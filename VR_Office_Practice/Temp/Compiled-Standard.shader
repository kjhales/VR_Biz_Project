// Compiled shader for PC, Mac & Linux Standalone

//////////////////////////////////////////////////////////////////////////
// 
// NOTE: This is *not* a valid shader file, the contents are provided just
// for information and for debugging purposes only.
// 
//////////////////////////////////////////////////////////////////////////
// Skipping shader variants that would not be included into build of current scene.

Shader "Standard" {
Properties {
 _Color ("Color", Color) = (1.000000,1.000000,1.000000,1.000000)
 _MainTex ("Albedo", 2D) = "white" { }
 _Cutoff ("Alpha Cutoff", Range(0.000000,1.000000)) = 0.500000
 _Glossiness ("Smoothness", Range(0.000000,1.000000)) = 0.500000
 _GlossMapScale ("Smoothness Scale", Range(0.000000,1.000000)) = 1.000000
[Enum(Metallic Alpha,0,Albedo Alpha,1)]  _SmoothnessTextureChannel ("Smoothness texture channel", Float) = 0.000000
[Gamma]  _Metallic ("Metallic", Range(0.000000,1.000000)) = 0.000000
 _MetallicGlossMap ("Metallic", 2D) = "white" { }
[ToggleOff]  _SpecularHighlights ("Specular Highlights", Float) = 1.000000
[ToggleOff]  _GlossyReflections ("Glossy Reflections", Float) = 1.000000
 _BumpScale ("Scale", Float) = 1.000000
 _BumpMap ("Normal Map", 2D) = "bump" { }
 _Parallax ("Height Scale", Range(0.005000,0.080000)) = 0.020000
 _ParallaxMap ("Height Map", 2D) = "black" { }
 _OcclusionStrength ("Strength", Range(0.000000,1.000000)) = 1.000000
 _OcclusionMap ("Occlusion", 2D) = "white" { }
 _EmissionColor ("Color", Color) = (0.000000,0.000000,0.000000,1.000000)
 _EmissionMap ("Emission", 2D) = "white" { }
 _DetailMask ("Detail Mask", 2D) = "white" { }
 _DetailAlbedoMap ("Detail Albedo x2", 2D) = "grey" { }
 _DetailNormalMapScale ("Scale", Float) = 1.000000
 _DetailNormalMap ("Normal Map", 2D) = "bump" { }
[Enum(UV0,0,UV1,1)]  _UVSec ("UV Set for secondary textures", Float) = 0.000000
[HideInInspector]  _Mode ("__mode", Float) = 0.000000
[HideInInspector]  _SrcBlend ("__src", Float) = 1.000000
[HideInInspector]  _DstBlend ("__dst", Float) = 0.000000
[HideInInspector]  _ZWrite ("__zw", Float) = 1.000000
}
SubShader { 
 LOD 300
 Tags { "RenderType"="Opaque" "PerformanceChecks"="False" }
 Pass {
  Name "FORWARD"
  Tags { "LIGHTMODE"="ForwardBase" "SHADOWSUPPORT"="true" "RenderType"="Opaque" "PerformanceChecks"="False" }
  ZWrite [_ZWrite]
  Blend [_SrcBlend] [_DstBlend]
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD8.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_2 = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_2 = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_2)));
    u_xlat16_0 = half4(u_xlat0.yzzx * u_xlat0.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_2) + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set CUBE Texture "unity_SpecCube0" to slot 2
Set CUBE Texture "unity_SpecCube1" to slot 3
Set 3D Texture "unity_ProbeVolumeSH" to slot 4

Constant Buffer "Globals" (294 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 176
  VectorHalf4 _WorldSpaceLightPos0 at 0
  VectorHalf4 unity_SHAr at 8
  VectorHalf4 unity_SHAg at 16
  VectorHalf4 unity_SHAb at 24
  Vector4 unity_SpecCube0_BoxMax at 32
  Vector4 unity_SpecCube0_BoxMin at 48
  Vector4 unity_SpecCube0_ProbePosition at 64
  VectorHalf4 unity_SpecCube0_HDR at 80
  Vector4 unity_SpecCube1_BoxMax at 96
  Vector4 unity_SpecCube1_BoxMin at 112
  Vector4 unity_SpecCube1_ProbePosition at 128
  VectorHalf4 unity_SpecCube1_HDR at 144
  Vector4 unity_ProbeVolumeParams at 160
  Vector3 unity_ProbeVolumeSizeInv at 240
  Vector3 unity_ProbeVolumeMin at 256
  VectorHalf4 _LightColor0 at 272
  VectorHalf4 _Color at 280
  ScalarHalf _Metallic at 288
  ScalarHalf _Glossiness at 290
  ScalarHalf _OcclusionStrength at 292
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    half4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    half4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texturecube<float, access::sample > unity_SpecCube0 [[ texture (2) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (2) ]] ,
    texturecube<float, access::sample > unity_SpecCube1 [[ texture (3) ]] ,
    sampler samplerunity_SpecCube1 [[ sampler (3) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (4) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    float4 u_xlat1;
    half3 u_xlat16_1;
    half4 u_xlat10_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    float3 u_xlat6;
    half3 u_xlat16_6;
    half4 u_xlat10_6;
    float3 u_xlat7;
    half3 u_xlat16_7;
    half4 u_xlat10_7;
    half4 u_xlat16_8;
    float3 u_xlat9;
    bool3 u_xlatb9;
    float3 u_xlat10;
    half3 u_xlat16_10;
    half3 u_xlat16_11;
    bool3 u_xlatb12;
    half3 u_xlat16_13;
    float3 u_xlat15;
    half3 u_xlat16_18;
    float3 u_xlat19;
    half3 u_xlat16_19;
    float u_xlat20;
    half u_xlat16_21;
    half u_xlat16_22;
    half u_xlat16_32;
    half u_xlat16_36;
    float u_xlat43;
    half u_xlat16_43;
    bool u_xlatb43;
    half u_xlat16_44;
    half u_xlat16_45;
    half u_xlat16_46;
    half u_xlat16_50;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_44 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_44));
    u_xlat16_45 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_45 = rsqrt(u_xlat16_45);
    u_xlat16_0.xyz = half3(half3(u_xlat16_45) * input.TEXCOORD4.xyz);
    u_xlat16_45 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_45 = rsqrt(u_xlat16_45);
    u_xlat16_4.xyz = half3(half3(u_xlat16_45) * input.TEXCOORD1.xyz);
    u_xlat16_1.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_46 = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_46 = half(u_xlat16_1.x * Globals._OcclusionStrength + u_xlat16_46);
    u_xlat16_5.x = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_19.x = dot(u_xlat16_4.xyz, u_xlat16_0.xyz);
    u_xlat16_19.x = half(u_xlat16_19.x + u_xlat16_19.x);
    u_xlat16_19.xyz = half3(u_xlat16_0.xyz * (-u_xlat16_19.xxx) + u_xlat16_4.xyz);
    u_xlatb1 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb1){
        u_xlatb1 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat15.xyz = input.TEXCOORD8.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat15.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD8.xxx + u_xlat15.xyz;
        u_xlat15.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD8.zzz + u_xlat15.xyz;
        u_xlat15.xyz = u_xlat15.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb1)) ? u_xlat15.xyz : input.TEXCOORD8.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat15.x = u_xlat1.y * 0.25;
        u_xlat6.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat20 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat15.x = max(u_xlat15.x, u_xlat6.x);
        u_xlat1.x = min(u_xlat20, u_xlat15.x);
        u_xlat10_6 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw));
        u_xlat7.xyz = u_xlat1.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_7 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat7.xyz));
        u_xlat1.xyz = u_xlat1.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_1 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xyz));
        u_xlat16_0.w = 1.0;
        u_xlat16_8.x = half(dot(float4(u_xlat10_6), float4(u_xlat16_0)));
        u_xlat16_8.y = half(dot(float4(u_xlat10_7), float4(u_xlat16_0)));
        u_xlat16_8.z = half(dot(float4(u_xlat10_1), float4(u_xlat16_0)));
    } else {
        u_xlat16_0.w = 1.0;
        u_xlat16_8.x = dot(Globals.unity_SHAr, u_xlat16_0);
        u_xlat16_8.y = dot(Globals.unity_SHAg, u_xlat16_0);
        u_xlat16_8.z = dot(Globals.unity_SHAb, u_xlat16_0);
    }
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz + input.TEXCOORD5.xyz);
    u_xlat16_8.xyz = half3(max(float3(u_xlat16_8.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_1.xyz = log2(u_xlat16_8.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_1.xyz = exp2(u_xlat16_1.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_1.xyz = half3(max(float3(u_xlat16_1.xyz), float3(0.0, 0.0, 0.0)));
    u_xlatb43 = 0.0<Globals.unity_SpecCube0_ProbePosition.w;
    if(u_xlatb43){
        u_xlat16_8.x = dot(u_xlat16_19.xyz, u_xlat16_19.xyz);
        u_xlat16_8.x = rsqrt(u_xlat16_8.x);
        u_xlat16_8.xyz = half3(u_xlat16_19.xyz * u_xlat16_8.xxx);
        u_xlat6.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMax.xyz;
        u_xlat6.xyz = u_xlat6.xyz / float3(u_xlat16_8.xyz);
        u_xlat7.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMin.xyz;
        u_xlat7.xyz = u_xlat7.xyz / float3(u_xlat16_8.xyz);
        u_xlatb9.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_8.xyz));
        u_xlat16_10.x = (u_xlatb9.x) ? half(u_xlat6.x) : half(u_xlat7.x);
        u_xlat16_10.y = (u_xlatb9.y) ? half(u_xlat6.y) : half(u_xlat7.y);
        u_xlat16_10.z = (u_xlatb9.z) ? half(u_xlat6.z) : half(u_xlat7.z);
        u_xlat16_50 = min(u_xlat16_10.y, u_xlat16_10.x);
        u_xlat16_50 = min(u_xlat16_10.z, u_xlat16_50);
        u_xlat6.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube0_ProbePosition.xyz);
        u_xlat6.xyz = float3(u_xlat16_8.xyz) * float3(u_xlat16_50) + u_xlat6.xyz;
        u_xlat16_6.xyz = half3(u_xlat6.xyz);
    } else {
        u_xlat16_6.xyz = u_xlat16_19.xyz;
    }
    u_xlat16_8.x = half((-float(u_xlat16_5.x)) * 0.699999988 + 1.70000005);
    u_xlat16_8.x = half(u_xlat16_5.x * u_xlat16_8.x);
    u_xlat16_8.x = half(float(u_xlat16_8.x) * 6.0);
    u_xlat10_6 = half4(unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_6.xyz), level(float(u_xlat16_8.x))));
    u_xlatb43 = Globals.unity_SpecCube0_HDR.w==1.0;
    u_xlat16_22 = (u_xlatb43) ? half(u_xlat10_6.w) : 1.0;
    u_xlat16_22 = half(u_xlat16_22 * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_10.xyz = half3(float3(u_xlat10_6.xyz) * float3(u_xlat16_22));
    u_xlatb43 = Globals.unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb43){
        u_xlatb43 = 0.0<Globals.unity_SpecCube1_ProbePosition.w;
        if(u_xlatb43){
            u_xlat16_36 = dot(u_xlat16_19.xyz, u_xlat16_19.xyz);
            u_xlat16_36 = rsqrt(u_xlat16_36);
            u_xlat16_11.xyz = half3(u_xlat16_19.xyz * half3(u_xlat16_36));
            u_xlat7.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMax.xyz;
            u_xlat7.xyz = u_xlat7.xyz / float3(u_xlat16_11.xyz);
            u_xlat9.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMin.xyz;
            u_xlat9.xyz = u_xlat9.xyz / float3(u_xlat16_11.xyz);
            u_xlatb12.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_11.xyz));
            u_xlat16_13.x = (u_xlatb12.x) ? half(u_xlat7.x) : half(u_xlat9.x);
            u_xlat16_13.y = (u_xlatb12.y) ? half(u_xlat7.y) : half(u_xlat9.y);
            u_xlat16_13.z = (u_xlatb12.z) ? half(u_xlat7.z) : half(u_xlat9.z);
            u_xlat16_36 = min(u_xlat16_13.y, u_xlat16_13.x);
            u_xlat16_36 = min(u_xlat16_13.z, u_xlat16_36);
            u_xlat7.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube1_ProbePosition.xyz);
            u_xlat19.xyz = float3(u_xlat16_11.xyz) * float3(u_xlat16_36) + u_xlat7.xyz;
            u_xlat16_19.xyz = half3(u_xlat19.xyz);
        }
        u_xlat10_7 = half4(unity_SpecCube1.sample(samplerunity_SpecCube0, float3(u_xlat16_19.xyz), level(float(u_xlat16_8.x))));
        u_xlatb43 = Globals.unity_SpecCube1_HDR.w==1.0;
        u_xlat16_19.x = (u_xlatb43) ? half(u_xlat10_7.w) : 1.0;
        u_xlat16_19.x = half(u_xlat16_19.x * Globals.unity_SpecCube1_HDR.x);
        u_xlat16_19.xyz = half3(float3(u_xlat10_7.xyz) * float3(u_xlat16_19.xxx));
        u_xlat16_7.xyz = half3(float3(u_xlat16_22) * float3(u_xlat10_6.xyz) + (-float3(u_xlat16_19.xyz)));
        u_xlat10.xyz = Globals.unity_SpecCube0_BoxMin.www * float3(u_xlat16_7.xyz) + float3(u_xlat16_19.xyz);
        u_xlat16_10.xyz = half3(u_xlat10.xyz);
    }
    u_xlat16_19.xyz = half3(half3(u_xlat16_46) * u_xlat16_10.xyz);
    u_xlat16_8.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_45) + Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_45 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_43 = half(max(float(u_xlat16_45), 0.00100000005));
    u_xlat16_45 = rsqrt(u_xlat16_43);
    u_xlat16_8.xyz = half3(half3(u_xlat16_45) * u_xlat16_8.xyz);
    u_xlat16_45 = dot(u_xlat16_0.xyz, (-u_xlat16_4.xyz));
    u_xlat16_4.x = dot(u_xlat16_0.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_18.x = dot(u_xlat16_0.xyz, u_xlat16_8.xyz);
    u_xlat16_18.x = clamp(u_xlat16_18.x, 0.0h, 1.0h);
    u_xlat16_32 = dot(Globals._WorldSpaceLightPos0.xyz, u_xlat16_8.xyz);
    u_xlat16_32 = clamp(u_xlat16_32, 0.0h, 1.0h);
    u_xlat16_8.x = half(u_xlat16_32 * u_xlat16_32);
    u_xlat16_8.x = dot(u_xlat16_8.xx, u_xlat16_5.xx);
    u_xlat16_8.x = half(float(u_xlat16_8.x) + -0.5);
    u_xlat16_22 = half((-float(u_xlat16_4.x)) + 1.0);
    u_xlat16_36 = half(u_xlat16_22 * u_xlat16_22);
    u_xlat16_36 = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_22 = half(u_xlat16_22 * u_xlat16_36);
    u_xlat16_22 = half(float(u_xlat16_8.x) * float(u_xlat16_22) + 1.0);
    u_xlat16_36 = half(-abs(float(u_xlat16_45)) + 1.0);
    u_xlat16_50 = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_50 = half(u_xlat16_50 * u_xlat16_50);
    u_xlat16_36 = half(u_xlat16_36 * u_xlat16_50);
    u_xlat16_8.x = half(float(u_xlat16_8.x) * float(u_xlat16_36) + 1.0);
    u_xlat16_8.x = half(u_xlat16_8.x * u_xlat16_22);
    u_xlat16_8.x = half(u_xlat16_4.x * u_xlat16_8.x);
    u_xlat16_22 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_50 = half((-float(u_xlat16_5.x)) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_10.x = half(abs(u_xlat16_45) * u_xlat16_50 + u_xlat16_22);
    u_xlat16_50 = half(u_xlat16_4.x * u_xlat16_50 + u_xlat16_22);
    u_xlat16_45 = half(abs(u_xlat16_45) * u_xlat16_50);
    u_xlat16_45 = half(u_xlat16_4.x * u_xlat16_10.x + u_xlat16_45);
    u_xlat16_43 = half(float(u_xlat16_45) + 9.99999975e-06);
    u_xlat16_43 = half(0.5 / float(u_xlat16_43));
    u_xlat16_45 = half(u_xlat16_22 * u_xlat16_22);
    u_xlat16_50 = half(u_xlat16_18.x * u_xlat16_45 + (-u_xlat16_18.x));
    u_xlat16_7.x = half(float(u_xlat16_50) * float(u_xlat16_18.x) + 1.0);
    u_xlat16_21 = half(float(u_xlat16_45) * 0.318309873);
    u_xlat16_7.x = half(float(u_xlat16_7.x) * float(u_xlat16_7.x) + 1.00000001e-07);
    u_xlat16_7.x = half(u_xlat16_21 / u_xlat16_7.x);
    u_xlat16_45 = half(u_xlat16_43 * u_xlat16_7.x);
    u_xlat16_43 = half(float(u_xlat16_45) * 3.14159274);
    u_xlat16_43 = half(max(float(u_xlat16_43), 9.99999975e-05));
    u_xlat16_43 = sqrt(u_xlat16_43);
    u_xlat16_45 = half(u_xlat16_4.x * u_xlat16_43);
    u_xlat16_4.x = half(u_xlat16_5.x * u_xlat16_22);
    u_xlat16_4.x = half((-float(u_xlat16_4.x)) * 0.280000001 + 1.0);
    u_xlat16_18.x = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb43 = u_xlat16_18.x!=0.0;
    u_xlat43 = u_xlatb43 ? 1.0 : float(0.0);
    u_xlat16_45 = half(u_xlat43 * float(u_xlat16_45));
    u_xlat16_44 = half((-u_xlat16_44) + Globals._Glossiness);
    u_xlat16_44 = half(float(u_xlat16_44) + 1.0);
    u_xlat16_44 = clamp(u_xlat16_44, 0.0h, 1.0h);
    u_xlat16_8.xyw = half3(u_xlat16_8.xxx * Globals._LightColor0.xyz);
    u_xlat16_8.xyw = half3(u_xlat16_1.xyz * half3(u_xlat16_46) + u_xlat16_8.xyw);
    u_xlat16_10.xyz = half3(half3(u_xlat16_45) * Globals._LightColor0.xyz);
    u_xlat16_45 = half((-float(u_xlat16_32)) + 1.0);
    u_xlat16_18.x = half(u_xlat16_45 * u_xlat16_45);
    u_xlat16_18.x = half(u_xlat16_18.x * u_xlat16_18.x);
    u_xlat16_45 = half(u_xlat16_45 * u_xlat16_18.x);
    u_xlat16_18.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_18.xyz = half3(u_xlat16_18.xyz * half3(u_xlat16_45) + u_xlat16_2.xyz);
    u_xlat16_18.xyz = half3(u_xlat16_18.xyz * u_xlat16_10.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * u_xlat16_8.xyw + u_xlat16_18.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_19.xyz * u_xlat16_4.xxx);
    u_xlat16_5.xyz = half3((-u_xlat16_2.xyz) + half3(u_xlat16_44));
    u_xlat16_2.xyz = half3(half3(u_xlat16_36) * u_xlat16_5.xyz + u_xlat16_2.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_2.xyz + u_xlat16_3.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD8.xyz = u_xlat0.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat6 = u_xlat0.y * u_xlat0.y;
    u_xlat6 = u_xlat0.x * u_xlat0.x + (-u_xlat6);
    u_xlat1 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat0.x = dot(unity_SHBr, u_xlat1);
    u_xlat0.y = dot(unity_SHBg, u_xlat1);
    u_xlat0.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat6) + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
float u_xlat4;
lowp vec4 u_xlat10_4;
vec4 u_xlat5;
lowp vec4 u_xlat10_5;
bool u_xlatb5;
vec3 u_xlat6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
lowp vec4 u_xlat10_7;
vec3 u_xlat8;
lowp vec4 u_xlat10_8;
vec3 u_xlat9;
bvec3 u_xlatb9;
vec3 u_xlat10;
bvec3 u_xlatb11;
vec3 u_xlat14;
float u_xlat15;
vec3 u_xlat16;
vec3 u_xlat17;
float u_xlat18;
float u_xlat26;
float u_xlat27;
float u_xlat36;
float u_xlat37;
float u_xlat38;
bool u_xlatb38;
float u_xlat39;
float u_xlat41;
bool u_xlatb41;
float u_xlat42;
bool u_xlatb42;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat36 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat36) * u_xlat1.xyz;
    u_xlat37 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat2.xyz = vec3(u_xlat37) * vs_TEXCOORD4.xyz;
    u_xlat37 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat3.xyz = vec3(u_xlat37) * vs_TEXCOORD1.xyz;
    u_xlat10_4 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat39 = (-_OcclusionStrength) + 1.0;
    u_xlat39 = u_xlat10_4.y * _OcclusionStrength + u_xlat39;
    u_xlat4 = (-_Glossiness) + 1.0;
    u_xlat16.x = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat16.x = u_xlat16.x + u_xlat16.x;
    u_xlat16.xyz = u_xlat2.xyz * (-u_xlat16.xxx) + u_xlat3.xyz;
    u_xlatb5 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb5){
        u_xlatb5 = unity_ProbeVolumeParams.y==1.0;
        u_xlat17.xyz = vs_TEXCOORD8.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat17.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD8.xxx + u_xlat17.xyz;
        u_xlat17.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD8.zzz + u_xlat17.xyz;
        u_xlat17.xyz = u_xlat17.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb5)) ? u_xlat17.xyz : vs_TEXCOORD8.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat17.x = u_xlat5.y * 0.25;
        u_xlat6.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat18 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat17.x = max(u_xlat17.x, u_xlat6.x);
        u_xlat5.x = min(u_xlat18, u_xlat17.x);
        u_xlat10_6 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
        u_xlat7.xyz = u_xlat5.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_7 = texture(unity_ProbeVolumeSH, u_xlat7.xyz);
        u_xlat5.xyz = u_xlat5.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_5 = texture(unity_ProbeVolumeSH, u_xlat5.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat10_6, u_xlat2);
        u_xlat6.y = dot(u_xlat10_7, u_xlat2);
        u_xlat6.z = dot(u_xlat10_5, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(unity_SHAr, u_xlat2);
        u_xlat6.y = dot(unity_SHAg, u_xlat2);
        u_xlat6.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat5.xyz = u_xlat6.xyz + vs_TEXCOORD5.xyz;
    u_xlat5.xyz = max(u_xlat5.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat5.xyz = log2(u_xlat5.xyz);
    u_xlat5.xyz = u_xlat5.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat5.xyz = exp2(u_xlat5.xyz);
    u_xlat5.xyz = u_xlat5.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat5.xyz = max(u_xlat5.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb38 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb38){
        u_xlat38 = dot(u_xlat16.xyz, u_xlat16.xyz);
        u_xlat38 = inversesqrt(u_xlat38);
        u_xlat6.xyz = vec3(u_xlat38) * u_xlat16.xyz;
        u_xlat7.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat7.xyz = u_xlat7.xyz / u_xlat6.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat6.xyz;
        u_xlatb9.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat6.xyzx).xyz;
        u_xlat7.x = (u_xlatb9.x) ? u_xlat7.x : u_xlat8.x;
        u_xlat7.y = (u_xlatb9.y) ? u_xlat7.y : u_xlat8.y;
        u_xlat7.z = (u_xlatb9.z) ? u_xlat7.z : u_xlat8.z;
        u_xlat38 = min(u_xlat7.y, u_xlat7.x);
        u_xlat38 = min(u_xlat7.z, u_xlat38);
        u_xlat7.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat6.xyz = u_xlat6.xyz * vec3(u_xlat38) + u_xlat7.xyz;
    } else {
        u_xlat6.xyz = u_xlat16.xyz;
    //ENDIF
    }
    u_xlat38 = (-u_xlat4) * 0.699999988 + 1.70000005;
    u_xlat38 = u_xlat38 * u_xlat4;
    u_xlat38 = u_xlat38 * 6.0;
    u_xlat10_6 = textureLod(unity_SpecCube0, u_xlat6.xyz, u_xlat38);
    u_xlatb41 = unity_SpecCube0_HDR.w==1.0;
    u_xlat41 = (u_xlatb41) ? u_xlat10_6.w : 1.0;
    u_xlat41 = u_xlat41 * unity_SpecCube0_HDR.x;
    u_xlat7.xyz = u_xlat10_6.xyz * vec3(u_xlat41);
    u_xlatb42 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb42){
        u_xlatb42 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb42){
            u_xlat42 = dot(u_xlat16.xyz, u_xlat16.xyz);
            u_xlat42 = inversesqrt(u_xlat42);
            u_xlat8.xyz = u_xlat16.xyz * vec3(u_xlat42);
            u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat9.xyz = u_xlat9.xyz / u_xlat8.xyz;
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat8.xyz;
            u_xlatb11.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat8.xyzx).xyz;
            u_xlat9.x = (u_xlatb11.x) ? u_xlat9.x : u_xlat10.x;
            u_xlat9.y = (u_xlatb11.y) ? u_xlat9.y : u_xlat10.y;
            u_xlat9.z = (u_xlatb11.z) ? u_xlat9.z : u_xlat10.z;
            u_xlat42 = min(u_xlat9.y, u_xlat9.x);
            u_xlat42 = min(u_xlat9.z, u_xlat42);
            u_xlat9.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat16.xyz = u_xlat8.xyz * vec3(u_xlat42) + u_xlat9.xyz;
        //ENDIF
        }
        u_xlat10_8 = textureLod(unity_SpecCube1, u_xlat16.xyz, u_xlat38);
        u_xlatb38 = unity_SpecCube1_HDR.w==1.0;
        u_xlat38 = (u_xlatb38) ? u_xlat10_8.w : 1.0;
        u_xlat38 = u_xlat38 * unity_SpecCube1_HDR.x;
        u_xlat16.xyz = u_xlat10_8.xyz * vec3(u_xlat38);
        u_xlat6.xyz = vec3(u_xlat41) * u_xlat10_6.xyz + (-u_xlat16.xyz);
        u_xlat7.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat16.xyz;
    //ENDIF
    }
    u_xlat16.xyz = vec3(u_xlat39) * u_xlat7.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat37) + _WorldSpaceLightPos0.xyz;
    u_xlat37 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat37 = max(u_xlat37, 0.00100000005);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat6.xyz = vec3(u_xlat37) * u_xlat6.xyz;
    u_xlat37 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat38 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat38 = clamp(u_xlat38, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat14.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat14.x = clamp(u_xlat14.x, 0.0, 1.0);
    u_xlat26 = u_xlat14.x * u_xlat14.x;
    u_xlat26 = dot(vec2(u_xlat26), vec2(u_xlat4));
    u_xlat26 = u_xlat26 + -0.5;
    u_xlat3.x = (-u_xlat38) + 1.0;
    u_xlat15 = u_xlat3.x * u_xlat3.x;
    u_xlat15 = u_xlat15 * u_xlat15;
    u_xlat3.x = u_xlat3.x * u_xlat15;
    u_xlat3.x = u_xlat26 * u_xlat3.x + 1.0;
    u_xlat15 = -abs(u_xlat37) + 1.0;
    u_xlat27 = u_xlat15 * u_xlat15;
    u_xlat27 = u_xlat27 * u_xlat27;
    u_xlat15 = u_xlat15 * u_xlat27;
    u_xlat26 = u_xlat26 * u_xlat15 + 1.0;
    u_xlat26 = u_xlat26 * u_xlat3.x;
    u_xlat26 = u_xlat38 * u_xlat26;
    u_xlat3.x = u_xlat4 * u_xlat4;
    u_xlat27 = (-u_xlat4) * u_xlat4 + 1.0;
    u_xlat41 = abs(u_xlat37) * u_xlat27 + u_xlat3.x;
    u_xlat27 = u_xlat38 * u_xlat27 + u_xlat3.x;
    u_xlat37 = abs(u_xlat37) * u_xlat27;
    u_xlat37 = u_xlat38 * u_xlat41 + u_xlat37;
    u_xlat37 = u_xlat37 + 9.99999975e-06;
    u_xlat37 = 0.5 / u_xlat37;
    u_xlat27 = u_xlat3.x * u_xlat3.x;
    u_xlat41 = u_xlat2.x * u_xlat27 + (-u_xlat2.x);
    u_xlat2.x = u_xlat41 * u_xlat2.x + 1.0;
    u_xlat27 = u_xlat27 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat27 / u_xlat2.x;
    u_xlat37 = u_xlat37 * u_xlat2.x;
    u_xlat37 = u_xlat37 * 3.14159274;
    u_xlat37 = max(u_xlat37, 9.99999975e-05);
    u_xlat37 = sqrt(u_xlat37);
    u_xlat37 = u_xlat38 * u_xlat37;
    u_xlat2.x = u_xlat3.x * u_xlat4;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat38 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb38 = u_xlat38!=0.0;
    u_xlat38 = u_xlatb38 ? 1.0 : float(0.0);
    u_xlat37 = u_xlat37 * u_xlat38;
    u_xlat36 = (-u_xlat36) + _Glossiness;
    u_xlat36 = u_xlat36 + 1.0;
    u_xlat36 = clamp(u_xlat36, 0.0, 1.0);
    u_xlat6.xyz = vec3(u_xlat26) * _LightColor0.xyz;
    u_xlat3.xzw = u_xlat5.xyz * vec3(u_xlat39) + u_xlat6.xyz;
    u_xlat5.xyz = vec3(u_xlat37) * _LightColor0.xyz;
    u_xlat37 = (-u_xlat14.x) + 1.0;
    u_xlat14.x = u_xlat37 * u_xlat37;
    u_xlat14.x = u_xlat14.x * u_xlat14.x;
    u_xlat37 = u_xlat37 * u_xlat14.x;
    u_xlat14.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat14.xyz = u_xlat14.xyz * vec3(u_xlat37) + u_xlat0.xyz;
    u_xlat14.xyz = u_xlat14.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat14.xyz;
    u_xlat2.xyz = u_xlat16.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat36);
    u_xlat0.xyz = vec3(u_xlat15) * u_xlat3.xzw + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL DIRLIGHTMAP_COMBINED DYNAMICLIGHTMAP_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 16
  Matrix4x4 unity_ObjectToWorld at 80
  Matrix4x4 unity_WorldToObject at 144
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_WorldTransformParams at 208
  Vector4 unity_DynamicLightmapST at 224
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    float2 TEXCOORD2 [[ attribute(4) ]] ;
    half4 TANGENT0 [[ attribute(5) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    float u_xlat9;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD8.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat1.xyz = float3(u_xlat9) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.w = 0.0;
    u_xlat0.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    output.TEXCOORD5.zw = half2(u_xlat0.xy);
    output.TEXCOORD5.xy = half2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "unity_DynamicLightmap" to slot 2
Set 2D Texture "unity_DynamicDirectionality" to slot 3
Set CUBE Texture "unity_SpecCube0" to slot 4
Set CUBE Texture "unity_SpecCube1" to slot 5

Constant Buffer "Globals" (166 bytes) on slot 0 {
  VectorHalf4 _WorldSpaceLightPos0 at 0
  Vector4 unity_SpecCube0_BoxMax at 16
  Vector4 unity_SpecCube0_BoxMin at 32
  Vector4 unity_SpecCube0_ProbePosition at 48
  VectorHalf4 unity_SpecCube0_HDR at 64
  Vector4 unity_SpecCube1_BoxMax at 80
  Vector4 unity_SpecCube1_BoxMin at 96
  Vector4 unity_SpecCube1_ProbePosition at 112
  VectorHalf4 unity_SpecCube1_HDR at 128
  VectorHalf4 unity_DynamicLightmap_HDR at 136
  VectorHalf4 _LightColor0 at 144
  VectorHalf4 _Color at 152
  ScalarHalf _Metallic at 160
  ScalarHalf _Glossiness at 162
  ScalarHalf _OcclusionStrength at 164
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    half4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    half4 unity_SpecCube1_HDR;
    half4 unity_DynamicLightmap_HDR;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<float, access::sample > unity_DynamicLightmap [[ texture (2) ]] ,
    sampler samplerunity_DynamicLightmap [[ sampler (2) ]] ,
    texture2d<float, access::sample > unity_DynamicDirectionality [[ texture (3) ]] ,
    sampler samplerunity_DynamicDirectionality [[ sampler (3) ]] ,
    texturecube<float, access::sample > unity_SpecCube0 [[ texture (4) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (4) ]] ,
    texturecube<float, access::sample > unity_SpecCube1 [[ texture (5) ]] ,
    sampler samplerunity_SpecCube1 [[ sampler (5) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half4 u_xlat10_0;
    float3 u_xlat1;
    half3 u_xlat16_1;
    half4 u_xlat10_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half4 u_xlat16_5;
    float3 u_xlat6;
    half3 u_xlat16_6;
    half4 u_xlat10_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    float3 u_xlat9;
    half3 u_xlat16_9;
    float3 u_xlat10;
    bool3 u_xlatb10;
    half3 u_xlat16_11;
    bool3 u_xlatb12;
    half3 u_xlat16_13;
    half3 u_xlat16_18;
    half u_xlat16_19;
    float3 u_xlat21;
    half3 u_xlat16_21;
    half u_xlat16_23;
    half u_xlat16_32;
    half u_xlat16_33;
    float u_xlat42;
    half u_xlat16_42;
    bool u_xlatb42;
    half u_xlat16_44;
    half u_xlat16_45;
    half u_xlat16_46;
    half u_xlat16_47;
    half u_xlat16_48;
    half u_xlat16_49;
    half u_xlat16_53;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_44 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_44));
    u_xlat16_45 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_45 = rsqrt(u_xlat16_45);
    u_xlat16_4.xyz = half3(half3(u_xlat16_45) * input.TEXCOORD4.xyz);
    u_xlat16_45 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_45 = rsqrt(u_xlat16_45);
    u_xlat16_5.xyz = half3(half3(u_xlat16_45) * input.TEXCOORD1.xyz);
    u_xlat16_0.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_46 = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_46 = half(u_xlat16_0.x * Globals._OcclusionStrength + u_xlat16_46);
    u_xlat16_47 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_6.x = dot(u_xlat16_5.xyz, u_xlat16_4.xyz);
    u_xlat16_6.x = half(u_xlat16_6.x + u_xlat16_6.x);
    u_xlat16_6.xyz = half3(u_xlat16_4.xyz * (-u_xlat16_6.xxx) + u_xlat16_5.xyz);
    u_xlat10_0 = half4(unity_DynamicLightmap.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_48 = half(float(u_xlat10_0.w) * float(Globals.unity_DynamicLightmap_HDR.x));
    u_xlat16_7.xyz = half3(float3(u_xlat10_0.xyz) * float3(u_xlat16_48));
    u_xlat16_7.xyz = log2(u_xlat16_7.xyz);
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * Globals.unity_DynamicLightmap_HDR.yyy);
    u_xlat16_7.xyz = exp2(u_xlat16_7.xyz);
    u_xlat10_0 = half4(unity_DynamicDirectionality.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_8.xyz = half3(float3(u_xlat10_0.xyz) + float3(-0.5, -0.5, -0.5));
    u_xlat16_48 = dot(u_xlat16_4.xyz, u_xlat16_8.xyz);
    u_xlat16_48 = half(float(u_xlat16_48) + 0.5);
    u_xlat16_7.xyz = half3(half3(u_xlat16_48) * u_xlat16_7.xyz);
    u_xlat16_0.x = half(max(float(u_xlat10_0.w), 9.99999975e-05));
    u_xlat16_0.xyz = half3(u_xlat16_7.xyz / u_xlat16_0.xxx);
    u_xlatb42 = 0.0<Globals.unity_SpecCube0_ProbePosition.w;
    if(u_xlatb42){
        u_xlat16_48 = dot(u_xlat16_6.xyz, u_xlat16_6.xyz);
        u_xlat16_48 = rsqrt(u_xlat16_48);
        u_xlat16_7.xyz = half3(half3(u_xlat16_48) * u_xlat16_6.xyz);
        u_xlat1.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMax.xyz;
        u_xlat1.xyz = u_xlat1.xyz / float3(u_xlat16_7.xyz);
        u_xlat9.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMin.xyz;
        u_xlat9.xyz = u_xlat9.xyz / float3(u_xlat16_7.xyz);
        u_xlatb10.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_7.xyz));
        u_xlat16_11.x = (u_xlatb10.x) ? half(u_xlat1.x) : half(u_xlat9.x);
        u_xlat16_11.y = (u_xlatb10.y) ? half(u_xlat1.y) : half(u_xlat9.y);
        u_xlat16_11.z = (u_xlatb10.z) ? half(u_xlat1.z) : half(u_xlat9.z);
        u_xlat16_48 = min(u_xlat16_11.y, u_xlat16_11.x);
        u_xlat16_48 = min(u_xlat16_11.z, u_xlat16_48);
        u_xlat1.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube0_ProbePosition.xyz);
        u_xlat1.xyz = float3(u_xlat16_7.xyz) * float3(u_xlat16_48) + u_xlat1.xyz;
        u_xlat16_1.xyz = half3(u_xlat1.xyz);
    } else {
        u_xlat16_1.xyz = u_xlat16_6.xyz;
    }
    u_xlat16_48 = half((-float(u_xlat16_47)) * 0.699999988 + 1.70000005);
    u_xlat16_48 = half(u_xlat16_47 * u_xlat16_48);
    u_xlat16_48 = half(float(u_xlat16_48) * 6.0);
    u_xlat10_1 = half4(unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_1.xyz), level(float(u_xlat16_48))));
    u_xlatb42 = Globals.unity_SpecCube0_HDR.w==1.0;
    u_xlat16_7.x = (u_xlatb42) ? half(u_xlat10_1.w) : 1.0;
    u_xlat16_7.x = half(u_xlat16_7.x * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_21.xyz = half3(float3(u_xlat10_1.xyz) * float3(u_xlat16_7.xxx));
    u_xlatb42 = Globals.unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb42){
        u_xlatb42 = 0.0<Globals.unity_SpecCube1_ProbePosition.w;
        if(u_xlatb42){
            u_xlat16_11.x = dot(u_xlat16_6.xyz, u_xlat16_6.xyz);
            u_xlat16_11.x = rsqrt(u_xlat16_11.x);
            u_xlat16_11.xyz = half3(u_xlat16_6.xyz * u_xlat16_11.xxx);
            u_xlat9.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMax.xyz;
            u_xlat9.xyz = u_xlat9.xyz / float3(u_xlat16_11.xyz);
            u_xlat10.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMin.xyz;
            u_xlat10.xyz = u_xlat10.xyz / float3(u_xlat16_11.xyz);
            u_xlatb12.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_11.xyz));
            u_xlat16_13.x = (u_xlatb12.x) ? half(u_xlat9.x) : half(u_xlat10.x);
            u_xlat16_13.y = (u_xlatb12.y) ? half(u_xlat9.y) : half(u_xlat10.y);
            u_xlat16_13.z = (u_xlatb12.z) ? half(u_xlat9.z) : half(u_xlat10.z);
            u_xlat16_53 = min(u_xlat16_13.y, u_xlat16_13.x);
            u_xlat16_53 = min(u_xlat16_13.z, u_xlat16_53);
            u_xlat9.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube1_ProbePosition.xyz);
            u_xlat6.xyz = float3(u_xlat16_11.xyz) * float3(u_xlat16_53) + u_xlat9.xyz;
            u_xlat16_6.xyz = half3(u_xlat6.xyz);
        }
        u_xlat10_6 = half4(unity_SpecCube1.sample(samplerunity_SpecCube0, float3(u_xlat16_6.xyz), level(float(u_xlat16_48))));
        u_xlatb42 = Globals.unity_SpecCube1_HDR.w==1.0;
        u_xlat16_11.x = (u_xlatb42) ? half(u_xlat10_6.w) : 1.0;
        u_xlat16_11.x = half(u_xlat16_11.x * Globals.unity_SpecCube1_HDR.x);
        u_xlat16_11.xyz = half3(float3(u_xlat10_6.xyz) * float3(u_xlat16_11.xxx));
        u_xlat16_9.xyz = half3(float3(u_xlat16_7.xxx) * float3(u_xlat10_1.xyz) + (-float3(u_xlat16_11.xyz)));
        u_xlat21.xyz = Globals.unity_SpecCube0_BoxMin.www * float3(u_xlat16_9.xyz) + float3(u_xlat16_11.xyz);
        u_xlat16_21.xyz = half3(u_xlat21.xyz);
    }
    u_xlat16_7.xyz = half3(half3(u_xlat16_46) * u_xlat16_21.xyz);
    u_xlat16_11.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_45) + Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_45 = dot(u_xlat16_11.xyz, u_xlat16_11.xyz);
    u_xlat16_42 = half(max(float(u_xlat16_45), 0.00100000005));
    u_xlat16_45 = rsqrt(u_xlat16_42);
    u_xlat16_11.xyz = half3(half3(u_xlat16_45) * u_xlat16_11.xyz);
    u_xlat16_45 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_5.x = dot(u_xlat16_4.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_5.x = clamp(u_xlat16_5.x, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_11.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_18.x = dot(Globals._WorldSpaceLightPos0.xyz, u_xlat16_11.xyz);
    u_xlat16_18.x = clamp(u_xlat16_18.x, 0.0h, 1.0h);
    u_xlat16_32 = half(u_xlat16_18.x * u_xlat16_18.x);
    u_xlat16_32 = dot(half2(u_xlat16_32), half2(u_xlat16_47));
    u_xlat16_32 = half(float(u_xlat16_32) + -0.5);
    u_xlat16_19 = half((-float(u_xlat16_5.x)) + 1.0);
    u_xlat16_33 = half(u_xlat16_19 * u_xlat16_19);
    u_xlat16_33 = half(u_xlat16_33 * u_xlat16_33);
    u_xlat16_19 = half(u_xlat16_19 * u_xlat16_33);
    u_xlat16_19 = half(float(u_xlat16_32) * float(u_xlat16_19) + 1.0);
    u_xlat16_33 = half(-abs(float(u_xlat16_45)) + 1.0);
    u_xlat16_49 = half(u_xlat16_33 * u_xlat16_33);
    u_xlat16_49 = half(u_xlat16_49 * u_xlat16_49);
    u_xlat16_33 = half(u_xlat16_33 * u_xlat16_49);
    u_xlat16_32 = half(float(u_xlat16_32) * float(u_xlat16_33) + 1.0);
    u_xlat16_32 = half(u_xlat16_32 * u_xlat16_19);
    u_xlat16_32 = half(u_xlat16_5.x * u_xlat16_32);
    u_xlat16_19 = half(u_xlat16_47 * u_xlat16_47);
    u_xlat16_49 = half((-float(u_xlat16_47)) * float(u_xlat16_47) + 1.0);
    u_xlat16_11.x = half(abs(u_xlat16_45) * u_xlat16_49 + u_xlat16_19);
    u_xlat16_49 = half(u_xlat16_5.x * u_xlat16_49 + u_xlat16_19);
    u_xlat16_45 = half(abs(u_xlat16_45) * u_xlat16_49);
    u_xlat16_45 = half(u_xlat16_5.x * u_xlat16_11.x + u_xlat16_45);
    u_xlat16_42 = half(float(u_xlat16_45) + 9.99999975e-06);
    u_xlat16_42 = half(0.5 / float(u_xlat16_42));
    u_xlat16_45 = half(u_xlat16_19 * u_xlat16_19);
    u_xlat16_49 = half(u_xlat16_4.x * u_xlat16_45 + (-u_xlat16_4.x));
    u_xlat16_9.x = half(float(u_xlat16_49) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_23 = half(float(u_xlat16_45) * 0.318309873);
    u_xlat16_9.x = half(float(u_xlat16_9.x) * float(u_xlat16_9.x) + 1.00000001e-07);
    u_xlat16_9.x = half(u_xlat16_23 / u_xlat16_9.x);
    u_xlat16_45 = half(u_xlat16_42 * u_xlat16_9.x);
    u_xlat16_42 = half(float(u_xlat16_45) * 3.14159274);
    u_xlat16_42 = half(max(float(u_xlat16_42), 9.99999975e-05));
    u_xlat16_42 = sqrt(u_xlat16_42);
    u_xlat16_45 = half(u_xlat16_5.x * u_xlat16_42);
    u_xlat16_4.x = half(u_xlat16_19 * u_xlat16_47);
    u_xlat16_4.x = half((-float(u_xlat16_4.x)) * 0.280000001 + 1.0);
    u_xlat16_5.x = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb42 = u_xlat16_5.x!=0.0;
    u_xlat42 = u_xlatb42 ? 1.0 : float(0.0);
    u_xlat16_45 = half(u_xlat42 * float(u_xlat16_45));
    u_xlat16_44 = half((-u_xlat16_44) + Globals._Glossiness);
    u_xlat16_44 = half(float(u_xlat16_44) + 1.0);
    u_xlat16_44 = clamp(u_xlat16_44, 0.0h, 1.0h);
    u_xlat16_5.xyw = half3(half3(u_xlat16_32) * Globals._LightColor0.xyz);
    u_xlat16_5.xyw = half3(u_xlat16_0.xyz * half3(u_xlat16_46) + u_xlat16_5.xyw);
    u_xlat16_11.xyz = half3(half3(u_xlat16_45) * Globals._LightColor0.xyz);
    u_xlat16_45 = half((-float(u_xlat16_18.x)) + 1.0);
    u_xlat16_18.x = half(u_xlat16_45 * u_xlat16_45);
    u_xlat16_18.x = half(u_xlat16_18.x * u_xlat16_18.x);
    u_xlat16_45 = half(u_xlat16_45 * u_xlat16_18.x);
    u_xlat16_18.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_18.xyz = half3(u_xlat16_18.xyz * half3(u_xlat16_45) + u_xlat16_2.xyz);
    u_xlat16_18.xyz = half3(u_xlat16_18.xyz * u_xlat16_11.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * u_xlat16_5.xyw + u_xlat16_18.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_7.xyz * u_xlat16_4.xxx);
    u_xlat16_5.xyw = half3((-u_xlat16_2.xyz) + half3(u_xlat16_44));
    u_xlat16_2.xyz = half3(half3(u_xlat16_33) * u_xlat16_5.xyw + u_xlat16_2.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_2.xyz + u_xlat16_3.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD8.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.w = 0.0;
    vs_TEXCOORD5.zw = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    vs_TEXCOORD5.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_DynamicLightmap_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_DynamicLightmap;
uniform  sampler2D unity_DynamicDirectionality;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
vec3 u_xlat2;
vec4 u_xlat3;
bool u_xlatb3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
lowp vec4 u_xlat10_5;
vec3 u_xlat6;
mediump vec3 u_xlat16_6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
vec3 u_xlat8;
vec3 u_xlat9;
bvec3 u_xlatb9;
vec3 u_xlat10;
bvec3 u_xlatb11;
vec3 u_xlat14;
float u_xlat15;
float u_xlat26;
float u_xlat27;
float u_xlat36;
float u_xlat37;
float u_xlat38;
float u_xlat39;
float u_xlat40;
mediump float u_xlat16_40;
bool u_xlatb40;
float u_xlat41;
bool u_xlatb41;
float u_xlat42;
bool u_xlatb42;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat36 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat36) * u_xlat1.xyz;
    u_xlat37 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat2.xyz = vec3(u_xlat37) * vs_TEXCOORD4.xyz;
    u_xlat37 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat3.xyz = vec3(u_xlat37) * vs_TEXCOORD1.xyz;
    u_xlat10_4 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat38 = (-_OcclusionStrength) + 1.0;
    u_xlat38 = u_xlat10_4.y * _OcclusionStrength + u_xlat38;
    u_xlat39 = (-_Glossiness) + 1.0;
    u_xlat4.x = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat4.x = u_xlat4.x + u_xlat4.x;
    u_xlat4.xyz = u_xlat2.xyz * (-u_xlat4.xxx) + u_xlat3.xyz;
    u_xlat10_5 = texture(unity_DynamicLightmap, vs_TEXCOORD5.zw);
    u_xlat40 = u_xlat10_5.w * unity_DynamicLightmap_HDR.x;
    u_xlat5.xyz = u_xlat10_5.xyz * vec3(u_xlat40);
    u_xlat5.xyz = log2(u_xlat5.xyz);
    u_xlat5.xyz = u_xlat5.xyz * unity_DynamicLightmap_HDR.yyy;
    u_xlat5.xyz = exp2(u_xlat5.xyz);
    u_xlat10_6 = texture(unity_DynamicDirectionality, vs_TEXCOORD5.zw);
    u_xlat16_6.xyz = u_xlat10_6.xyz + vec3(-0.5, -0.5, -0.5);
    u_xlat40 = dot(u_xlat2.xyz, u_xlat16_6.xyz);
    u_xlat40 = u_xlat40 + 0.5;
    u_xlat5.xyz = vec3(u_xlat40) * u_xlat5.xyz;
    u_xlat16_40 = max(u_xlat10_6.w, 9.99999975e-05);
    u_xlat5.xyz = u_xlat5.xyz / vec3(u_xlat16_40);
    u_xlatb40 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb40){
        u_xlat40 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat40 = inversesqrt(u_xlat40);
        u_xlat6.xyz = vec3(u_xlat40) * u_xlat4.xyz;
        u_xlat7.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat7.xyz = u_xlat7.xyz / u_xlat6.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat6.xyz;
        u_xlatb9.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat6.xyzx).xyz;
        u_xlat7.x = (u_xlatb9.x) ? u_xlat7.x : u_xlat8.x;
        u_xlat7.y = (u_xlatb9.y) ? u_xlat7.y : u_xlat8.y;
        u_xlat7.z = (u_xlatb9.z) ? u_xlat7.z : u_xlat8.z;
        u_xlat40 = min(u_xlat7.y, u_xlat7.x);
        u_xlat40 = min(u_xlat7.z, u_xlat40);
        u_xlat7.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat6.xyz = u_xlat6.xyz * vec3(u_xlat40) + u_xlat7.xyz;
    } else {
        u_xlat6.xyz = u_xlat4.xyz;
    //ENDIF
    }
    u_xlat40 = (-u_xlat39) * 0.699999988 + 1.70000005;
    u_xlat40 = u_xlat39 * u_xlat40;
    u_xlat40 = u_xlat40 * 6.0;
    u_xlat10_6 = textureLod(unity_SpecCube0, u_xlat6.xyz, u_xlat40);
    u_xlatb41 = unity_SpecCube0_HDR.w==1.0;
    u_xlat41 = (u_xlatb41) ? u_xlat10_6.w : 1.0;
    u_xlat41 = u_xlat41 * unity_SpecCube0_HDR.x;
    u_xlat7.xyz = u_xlat10_6.xyz * vec3(u_xlat41);
    u_xlatb42 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb42){
        u_xlatb42 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb42){
            u_xlat42 = dot(u_xlat4.xyz, u_xlat4.xyz);
            u_xlat42 = inversesqrt(u_xlat42);
            u_xlat8.xyz = u_xlat4.xyz * vec3(u_xlat42);
            u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat9.xyz = u_xlat9.xyz / u_xlat8.xyz;
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat8.xyz;
            u_xlatb11.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat8.xyzx).xyz;
            u_xlat9.x = (u_xlatb11.x) ? u_xlat9.x : u_xlat10.x;
            u_xlat9.y = (u_xlatb11.y) ? u_xlat9.y : u_xlat10.y;
            u_xlat9.z = (u_xlatb11.z) ? u_xlat9.z : u_xlat10.z;
            u_xlat42 = min(u_xlat9.y, u_xlat9.x);
            u_xlat42 = min(u_xlat9.z, u_xlat42);
            u_xlat9.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat4.xyz = u_xlat8.xyz * vec3(u_xlat42) + u_xlat9.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat4.xyz, u_xlat40);
        u_xlatb42 = unity_SpecCube1_HDR.w==1.0;
        u_xlat40 = (u_xlatb42) ? u_xlat10_4.w : 1.0;
        u_xlat40 = u_xlat40 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat40);
        u_xlat6.xyz = vec3(u_xlat41) * u_xlat10_6.xyz + (-u_xlat4.xyz);
        u_xlat7.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = vec3(u_xlat38) * u_xlat7.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat37) + _WorldSpaceLightPos0.xyz;
    u_xlat37 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat37 = max(u_xlat37, 0.00100000005);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat6.xyz = vec3(u_xlat37) * u_xlat6.xyz;
    u_xlat37 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat3.x = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat3.x = clamp(u_xlat3.x, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat14.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat14.x = clamp(u_xlat14.x, 0.0, 1.0);
    u_xlat26 = u_xlat14.x * u_xlat14.x;
    u_xlat26 = dot(vec2(u_xlat26), vec2(u_xlat39));
    u_xlat26 = u_xlat26 + -0.5;
    u_xlat15 = (-u_xlat3.x) + 1.0;
    u_xlat27 = u_xlat15 * u_xlat15;
    u_xlat27 = u_xlat27 * u_xlat27;
    u_xlat15 = u_xlat15 * u_xlat27;
    u_xlat15 = u_xlat26 * u_xlat15 + 1.0;
    u_xlat27 = -abs(u_xlat37) + 1.0;
    u_xlat40 = u_xlat27 * u_xlat27;
    u_xlat40 = u_xlat40 * u_xlat40;
    u_xlat27 = u_xlat27 * u_xlat40;
    u_xlat26 = u_xlat26 * u_xlat27 + 1.0;
    u_xlat26 = u_xlat26 * u_xlat15;
    u_xlat26 = u_xlat3.x * u_xlat26;
    u_xlat15 = u_xlat39 * u_xlat39;
    u_xlat40 = (-u_xlat39) * u_xlat39 + 1.0;
    u_xlat41 = abs(u_xlat37) * u_xlat40 + u_xlat15;
    u_xlat40 = u_xlat3.x * u_xlat40 + u_xlat15;
    u_xlat37 = abs(u_xlat37) * u_xlat40;
    u_xlat37 = u_xlat3.x * u_xlat41 + u_xlat37;
    u_xlat37 = u_xlat37 + 9.99999975e-06;
    u_xlat37 = 0.5 / u_xlat37;
    u_xlat40 = u_xlat15 * u_xlat15;
    u_xlat41 = u_xlat2.x * u_xlat40 + (-u_xlat2.x);
    u_xlat2.x = u_xlat41 * u_xlat2.x + 1.0;
    u_xlat40 = u_xlat40 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat40 / u_xlat2.x;
    u_xlat37 = u_xlat37 * u_xlat2.x;
    u_xlat37 = u_xlat37 * 3.14159274;
    u_xlat37 = max(u_xlat37, 9.99999975e-05);
    u_xlat37 = sqrt(u_xlat37);
    u_xlat37 = u_xlat3.x * u_xlat37;
    u_xlat2.x = u_xlat15 * u_xlat39;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat3.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb3 = u_xlat3.x!=0.0;
    u_xlat3.x = u_xlatb3 ? 1.0 : float(0.0);
    u_xlat37 = u_xlat37 * u_xlat3.x;
    u_xlat36 = (-u_xlat36) + _Glossiness;
    u_xlat36 = u_xlat36 + 1.0;
    u_xlat36 = clamp(u_xlat36, 0.0, 1.0);
    u_xlat3.xyw = vec3(u_xlat26) * _LightColor0.xyz;
    u_xlat3.xyw = u_xlat5.xyz * vec3(u_xlat38) + u_xlat3.xyw;
    u_xlat5.xyz = vec3(u_xlat37) * _LightColor0.xyz;
    u_xlat37 = (-u_xlat14.x) + 1.0;
    u_xlat14.x = u_xlat37 * u_xlat37;
    u_xlat14.x = u_xlat14.x * u_xlat14.x;
    u_xlat37 = u_xlat37 * u_xlat14.x;
    u_xlat14.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat14.xyz = u_xlat14.xyz * vec3(u_xlat37) + u_xlat0.xyz;
    u_xlat14.xyz = u_xlat14.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xyw + u_xlat14.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xyw = (-u_xlat0.xyz) + vec3(u_xlat36);
    u_xlat0.xyz = vec3(u_xlat27) * u_xlat3.xyw + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 64
  Matrix4x4 unity_ObjectToWorld at 128
  Matrix4x4 unity_WorldToObject at 192
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 unity_SHBr at 32
  VectorHalf4 unity_SHBg at 40
  VectorHalf4 unity_SHBb at 48
  VectorHalf4 unity_SHC at 56
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float3 u_xlat1;
    half4 u_xlat16_1;
    bool u_xlatb1;
    float4 u_xlat2;
    half u_xlat16_3;
    half3 u_xlat16_4;
    float u_xlat16;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD8.xyz = u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat16 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat1.xyz = float3(u_xlat16) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_3 = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_3 = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_3)));
    u_xlat16_1 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_4.x = dot(Globals.unity_SHBr, u_xlat16_1);
    u_xlat16_4.y = dot(Globals.unity_SHBg, u_xlat16_1);
    u_xlat16_4.z = dot(Globals.unity_SHBb, u_xlat16_1);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_3) + u_xlat16_4.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat2.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat2.zz + u_xlat2.xw;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_OcclusionMap" to slot 2
Set CUBE Texture "unity_SpecCube0" to slot 3
Set CUBE Texture "unity_SpecCube1" to slot 4
Set 3D Texture "unity_ProbeVolumeSH" to slot 5

Constant Buffer "Globals" (294 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 176
  VectorHalf4 _WorldSpaceLightPos0 at 0
  VectorHalf4 unity_SHAr at 8
  VectorHalf4 unity_SHAg at 16
  VectorHalf4 unity_SHAb at 24
  Vector4 unity_SpecCube0_BoxMax at 32
  Vector4 unity_SpecCube0_BoxMin at 48
  Vector4 unity_SpecCube0_ProbePosition at 64
  VectorHalf4 unity_SpecCube0_HDR at 80
  Vector4 unity_SpecCube1_BoxMax at 96
  Vector4 unity_SpecCube1_BoxMin at 112
  Vector4 unity_SpecCube1_ProbePosition at 128
  VectorHalf4 unity_SpecCube1_HDR at 144
  Vector4 unity_ProbeVolumeParams at 160
  Vector3 unity_ProbeVolumeSizeInv at 240
  Vector3 unity_ProbeVolumeMin at 256
  VectorHalf4 _LightColor0 at 272
  VectorHalf4 _Color at 280
  ScalarHalf _Metallic at 288
  ScalarHalf _Glossiness at 290
  ScalarHalf _OcclusionStrength at 292
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    half4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    half4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (2) ]] ,
    sampler sampler_OcclusionMap [[ sampler (2) ]] ,
    texturecube<float, access::sample > unity_SpecCube0 [[ texture (3) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (3) ]] ,
    texturecube<float, access::sample > unity_SpecCube1 [[ texture (4) ]] ,
    sampler samplerunity_SpecCube1 [[ sampler (4) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (5) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (5) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    float4 u_xlat1;
    half3 u_xlat16_1;
    half4 u_xlat10_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    float3 u_xlat7;
    half3 u_xlat16_7;
    half4 u_xlat10_7;
    float3 u_xlat8;
    half3 u_xlat16_8;
    half4 u_xlat10_8;
    half4 u_xlat16_9;
    float3 u_xlat10;
    bool3 u_xlatb10;
    half3 u_xlat16_11;
    bool3 u_xlatb12;
    half3 u_xlat16_13;
    float3 u_xlat15;
    half u_xlat16_15;
    half3 u_xlat16_18;
    float3 u_xlat19;
    half3 u_xlat16_19;
    float u_xlat21;
    half u_xlat16_22;
    float3 u_xlat23;
    half3 u_xlat16_23;
    half u_xlat16_32;
    half u_xlat16_37;
    float u_xlat43;
    half u_xlat16_43;
    bool u_xlatb43;
    half u_xlat16_44;
    half u_xlat16_45;
    half u_xlat16_46;
    half u_xlat16_48;
    half u_xlat16_51;
    half u_xlat16_53;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_44 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_44));
    u_xlat16_45 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_45 = rsqrt(u_xlat16_45);
    u_xlat16_0.xyz = half3(half3(u_xlat16_45) * input.TEXCOORD4.xyz);
    u_xlat16_45 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_45 = rsqrt(u_xlat16_45);
    u_xlat16_4.xyz = half3(half3(u_xlat16_45) * input.TEXCOORD1.xyz);
    u_xlat1.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_1.x = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat1.xy).x;
    u_xlat16_15 = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_46 = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_46 = half(u_xlat16_15 * Globals._OcclusionStrength + u_xlat16_46);
    u_xlat16_5.x = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_19.x = dot(u_xlat16_4.xyz, u_xlat16_0.xyz);
    u_xlat16_19.x = half(u_xlat16_19.x + u_xlat16_19.x);
    u_xlat16_19.xyz = half3(u_xlat16_0.xyz * (-u_xlat16_19.xxx) + u_xlat16_4.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_1.xxx * Globals._LightColor0.xyz);
    u_xlatb1 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb1){
        u_xlatb1 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat15.xyz = input.TEXCOORD8.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat15.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD8.xxx + u_xlat15.xyz;
        u_xlat15.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD8.zzz + u_xlat15.xyz;
        u_xlat15.xyz = u_xlat15.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb1)) ? u_xlat15.xyz : input.TEXCOORD8.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat15.x = u_xlat1.y * 0.25;
        u_xlat7.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat21 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat15.x = max(u_xlat15.x, u_xlat7.x);
        u_xlat1.x = min(u_xlat21, u_xlat15.x);
        u_xlat10_7 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw));
        u_xlat8.xyz = u_xlat1.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_8 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat8.xyz));
        u_xlat1.xyz = u_xlat1.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_1 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xyz));
        u_xlat16_0.w = 1.0;
        u_xlat16_9.x = half(dot(float4(u_xlat10_7), float4(u_xlat16_0)));
        u_xlat16_9.y = half(dot(float4(u_xlat10_8), float4(u_xlat16_0)));
        u_xlat16_9.z = half(dot(float4(u_xlat10_1), float4(u_xlat16_0)));
    } else {
        u_xlat16_0.w = 1.0;
        u_xlat16_9.x = dot(Globals.unity_SHAr, u_xlat16_0);
        u_xlat16_9.y = dot(Globals.unity_SHAg, u_xlat16_0);
        u_xlat16_9.z = dot(Globals.unity_SHAb, u_xlat16_0);
    }
    u_xlat16_9.xyz = half3(u_xlat16_9.xyz + input.TEXCOORD5.xyz);
    u_xlat16_9.xyz = half3(max(float3(u_xlat16_9.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_1.xyz = log2(u_xlat16_9.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_1.xyz = exp2(u_xlat16_1.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_1.xyz = half3(max(float3(u_xlat16_1.xyz), float3(0.0, 0.0, 0.0)));
    u_xlatb43 = 0.0<Globals.unity_SpecCube0_ProbePosition.w;
    if(u_xlatb43){
        u_xlat16_48 = dot(u_xlat16_19.xyz, u_xlat16_19.xyz);
        u_xlat16_48 = rsqrt(u_xlat16_48);
        u_xlat16_9.xyz = half3(u_xlat16_19.xyz * half3(u_xlat16_48));
        u_xlat7.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMax.xyz;
        u_xlat7.xyz = u_xlat7.xyz / float3(u_xlat16_9.xyz);
        u_xlat8.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMin.xyz;
        u_xlat8.xyz = u_xlat8.xyz / float3(u_xlat16_9.xyz);
        u_xlatb10.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_9.xyz));
        u_xlat16_11.x = (u_xlatb10.x) ? half(u_xlat7.x) : half(u_xlat8.x);
        u_xlat16_11.y = (u_xlatb10.y) ? half(u_xlat7.y) : half(u_xlat8.y);
        u_xlat16_11.z = (u_xlatb10.z) ? half(u_xlat7.z) : half(u_xlat8.z);
        u_xlat16_48 = min(u_xlat16_11.y, u_xlat16_11.x);
        u_xlat16_48 = min(u_xlat16_11.z, u_xlat16_48);
        u_xlat7.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube0_ProbePosition.xyz);
        u_xlat7.xyz = float3(u_xlat16_9.xyz) * float3(u_xlat16_48) + u_xlat7.xyz;
        u_xlat16_7.xyz = half3(u_xlat7.xyz);
    } else {
        u_xlat16_7.xyz = u_xlat16_19.xyz;
    }
    u_xlat16_48 = half((-float(u_xlat16_5.x)) * 0.699999988 + 1.70000005);
    u_xlat16_48 = half(u_xlat16_5.x * u_xlat16_48);
    u_xlat16_48 = half(float(u_xlat16_48) * 6.0);
    u_xlat10_7 = half4(unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_7.xyz), level(float(u_xlat16_48))));
    u_xlatb43 = Globals.unity_SpecCube0_HDR.w==1.0;
    u_xlat16_9.x = (u_xlatb43) ? half(u_xlat10_7.w) : 1.0;
    u_xlat16_9.x = half(u_xlat16_9.x * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_23.xyz = half3(float3(u_xlat10_7.xyz) * float3(u_xlat16_9.xxx));
    u_xlatb43 = Globals.unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb43){
        u_xlatb43 = 0.0<Globals.unity_SpecCube1_ProbePosition.w;
        if(u_xlatb43){
            u_xlat16_11.x = dot(u_xlat16_19.xyz, u_xlat16_19.xyz);
            u_xlat16_11.x = rsqrt(u_xlat16_11.x);
            u_xlat16_11.xyz = half3(u_xlat16_19.xyz * u_xlat16_11.xxx);
            u_xlat8.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMax.xyz;
            u_xlat8.xyz = u_xlat8.xyz / float3(u_xlat16_11.xyz);
            u_xlat10.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMin.xyz;
            u_xlat10.xyz = u_xlat10.xyz / float3(u_xlat16_11.xyz);
            u_xlatb12.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_11.xyz));
            u_xlat16_13.x = (u_xlatb12.x) ? half(u_xlat8.x) : half(u_xlat10.x);
            u_xlat16_13.y = (u_xlatb12.y) ? half(u_xlat8.y) : half(u_xlat10.y);
            u_xlat16_13.z = (u_xlatb12.z) ? half(u_xlat8.z) : half(u_xlat10.z);
            u_xlat16_53 = min(u_xlat16_13.y, u_xlat16_13.x);
            u_xlat16_53 = min(u_xlat16_13.z, u_xlat16_53);
            u_xlat8.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube1_ProbePosition.xyz);
            u_xlat19.xyz = float3(u_xlat16_11.xyz) * float3(u_xlat16_53) + u_xlat8.xyz;
            u_xlat16_19.xyz = half3(u_xlat19.xyz);
        }
        u_xlat10_8 = half4(unity_SpecCube1.sample(samplerunity_SpecCube0, float3(u_xlat16_19.xyz), level(float(u_xlat16_48))));
        u_xlatb43 = Globals.unity_SpecCube1_HDR.w==1.0;
        u_xlat16_19.x = (u_xlatb43) ? half(u_xlat10_8.w) : 1.0;
        u_xlat16_19.x = half(u_xlat16_19.x * Globals.unity_SpecCube1_HDR.x);
        u_xlat16_19.xyz = half3(float3(u_xlat10_8.xyz) * float3(u_xlat16_19.xxx));
        u_xlat16_8.xyz = half3(float3(u_xlat16_9.xxx) * float3(u_xlat10_7.xyz) + (-float3(u_xlat16_19.xyz)));
        u_xlat23.xyz = Globals.unity_SpecCube0_BoxMin.www * float3(u_xlat16_8.xyz) + float3(u_xlat16_19.xyz);
        u_xlat16_23.xyz = half3(u_xlat23.xyz);
    }
    u_xlat16_19.xyz = half3(half3(u_xlat16_46) * u_xlat16_23.xyz);
    u_xlat16_9.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_45) + Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_45 = dot(u_xlat16_9.xyz, u_xlat16_9.xyz);
    u_xlat16_43 = half(max(float(u_xlat16_45), 0.00100000005));
    u_xlat16_45 = rsqrt(u_xlat16_43);
    u_xlat16_9.xyz = half3(half3(u_xlat16_45) * u_xlat16_9.xyz);
    u_xlat16_45 = dot(u_xlat16_0.xyz, (-u_xlat16_4.xyz));
    u_xlat16_4.x = dot(u_xlat16_0.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_18.x = dot(u_xlat16_0.xyz, u_xlat16_9.xyz);
    u_xlat16_18.x = clamp(u_xlat16_18.x, 0.0h, 1.0h);
    u_xlat16_32 = dot(Globals._WorldSpaceLightPos0.xyz, u_xlat16_9.xyz);
    u_xlat16_32 = clamp(u_xlat16_32, 0.0h, 1.0h);
    u_xlat16_48 = half(u_xlat16_32 * u_xlat16_32);
    u_xlat16_48 = dot(half2(u_xlat16_48), u_xlat16_5.xx);
    u_xlat16_48 = half(float(u_xlat16_48) + -0.5);
    u_xlat16_9.x = half((-float(u_xlat16_4.x)) + 1.0);
    u_xlat16_23.x = half(u_xlat16_9.x * u_xlat16_9.x);
    u_xlat16_23.x = half(u_xlat16_23.x * u_xlat16_23.x);
    u_xlat16_9.x = half(u_xlat16_9.x * u_xlat16_23.x);
    u_xlat16_9.x = half(float(u_xlat16_48) * float(u_xlat16_9.x) + 1.0);
    u_xlat16_23.x = half(-abs(float(u_xlat16_45)) + 1.0);
    u_xlat16_37 = half(u_xlat16_23.x * u_xlat16_23.x);
    u_xlat16_37 = half(u_xlat16_37 * u_xlat16_37);
    u_xlat16_23.x = half(u_xlat16_23.x * u_xlat16_37);
    u_xlat16_48 = half(float(u_xlat16_48) * float(u_xlat16_23.x) + 1.0);
    u_xlat16_48 = half(u_xlat16_48 * u_xlat16_9.x);
    u_xlat16_48 = half(u_xlat16_4.x * u_xlat16_48);
    u_xlat16_9.x = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_37 = half((-float(u_xlat16_5.x)) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_51 = half(abs(u_xlat16_45) * u_xlat16_37 + u_xlat16_9.x);
    u_xlat16_37 = half(u_xlat16_4.x * u_xlat16_37 + u_xlat16_9.x);
    u_xlat16_45 = half(abs(u_xlat16_45) * u_xlat16_37);
    u_xlat16_45 = half(u_xlat16_4.x * u_xlat16_51 + u_xlat16_45);
    u_xlat16_43 = half(float(u_xlat16_45) + 9.99999975e-06);
    u_xlat16_43 = half(0.5 / float(u_xlat16_43));
    u_xlat16_45 = half(u_xlat16_9.x * u_xlat16_9.x);
    u_xlat16_37 = half(u_xlat16_18.x * u_xlat16_45 + (-u_xlat16_18.x));
    u_xlat16_8.x = half(float(u_xlat16_37) * float(u_xlat16_18.x) + 1.0);
    u_xlat16_22 = half(float(u_xlat16_45) * 0.318309873);
    u_xlat16_8.x = half(float(u_xlat16_8.x) * float(u_xlat16_8.x) + 1.00000001e-07);
    u_xlat16_8.x = half(u_xlat16_22 / u_xlat16_8.x);
    u_xlat16_45 = half(u_xlat16_43 * u_xlat16_8.x);
    u_xlat16_43 = half(float(u_xlat16_45) * 3.14159274);
    u_xlat16_43 = half(max(float(u_xlat16_43), 9.99999975e-05));
    u_xlat16_43 = sqrt(u_xlat16_43);
    u_xlat16_45 = half(u_xlat16_4.x * u_xlat16_43);
    u_xlat16_4.x = half(u_xlat16_5.x * u_xlat16_9.x);
    u_xlat16_4.x = half((-float(u_xlat16_4.x)) * 0.280000001 + 1.0);
    u_xlat16_18.x = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb43 = u_xlat16_18.x!=0.0;
    u_xlat43 = u_xlatb43 ? 1.0 : float(0.0);
    u_xlat16_45 = half(u_xlat43 * float(u_xlat16_45));
    u_xlat16_44 = half((-u_xlat16_44) + Globals._Glossiness);
    u_xlat16_44 = half(float(u_xlat16_44) + 1.0);
    u_xlat16_44 = clamp(u_xlat16_44, 0.0h, 1.0h);
    u_xlat16_9.xzw = half3(half3(u_xlat16_48) * u_xlat16_6.xyz);
    u_xlat16_9.xzw = half3(u_xlat16_1.xyz * half3(u_xlat16_46) + u_xlat16_9.xzw);
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_45));
    u_xlat16_45 = half((-float(u_xlat16_32)) + 1.0);
    u_xlat16_18.x = half(u_xlat16_45 * u_xlat16_45);
    u_xlat16_18.x = half(u_xlat16_18.x * u_xlat16_18.x);
    u_xlat16_45 = half(u_xlat16_45 * u_xlat16_18.x);
    u_xlat16_18.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_18.xyz = half3(u_xlat16_18.xyz * half3(u_xlat16_45) + u_xlat16_2.xyz);
    u_xlat16_18.xyz = half3(u_xlat16_18.xyz * u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * u_xlat16_9.xzw + u_xlat16_18.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_19.xyz * u_xlat16_4.xxx);
    u_xlat16_5.xyz = half3((-u_xlat16_2.xyz) + half3(u_xlat16_44));
    u_xlat16_2.xyz = half3(u_xlat16_23.xxx * u_xlat16_5.xyz + u_xlat16_2.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_2.xyz + u_xlat16_3.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
float u_xlat10;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD8.xyz = u_xlat1.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = inversesqrt(u_xlat10);
    u_xlat1.xyz = vec3(u_xlat10) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = u_xlat1.x * u_xlat1.x + (-u_xlat10);
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(unity_SHBr, u_xlat2);
    u_xlat1.y = dot(unity_SHBg, u_xlat2);
    u_xlat1.z = dot(unity_SHBb, u_xlat2);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat10) + u_xlat1.xyz;
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
lowp vec4 u_xlat10_5;
vec4 u_xlat6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
lowp vec4 u_xlat10_7;
vec3 u_xlat8;
lowp vec4 u_xlat10_8;
vec3 u_xlat9;
lowp vec4 u_xlat10_9;
vec3 u_xlat10;
bvec3 u_xlatb10;
vec3 u_xlat11;
bvec3 u_xlatb12;
vec3 u_xlat15;
float u_xlat16;
float u_xlat17;
float u_xlat19;
float u_xlat28;
float u_xlat29;
float u_xlat30;
float u_xlat39;
float u_xlat40;
float u_xlat41;
bool u_xlatb41;
float u_xlat42;
float u_xlat44;
bool u_xlatb44;
float u_xlat45;
bool u_xlatb45;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat39 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat39) * u_xlat1.xyz;
    u_xlat40 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat2.xyz = vec3(u_xlat40) * vs_TEXCOORD4.xyz;
    u_xlat40 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat3.xyz = vec3(u_xlat40) * vs_TEXCOORD1.xyz;
    u_xlat4.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_4 = texture(_ShadowMapTexture, u_xlat4.xy);
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat42 = (-_OcclusionStrength) + 1.0;
    u_xlat42 = u_xlat10_5.y * _OcclusionStrength + u_xlat42;
    u_xlat17 = (-_Glossiness) + 1.0;
    u_xlat30 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat30 = u_xlat30 + u_xlat30;
    u_xlat5.xyz = u_xlat2.xyz * (-vec3(u_xlat30)) + u_xlat3.xyz;
    u_xlat4.xzw = u_xlat10_4.xxx * _LightColor0.xyz;
    u_xlatb44 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb44){
        u_xlatb44 = unity_ProbeVolumeParams.y==1.0;
        u_xlat6.xyz = vs_TEXCOORD8.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat6.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD8.xxx + u_xlat6.xyz;
        u_xlat6.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD8.zzz + u_xlat6.xyz;
        u_xlat6.xyz = u_xlat6.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat6.xyz = (bool(u_xlatb44)) ? u_xlat6.xyz : vs_TEXCOORD8.xyz;
        u_xlat6.xyz = u_xlat6.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat6.yzw = u_xlat6.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat44 = u_xlat6.y * 0.25;
        u_xlat19 = unity_ProbeVolumeParams.z * 0.5;
        u_xlat7.x = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat44 = max(u_xlat44, u_xlat19);
        u_xlat6.x = min(u_xlat7.x, u_xlat44);
        u_xlat10_7 = texture(unity_ProbeVolumeSH, u_xlat6.xzw);
        u_xlat8.xyz = u_xlat6.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat8.xyz);
        u_xlat6.xyz = u_xlat6.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_6 = texture(unity_ProbeVolumeSH, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat7.x = dot(u_xlat10_7, u_xlat2);
        u_xlat7.y = dot(u_xlat10_8, u_xlat2);
        u_xlat7.z = dot(u_xlat10_6, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat7.x = dot(unity_SHAr, u_xlat2);
        u_xlat7.y = dot(unity_SHAg, u_xlat2);
        u_xlat7.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat6.xyz = u_xlat7.xyz + vs_TEXCOORD5.xyz;
    u_xlat6.xyz = max(u_xlat6.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat6.xyz = log2(u_xlat6.xyz);
    u_xlat6.xyz = u_xlat6.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat6.xyz = exp2(u_xlat6.xyz);
    u_xlat6.xyz = u_xlat6.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat6.xyz = max(u_xlat6.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb41 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb41){
        u_xlat41 = dot(u_xlat5.xyz, u_xlat5.xyz);
        u_xlat41 = inversesqrt(u_xlat41);
        u_xlat7.xyz = vec3(u_xlat41) * u_xlat5.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat7.xyz;
        u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat9.xyz = u_xlat9.xyz / u_xlat7.xyz;
        u_xlatb10.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat7.xyzx).xyz;
        u_xlat8.x = (u_xlatb10.x) ? u_xlat8.x : u_xlat9.x;
        u_xlat8.y = (u_xlatb10.y) ? u_xlat8.y : u_xlat9.y;
        u_xlat8.z = (u_xlatb10.z) ? u_xlat8.z : u_xlat9.z;
        u_xlat41 = min(u_xlat8.y, u_xlat8.x);
        u_xlat41 = min(u_xlat8.z, u_xlat41);
        u_xlat8.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat7.xyz = u_xlat7.xyz * vec3(u_xlat41) + u_xlat8.xyz;
    } else {
        u_xlat7.xyz = u_xlat5.xyz;
    //ENDIF
    }
    u_xlat41 = (-u_xlat17) * 0.699999988 + 1.70000005;
    u_xlat41 = u_xlat41 * u_xlat17;
    u_xlat41 = u_xlat41 * 6.0;
    u_xlat10_7 = textureLod(unity_SpecCube0, u_xlat7.xyz, u_xlat41);
    u_xlatb44 = unity_SpecCube0_HDR.w==1.0;
    u_xlat44 = (u_xlatb44) ? u_xlat10_7.w : 1.0;
    u_xlat44 = u_xlat44 * unity_SpecCube0_HDR.x;
    u_xlat8.xyz = u_xlat10_7.xyz * vec3(u_xlat44);
    u_xlatb45 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb45){
        u_xlatb45 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb45){
            u_xlat45 = dot(u_xlat5.xyz, u_xlat5.xyz);
            u_xlat45 = inversesqrt(u_xlat45);
            u_xlat9.xyz = u_xlat5.xyz * vec3(u_xlat45);
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
            u_xlat11.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
            u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
            u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
            u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
            u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
            u_xlat45 = min(u_xlat10.y, u_xlat10.x);
            u_xlat45 = min(u_xlat10.z, u_xlat45);
            u_xlat10.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat5.xyz = u_xlat9.xyz * vec3(u_xlat45) + u_xlat10.xyz;
        //ENDIF
        }
        u_xlat10_9 = textureLod(unity_SpecCube1, u_xlat5.xyz, u_xlat41);
        u_xlatb41 = unity_SpecCube1_HDR.w==1.0;
        u_xlat41 = (u_xlatb41) ? u_xlat10_9.w : 1.0;
        u_xlat41 = u_xlat41 * unity_SpecCube1_HDR.x;
        u_xlat5.xyz = u_xlat10_9.xyz * vec3(u_xlat41);
        u_xlat7.xyz = vec3(u_xlat44) * u_xlat10_7.xyz + (-u_xlat5.xyz);
        u_xlat8.xyz = unity_SpecCube0_BoxMin.www * u_xlat7.xyz + u_xlat5.xyz;
    //ENDIF
    }
    u_xlat5.xyz = vec3(u_xlat42) * u_xlat8.xyz;
    u_xlat7.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat40) + _WorldSpaceLightPos0.xyz;
    u_xlat40 = dot(u_xlat7.xyz, u_xlat7.xyz);
    u_xlat40 = max(u_xlat40, 0.00100000005);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat7.xyz = vec3(u_xlat40) * u_xlat7.xyz;
    u_xlat40 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat41 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat41 = clamp(u_xlat41, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat7.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat15.x = dot(_WorldSpaceLightPos0.xyz, u_xlat7.xyz);
    u_xlat15.x = clamp(u_xlat15.x, 0.0, 1.0);
    u_xlat28 = u_xlat15.x * u_xlat15.x;
    u_xlat28 = dot(vec2(u_xlat28), vec2(u_xlat17));
    u_xlat28 = u_xlat28 + -0.5;
    u_xlat3.x = (-u_xlat41) + 1.0;
    u_xlat16 = u_xlat3.x * u_xlat3.x;
    u_xlat16 = u_xlat16 * u_xlat16;
    u_xlat3.x = u_xlat3.x * u_xlat16;
    u_xlat3.x = u_xlat28 * u_xlat3.x + 1.0;
    u_xlat16 = -abs(u_xlat40) + 1.0;
    u_xlat29 = u_xlat16 * u_xlat16;
    u_xlat29 = u_xlat29 * u_xlat29;
    u_xlat16 = u_xlat16 * u_xlat29;
    u_xlat28 = u_xlat28 * u_xlat16 + 1.0;
    u_xlat28 = u_xlat28 * u_xlat3.x;
    u_xlat28 = u_xlat41 * u_xlat28;
    u_xlat3.x = u_xlat17 * u_xlat17;
    u_xlat29 = (-u_xlat17) * u_xlat17 + 1.0;
    u_xlat44 = abs(u_xlat40) * u_xlat29 + u_xlat3.x;
    u_xlat29 = u_xlat41 * u_xlat29 + u_xlat3.x;
    u_xlat40 = abs(u_xlat40) * u_xlat29;
    u_xlat40 = u_xlat41 * u_xlat44 + u_xlat40;
    u_xlat40 = u_xlat40 + 9.99999975e-06;
    u_xlat40 = 0.5 / u_xlat40;
    u_xlat29 = u_xlat3.x * u_xlat3.x;
    u_xlat44 = u_xlat2.x * u_xlat29 + (-u_xlat2.x);
    u_xlat2.x = u_xlat44 * u_xlat2.x + 1.0;
    u_xlat29 = u_xlat29 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat29 / u_xlat2.x;
    u_xlat40 = u_xlat40 * u_xlat2.x;
    u_xlat40 = u_xlat40 * 3.14159274;
    u_xlat40 = max(u_xlat40, 9.99999975e-05);
    u_xlat40 = sqrt(u_xlat40);
    u_xlat40 = u_xlat41 * u_xlat40;
    u_xlat2.x = u_xlat3.x * u_xlat17;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat41 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb41 = u_xlat41!=0.0;
    u_xlat41 = u_xlatb41 ? 1.0 : float(0.0);
    u_xlat40 = u_xlat40 * u_xlat41;
    u_xlat39 = (-u_xlat39) + _Glossiness;
    u_xlat39 = u_xlat39 + 1.0;
    u_xlat39 = clamp(u_xlat39, 0.0, 1.0);
    u_xlat7.xyz = vec3(u_xlat28) * u_xlat4.xzw;
    u_xlat3.xzw = u_xlat6.xyz * vec3(u_xlat42) + u_xlat7.xyz;
    u_xlat4.xyz = u_xlat4.xzw * vec3(u_xlat40);
    u_xlat40 = (-u_xlat15.x) + 1.0;
    u_xlat15.x = u_xlat40 * u_xlat40;
    u_xlat15.x = u_xlat15.x * u_xlat15.x;
    u_xlat40 = u_xlat40 * u_xlat15.x;
    u_xlat15.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat15.xyz = u_xlat15.xyz * vec3(u_xlat40) + u_xlat0.xyz;
    u_xlat15.xyz = u_xlat15.xyz * u_xlat4.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat15.xyz;
    u_xlat2.xyz = u_xlat5.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat39);
    u_xlat0.xyz = vec3(u_xlat16) * u_xlat3.xzw + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN DIRLIGHTMAP_COMBINED DYNAMICLIGHTMAP_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  Vector4 unity_WorldTransformParams at 224
  Vector4 unity_DynamicLightmapST at 240
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    float2 TEXCOORD2 [[ attribute(4) ]] ;
    half4 TANGENT0 [[ attribute(5) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float3 u_xlat2;
    half3 u_xlat16_3;
    float u_xlat13;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD8.xyz = u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    u_xlat1.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat1.xyz;
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat1.xyz = float3(u_xlat13) * u_xlat1.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat16_3.xyz = half3(u_xlat1.yzx * u_xlat2.zxy);
    u_xlat16_3.xyz = half3(u_xlat2.yzx * u_xlat1.zxy + (-float3(u_xlat16_3.xyz)));
    output.TEXCOORD4.xyz = half3(u_xlat2.xyz);
    u_xlat1.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat1.xxx * float3(u_xlat16_3.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.w = 0.0;
    u_xlat1.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    output.TEXCOORD5.zw = half2(u_xlat1.xy);
    output.TEXCOORD5.xy = half2(0.0, 0.0);
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_OcclusionMap" to slot 2
Set 2D Texture "unity_DynamicLightmap" to slot 3
Set 2D Texture "unity_DynamicDirectionality" to slot 4
Set CUBE Texture "unity_SpecCube0" to slot 5
Set CUBE Texture "unity_SpecCube1" to slot 6

Constant Buffer "Globals" (166 bytes) on slot 0 {
  VectorHalf4 _WorldSpaceLightPos0 at 0
  Vector4 unity_SpecCube0_BoxMax at 16
  Vector4 unity_SpecCube0_BoxMin at 32
  Vector4 unity_SpecCube0_ProbePosition at 48
  VectorHalf4 unity_SpecCube0_HDR at 64
  Vector4 unity_SpecCube1_BoxMax at 80
  Vector4 unity_SpecCube1_BoxMin at 96
  Vector4 unity_SpecCube1_ProbePosition at 112
  VectorHalf4 unity_SpecCube1_HDR at 128
  VectorHalf4 unity_DynamicLightmap_HDR at 136
  VectorHalf4 _LightColor0 at 144
  VectorHalf4 _Color at 152
  ScalarHalf _Metallic at 160
  ScalarHalf _Glossiness at 162
  ScalarHalf _OcclusionStrength at 164
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    half4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    half4 unity_SpecCube1_HDR;
    half4 unity_DynamicLightmap_HDR;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (2) ]] ,
    sampler sampler_OcclusionMap [[ sampler (2) ]] ,
    texture2d<float, access::sample > unity_DynamicLightmap [[ texture (3) ]] ,
    sampler samplerunity_DynamicLightmap [[ sampler (3) ]] ,
    texture2d<float, access::sample > unity_DynamicDirectionality [[ texture (4) ]] ,
    sampler samplerunity_DynamicDirectionality [[ sampler (4) ]] ,
    texturecube<float, access::sample > unity_SpecCube0 [[ texture (5) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (5) ]] ,
    texturecube<float, access::sample > unity_SpecCube1 [[ texture (6) ]] ,
    sampler samplerunity_SpecCube1 [[ sampler (6) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float2 u_xlat0;
    half3 u_xlat16_0;
    half4 u_xlat10_0;
    float3 u_xlat1;
    half3 u_xlat16_1;
    half4 u_xlat10_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half4 u_xlat16_5;
    float3 u_xlat6;
    half3 u_xlat16_6;
    half4 u_xlat10_6;
    half3 u_xlat16_7;
    float3 u_xlat8;
    half3 u_xlat16_8;
    half3 u_xlat16_9;
    float3 u_xlat10;
    half3 u_xlat16_10;
    float3 u_xlat11;
    bool3 u_xlatb11;
    half3 u_xlat16_12;
    bool3 u_xlatb13;
    half3 u_xlat16_14;
    half u_xlat16_15;
    half3 u_xlat16_19;
    half u_xlat16_20;
    half u_xlat16_25;
    half u_xlat16_34;
    half u_xlat16_35;
    float u_xlat45;
    half u_xlat16_45;
    bool u_xlatb45;
    half u_xlat16_47;
    half u_xlat16_48;
    half u_xlat16_49;
    half u_xlat16_50;
    half u_xlat16_51;
    half u_xlat16_52;
    half u_xlat16_53;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_47 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_47));
    u_xlat16_48 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_48 = rsqrt(u_xlat16_48);
    u_xlat16_4.xyz = half3(half3(u_xlat16_48) * input.TEXCOORD4.xyz);
    u_xlat16_48 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_48 = rsqrt(u_xlat16_48);
    u_xlat16_5.xyz = half3(half3(u_xlat16_48) * input.TEXCOORD1.xyz);
    u_xlat0.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_0.x = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat0.xy).x;
    u_xlat16_15 = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_49 = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_49 = half(u_xlat16_15 * Globals._OcclusionStrength + u_xlat16_49);
    u_xlat16_50 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_6.x = dot(u_xlat16_5.xyz, u_xlat16_4.xyz);
    u_xlat16_6.x = half(u_xlat16_6.x + u_xlat16_6.x);
    u_xlat16_6.xyz = half3(u_xlat16_4.xyz * (-u_xlat16_6.xxx) + u_xlat16_5.xyz);
    u_xlat16_7.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat10_0 = half4(unity_DynamicLightmap.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_51 = half(float(u_xlat10_0.w) * float(Globals.unity_DynamicLightmap_HDR.x));
    u_xlat16_8.xyz = half3(float3(u_xlat10_0.xyz) * float3(u_xlat16_51));
    u_xlat16_8.xyz = log2(u_xlat16_8.xyz);
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * Globals.unity_DynamicLightmap_HDR.yyy);
    u_xlat16_8.xyz = exp2(u_xlat16_8.xyz);
    u_xlat10_0 = half4(unity_DynamicDirectionality.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_9.xyz = half3(float3(u_xlat10_0.xyz) + float3(-0.5, -0.5, -0.5));
    u_xlat16_51 = dot(u_xlat16_4.xyz, u_xlat16_9.xyz);
    u_xlat16_51 = half(float(u_xlat16_51) + 0.5);
    u_xlat16_8.xyz = half3(half3(u_xlat16_51) * u_xlat16_8.xyz);
    u_xlat16_0.x = half(max(float(u_xlat10_0.w), 9.99999975e-05));
    u_xlat16_0.xyz = half3(u_xlat16_8.xyz / u_xlat16_0.xxx);
    u_xlatb45 = 0.0<Globals.unity_SpecCube0_ProbePosition.w;
    if(u_xlatb45){
        u_xlat16_51 = dot(u_xlat16_6.xyz, u_xlat16_6.xyz);
        u_xlat16_51 = rsqrt(u_xlat16_51);
        u_xlat16_8.xyz = half3(half3(u_xlat16_51) * u_xlat16_6.xyz);
        u_xlat1.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMax.xyz;
        u_xlat1.xyz = u_xlat1.xyz / float3(u_xlat16_8.xyz);
        u_xlat10.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMin.xyz;
        u_xlat10.xyz = u_xlat10.xyz / float3(u_xlat16_8.xyz);
        u_xlatb11.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_8.xyz));
        u_xlat16_12.x = (u_xlatb11.x) ? half(u_xlat1.x) : half(u_xlat10.x);
        u_xlat16_12.y = (u_xlatb11.y) ? half(u_xlat1.y) : half(u_xlat10.y);
        u_xlat16_12.z = (u_xlatb11.z) ? half(u_xlat1.z) : half(u_xlat10.z);
        u_xlat16_51 = min(u_xlat16_12.y, u_xlat16_12.x);
        u_xlat16_51 = min(u_xlat16_12.z, u_xlat16_51);
        u_xlat1.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube0_ProbePosition.xyz);
        u_xlat1.xyz = float3(u_xlat16_8.xyz) * float3(u_xlat16_51) + u_xlat1.xyz;
        u_xlat16_1.xyz = half3(u_xlat1.xyz);
    } else {
        u_xlat16_1.xyz = u_xlat16_6.xyz;
    }
    u_xlat16_51 = half((-float(u_xlat16_50)) * 0.699999988 + 1.70000005);
    u_xlat16_51 = half(u_xlat16_50 * u_xlat16_51);
    u_xlat16_51 = half(float(u_xlat16_51) * 6.0);
    u_xlat10_1 = half4(unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_1.xyz), level(float(u_xlat16_51))));
    u_xlatb45 = Globals.unity_SpecCube0_HDR.w==1.0;
    u_xlat16_52 = (u_xlatb45) ? half(u_xlat10_1.w) : 1.0;
    u_xlat16_52 = half(u_xlat16_52 * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_8.xyz = half3(float3(u_xlat10_1.xyz) * float3(u_xlat16_52));
    u_xlatb45 = Globals.unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb45){
        u_xlatb45 = 0.0<Globals.unity_SpecCube1_ProbePosition.w;
        if(u_xlatb45){
            u_xlat16_53 = dot(u_xlat16_6.xyz, u_xlat16_6.xyz);
            u_xlat16_53 = rsqrt(u_xlat16_53);
            u_xlat16_12.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_53));
            u_xlat10.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMax.xyz;
            u_xlat10.xyz = u_xlat10.xyz / float3(u_xlat16_12.xyz);
            u_xlat11.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMin.xyz;
            u_xlat11.xyz = u_xlat11.xyz / float3(u_xlat16_12.xyz);
            u_xlatb13.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_12.xyz));
            u_xlat16_14.x = (u_xlatb13.x) ? half(u_xlat10.x) : half(u_xlat11.x);
            u_xlat16_14.y = (u_xlatb13.y) ? half(u_xlat10.y) : half(u_xlat11.y);
            u_xlat16_14.z = (u_xlatb13.z) ? half(u_xlat10.z) : half(u_xlat11.z);
            u_xlat16_53 = min(u_xlat16_14.y, u_xlat16_14.x);
            u_xlat16_53 = min(u_xlat16_14.z, u_xlat16_53);
            u_xlat10.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube1_ProbePosition.xyz);
            u_xlat6.xyz = float3(u_xlat16_12.xyz) * float3(u_xlat16_53) + u_xlat10.xyz;
            u_xlat16_6.xyz = half3(u_xlat6.xyz);
        }
        u_xlat10_6 = half4(unity_SpecCube1.sample(samplerunity_SpecCube0, float3(u_xlat16_6.xyz), level(float(u_xlat16_51))));
        u_xlatb45 = Globals.unity_SpecCube1_HDR.w==1.0;
        u_xlat16_53 = (u_xlatb45) ? half(u_xlat10_6.w) : 1.0;
        u_xlat16_53 = half(u_xlat16_53 * Globals.unity_SpecCube1_HDR.x);
        u_xlat16_12.xyz = half3(float3(u_xlat10_6.xyz) * float3(u_xlat16_53));
        u_xlat16_10.xyz = half3(float3(u_xlat16_52) * float3(u_xlat10_1.xyz) + (-float3(u_xlat16_12.xyz)));
        u_xlat8.xyz = Globals.unity_SpecCube0_BoxMin.www * float3(u_xlat16_10.xyz) + float3(u_xlat16_12.xyz);
        u_xlat16_8.xyz = half3(u_xlat8.xyz);
    }
    u_xlat16_8.xyz = half3(half3(u_xlat16_49) * u_xlat16_8.xyz);
    u_xlat16_12.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_48) + Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_48 = dot(u_xlat16_12.xyz, u_xlat16_12.xyz);
    u_xlat16_45 = half(max(float(u_xlat16_48), 0.00100000005));
    u_xlat16_48 = rsqrt(u_xlat16_45);
    u_xlat16_12.xyz = half3(half3(u_xlat16_48) * u_xlat16_12.xyz);
    u_xlat16_48 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_5.x = dot(u_xlat16_4.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_5.x = clamp(u_xlat16_5.x, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_12.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_19.x = dot(Globals._WorldSpaceLightPos0.xyz, u_xlat16_12.xyz);
    u_xlat16_19.x = clamp(u_xlat16_19.x, 0.0h, 1.0h);
    u_xlat16_34 = half(u_xlat16_19.x * u_xlat16_19.x);
    u_xlat16_34 = dot(half2(u_xlat16_34), half2(u_xlat16_50));
    u_xlat16_34 = half(float(u_xlat16_34) + -0.5);
    u_xlat16_20 = half((-float(u_xlat16_5.x)) + 1.0);
    u_xlat16_35 = half(u_xlat16_20 * u_xlat16_20);
    u_xlat16_35 = half(u_xlat16_35 * u_xlat16_35);
    u_xlat16_20 = half(u_xlat16_20 * u_xlat16_35);
    u_xlat16_20 = half(float(u_xlat16_34) * float(u_xlat16_20) + 1.0);
    u_xlat16_35 = half(-abs(float(u_xlat16_48)) + 1.0);
    u_xlat16_52 = half(u_xlat16_35 * u_xlat16_35);
    u_xlat16_52 = half(u_xlat16_52 * u_xlat16_52);
    u_xlat16_35 = half(u_xlat16_35 * u_xlat16_52);
    u_xlat16_34 = half(float(u_xlat16_34) * float(u_xlat16_35) + 1.0);
    u_xlat16_34 = half(u_xlat16_34 * u_xlat16_20);
    u_xlat16_34 = half(u_xlat16_5.x * u_xlat16_34);
    u_xlat16_20 = half(u_xlat16_50 * u_xlat16_50);
    u_xlat16_52 = half((-float(u_xlat16_50)) * float(u_xlat16_50) + 1.0);
    u_xlat16_53 = half(abs(u_xlat16_48) * u_xlat16_52 + u_xlat16_20);
    u_xlat16_52 = half(u_xlat16_5.x * u_xlat16_52 + u_xlat16_20);
    u_xlat16_48 = half(abs(u_xlat16_48) * u_xlat16_52);
    u_xlat16_48 = half(u_xlat16_5.x * u_xlat16_53 + u_xlat16_48);
    u_xlat16_45 = half(float(u_xlat16_48) + 9.99999975e-06);
    u_xlat16_45 = half(0.5 / float(u_xlat16_45));
    u_xlat16_48 = half(u_xlat16_20 * u_xlat16_20);
    u_xlat16_52 = half(u_xlat16_4.x * u_xlat16_48 + (-u_xlat16_4.x));
    u_xlat16_10.x = half(float(u_xlat16_52) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_25 = half(float(u_xlat16_48) * 0.318309873);
    u_xlat16_10.x = half(float(u_xlat16_10.x) * float(u_xlat16_10.x) + 1.00000001e-07);
    u_xlat16_10.x = half(u_xlat16_25 / u_xlat16_10.x);
    u_xlat16_48 = half(u_xlat16_45 * u_xlat16_10.x);
    u_xlat16_45 = half(float(u_xlat16_48) * 3.14159274);
    u_xlat16_45 = half(max(float(u_xlat16_45), 9.99999975e-05));
    u_xlat16_45 = sqrt(u_xlat16_45);
    u_xlat16_48 = half(u_xlat16_5.x * u_xlat16_45);
    u_xlat16_4.x = half(u_xlat16_20 * u_xlat16_50);
    u_xlat16_4.x = half((-float(u_xlat16_4.x)) * 0.280000001 + 1.0);
    u_xlat16_5.x = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb45 = u_xlat16_5.x!=0.0;
    u_xlat45 = u_xlatb45 ? 1.0 : float(0.0);
    u_xlat16_48 = half(u_xlat45 * float(u_xlat16_48));
    u_xlat16_47 = half((-u_xlat16_47) + Globals._Glossiness);
    u_xlat16_47 = half(float(u_xlat16_47) + 1.0);
    u_xlat16_47 = clamp(u_xlat16_47, 0.0h, 1.0h);
    u_xlat16_5.xyw = half3(half3(u_xlat16_34) * u_xlat16_7.xyz);
    u_xlat16_5.xyw = half3(u_xlat16_0.xyz * half3(u_xlat16_49) + u_xlat16_5.xyw);
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * half3(u_xlat16_48));
    u_xlat16_48 = half((-float(u_xlat16_19.x)) + 1.0);
    u_xlat16_19.x = half(u_xlat16_48 * u_xlat16_48);
    u_xlat16_19.x = half(u_xlat16_19.x * u_xlat16_19.x);
    u_xlat16_48 = half(u_xlat16_48 * u_xlat16_19.x);
    u_xlat16_19.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_19.xyz = half3(u_xlat16_19.xyz * half3(u_xlat16_48) + u_xlat16_2.xyz);
    u_xlat16_19.xyz = half3(u_xlat16_19.xyz * u_xlat16_7.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * u_xlat16_5.xyw + u_xlat16_19.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_8.xyz * u_xlat16_4.xxx);
    u_xlat16_5.xyw = half3((-u_xlat16_2.xyz) + half3(u_xlat16_47));
    u_xlat16_2.xyz = half3(half3(u_xlat16_35) * u_xlat16_5.xyw + u_xlat16_2.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_2.xyz + u_xlat16_3.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec3 u_xlat2;
vec3 u_xlat3;
float u_xlat13;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD8.xyz = u_xlat1.xyz;
    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = inversesqrt(u_xlat13);
    u_xlat1.xyz = vec3(u_xlat13) * u_xlat1.xyz;
    vs_TEXCOORD2.xyz = u_xlat1.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat2.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = inversesqrt(u_xlat13);
    u_xlat2.xyz = vec3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.yzx * u_xlat2.zxy;
    u_xlat1.xyz = u_xlat2.yzx * u_xlat1.zxy + (-u_xlat3.xyz);
    vs_TEXCOORD4.xyz = u_xlat2.xyz;
    u_xlat13 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat13) * u_xlat1.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.w = 0.0;
    vs_TEXCOORD5.zw = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    vs_TEXCOORD5.xy = vec2(0.0, 0.0);
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_DynamicLightmap_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_DynamicLightmap;
uniform  sampler2D unity_DynamicDirectionality;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
vec3 u_xlat2;
vec4 u_xlat3;
bool u_xlatb3;
vec3 u_xlat4;
mediump float u_xlat16_4;
lowp vec4 u_xlat10_4;
bool u_xlatb4;
vec3 u_xlat5;
lowp vec4 u_xlat10_5;
vec3 u_xlat6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
mediump vec3 u_xlat16_7;
lowp vec4 u_xlat10_7;
vec3 u_xlat8;
vec3 u_xlat9;
vec3 u_xlat10;
bvec3 u_xlatb10;
vec3 u_xlat11;
bvec3 u_xlatb12;
vec3 u_xlat15;
float u_xlat16;
vec3 u_xlat17;
float u_xlat28;
float u_xlat29;
float u_xlat39;
float u_xlat40;
float u_xlat41;
float u_xlat42;
float u_xlat43;
float u_xlat44;
bool u_xlatb44;
float u_xlat45;
bool u_xlatb45;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat39 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat39) * u_xlat1.xyz;
    u_xlat40 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat2.xyz = vec3(u_xlat40) * vs_TEXCOORD4.xyz;
    u_xlat40 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat3.xyz = vec3(u_xlat40) * vs_TEXCOORD1.xyz;
    u_xlat4.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_4 = texture(_ShadowMapTexture, u_xlat4.xy);
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat41 = (-_OcclusionStrength) + 1.0;
    u_xlat41 = u_xlat10_5.y * _OcclusionStrength + u_xlat41;
    u_xlat42 = (-_Glossiness) + 1.0;
    u_xlat17.x = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat17.x = u_xlat17.x + u_xlat17.x;
    u_xlat17.xyz = u_xlat2.xyz * (-u_xlat17.xxx) + u_xlat3.xyz;
    u_xlat5.xyz = u_xlat10_4.xxx * _LightColor0.xyz;
    u_xlat10_6 = texture(unity_DynamicLightmap, vs_TEXCOORD5.zw);
    u_xlat4.x = u_xlat10_6.w * unity_DynamicLightmap_HDR.x;
    u_xlat6.xyz = u_xlat10_6.xyz * u_xlat4.xxx;
    u_xlat6.xyz = log2(u_xlat6.xyz);
    u_xlat6.xyz = u_xlat6.xyz * unity_DynamicLightmap_HDR.yyy;
    u_xlat6.xyz = exp2(u_xlat6.xyz);
    u_xlat10_7 = texture(unity_DynamicDirectionality, vs_TEXCOORD5.zw);
    u_xlat16_7.xyz = u_xlat10_7.xyz + vec3(-0.5, -0.5, -0.5);
    u_xlat4.x = dot(u_xlat2.xyz, u_xlat16_7.xyz);
    u_xlat4.x = u_xlat4.x + 0.5;
    u_xlat6.xyz = u_xlat4.xxx * u_xlat6.xyz;
    u_xlat16_4 = max(u_xlat10_7.w, 9.99999975e-05);
    u_xlat6.xyz = u_xlat6.xyz / vec3(u_xlat16_4);
    u_xlatb4 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb4){
        u_xlat4.x = dot(u_xlat17.xyz, u_xlat17.xyz);
        u_xlat4.x = inversesqrt(u_xlat4.x);
        u_xlat7.xyz = u_xlat4.xxx * u_xlat17.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat7.xyz;
        u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat9.xyz = u_xlat9.xyz / u_xlat7.xyz;
        u_xlatb10.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat7.xyzx).xyz;
        u_xlat8.x = (u_xlatb10.x) ? u_xlat8.x : u_xlat9.x;
        u_xlat8.y = (u_xlatb10.y) ? u_xlat8.y : u_xlat9.y;
        u_xlat8.z = (u_xlatb10.z) ? u_xlat8.z : u_xlat9.z;
        u_xlat4.x = min(u_xlat8.y, u_xlat8.x);
        u_xlat4.x = min(u_xlat8.z, u_xlat4.x);
        u_xlat8.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat7.xyz = u_xlat7.xyz * u_xlat4.xxx + u_xlat8.xyz;
    } else {
        u_xlat7.xyz = u_xlat17.xyz;
    //ENDIF
    }
    u_xlat4.x = (-u_xlat42) * 0.699999988 + 1.70000005;
    u_xlat4.x = u_xlat42 * u_xlat4.x;
    u_xlat4.x = u_xlat4.x * 6.0;
    u_xlat10_7 = textureLod(unity_SpecCube0, u_xlat7.xyz, u_xlat4.x);
    u_xlatb44 = unity_SpecCube0_HDR.w==1.0;
    u_xlat44 = (u_xlatb44) ? u_xlat10_7.w : 1.0;
    u_xlat44 = u_xlat44 * unity_SpecCube0_HDR.x;
    u_xlat8.xyz = u_xlat10_7.xyz * vec3(u_xlat44);
    u_xlatb45 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb45){
        u_xlatb45 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb45){
            u_xlat45 = dot(u_xlat17.xyz, u_xlat17.xyz);
            u_xlat45 = inversesqrt(u_xlat45);
            u_xlat9.xyz = u_xlat17.xyz * vec3(u_xlat45);
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
            u_xlat11.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
            u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
            u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
            u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
            u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
            u_xlat45 = min(u_xlat10.y, u_xlat10.x);
            u_xlat45 = min(u_xlat10.z, u_xlat45);
            u_xlat10.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat17.xyz = u_xlat9.xyz * vec3(u_xlat45) + u_xlat10.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat17.xyz, u_xlat4.x);
        u_xlatb45 = unity_SpecCube1_HDR.w==1.0;
        u_xlat43 = (u_xlatb45) ? u_xlat10_4.w : 1.0;
        u_xlat43 = u_xlat43 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat43);
        u_xlat7.xyz = vec3(u_xlat44) * u_xlat10_7.xyz + (-u_xlat4.xyz);
        u_xlat8.xyz = unity_SpecCube0_BoxMin.www * u_xlat7.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = vec3(u_xlat41) * u_xlat8.xyz;
    u_xlat7.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat40) + _WorldSpaceLightPos0.xyz;
    u_xlat40 = dot(u_xlat7.xyz, u_xlat7.xyz);
    u_xlat40 = max(u_xlat40, 0.00100000005);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat7.xyz = vec3(u_xlat40) * u_xlat7.xyz;
    u_xlat40 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat3.x = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat3.x = clamp(u_xlat3.x, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat7.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat15.x = dot(_WorldSpaceLightPos0.xyz, u_xlat7.xyz);
    u_xlat15.x = clamp(u_xlat15.x, 0.0, 1.0);
    u_xlat28 = u_xlat15.x * u_xlat15.x;
    u_xlat28 = dot(vec2(u_xlat28), vec2(u_xlat42));
    u_xlat28 = u_xlat28 + -0.5;
    u_xlat16 = (-u_xlat3.x) + 1.0;
    u_xlat29 = u_xlat16 * u_xlat16;
    u_xlat29 = u_xlat29 * u_xlat29;
    u_xlat16 = u_xlat16 * u_xlat29;
    u_xlat16 = u_xlat28 * u_xlat16 + 1.0;
    u_xlat29 = -abs(u_xlat40) + 1.0;
    u_xlat43 = u_xlat29 * u_xlat29;
    u_xlat43 = u_xlat43 * u_xlat43;
    u_xlat29 = u_xlat29 * u_xlat43;
    u_xlat28 = u_xlat28 * u_xlat29 + 1.0;
    u_xlat28 = u_xlat28 * u_xlat16;
    u_xlat28 = u_xlat3.x * u_xlat28;
    u_xlat16 = u_xlat42 * u_xlat42;
    u_xlat43 = (-u_xlat42) * u_xlat42 + 1.0;
    u_xlat44 = abs(u_xlat40) * u_xlat43 + u_xlat16;
    u_xlat43 = u_xlat3.x * u_xlat43 + u_xlat16;
    u_xlat40 = abs(u_xlat40) * u_xlat43;
    u_xlat40 = u_xlat3.x * u_xlat44 + u_xlat40;
    u_xlat40 = u_xlat40 + 9.99999975e-06;
    u_xlat40 = 0.5 / u_xlat40;
    u_xlat43 = u_xlat16 * u_xlat16;
    u_xlat44 = u_xlat2.x * u_xlat43 + (-u_xlat2.x);
    u_xlat2.x = u_xlat44 * u_xlat2.x + 1.0;
    u_xlat43 = u_xlat43 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat43 / u_xlat2.x;
    u_xlat40 = u_xlat40 * u_xlat2.x;
    u_xlat40 = u_xlat40 * 3.14159274;
    u_xlat40 = max(u_xlat40, 9.99999975e-05);
    u_xlat40 = sqrt(u_xlat40);
    u_xlat40 = u_xlat3.x * u_xlat40;
    u_xlat2.x = u_xlat16 * u_xlat42;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat3.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb3 = u_xlat3.x!=0.0;
    u_xlat3.x = u_xlatb3 ? 1.0 : float(0.0);
    u_xlat40 = u_xlat40 * u_xlat3.x;
    u_xlat39 = (-u_xlat39) + _Glossiness;
    u_xlat39 = u_xlat39 + 1.0;
    u_xlat39 = clamp(u_xlat39, 0.0, 1.0);
    u_xlat3.xyw = vec3(u_xlat28) * u_xlat5.xyz;
    u_xlat3.xyw = u_xlat6.xyz * vec3(u_xlat41) + u_xlat3.xyw;
    u_xlat5.xyz = u_xlat5.xyz * vec3(u_xlat40);
    u_xlat40 = (-u_xlat15.x) + 1.0;
    u_xlat15.x = u_xlat40 * u_xlat40;
    u_xlat15.x = u_xlat15.x * u_xlat15.x;
    u_xlat40 = u_xlat40 * u_xlat15.x;
    u_xlat15.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat15.xyz = u_xlat15.xyz * vec3(u_xlat40) + u_xlat0.xyz;
    u_xlat15.xyz = u_xlat15.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xyw + u_xlat15.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xyw = (-u_xlat0.xyz) + vec3(u_xlat39);
    u_xlat0.xyz = vec3(u_xlat29) * u_xlat3.xyw + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL _EMISSION 
-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "_EmissionMap" to slot 2
Set CUBE Texture "unity_SpecCube0" to slot 3
Set CUBE Texture "unity_SpecCube1" to slot 4
Set 3D Texture "unity_ProbeVolumeSH" to slot 5

Constant Buffer "Globals" (304 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 176
  VectorHalf4 _WorldSpaceLightPos0 at 0
  VectorHalf4 unity_SHAr at 8
  VectorHalf4 unity_SHAg at 16
  VectorHalf4 unity_SHAb at 24
  Vector4 unity_SpecCube0_BoxMax at 32
  Vector4 unity_SpecCube0_BoxMin at 48
  Vector4 unity_SpecCube0_ProbePosition at 64
  VectorHalf4 unity_SpecCube0_HDR at 80
  Vector4 unity_SpecCube1_BoxMax at 96
  Vector4 unity_SpecCube1_BoxMin at 112
  Vector4 unity_SpecCube1_ProbePosition at 128
  VectorHalf4 unity_SpecCube1_HDR at 144
  Vector4 unity_ProbeVolumeParams at 160
  Vector3 unity_ProbeVolumeSizeInv at 240
  Vector3 unity_ProbeVolumeMin at 256
  VectorHalf4 _LightColor0 at 272
  VectorHalf4 _Color at 280
  ScalarHalf _Metallic at 288
  ScalarHalf _Glossiness at 290
  ScalarHalf _OcclusionStrength at 292
  VectorHalf4 _EmissionColor at 296
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    half4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    half4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (2) ]] ,
    sampler sampler_EmissionMap [[ sampler (2) ]] ,
    texturecube<float, access::sample > unity_SpecCube0 [[ texture (3) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (3) ]] ,
    texturecube<float, access::sample > unity_SpecCube1 [[ texture (4) ]] ,
    sampler samplerunity_SpecCube1 [[ sampler (4) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (5) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (5) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    float4 u_xlat1;
    half3 u_xlat16_1;
    half4 u_xlat10_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    float3 u_xlat6;
    half3 u_xlat16_6;
    half4 u_xlat10_6;
    float3 u_xlat7;
    half3 u_xlat16_7;
    half4 u_xlat10_7;
    half4 u_xlat16_8;
    float3 u_xlat9;
    bool3 u_xlatb9;
    float3 u_xlat10;
    half3 u_xlat16_10;
    half3 u_xlat16_11;
    bool3 u_xlatb12;
    half3 u_xlat16_13;
    float3 u_xlat15;
    half3 u_xlat16_18;
    float3 u_xlat19;
    half3 u_xlat16_19;
    float u_xlat20;
    half u_xlat16_21;
    half u_xlat16_22;
    half u_xlat16_32;
    half u_xlat16_36;
    float u_xlat43;
    half u_xlat16_43;
    bool u_xlatb43;
    half u_xlat16_44;
    half u_xlat16_45;
    half u_xlat16_46;
    half u_xlat16_50;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_44 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_44));
    u_xlat16_45 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_45 = rsqrt(u_xlat16_45);
    u_xlat16_0.xyz = half3(half3(u_xlat16_45) * input.TEXCOORD4.xyz);
    u_xlat16_45 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_45 = rsqrt(u_xlat16_45);
    u_xlat16_4.xyz = half3(half3(u_xlat16_45) * input.TEXCOORD1.xyz);
    u_xlat16_1.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_46 = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_46 = half(u_xlat16_1.x * Globals._OcclusionStrength + u_xlat16_46);
    u_xlat16_5.x = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_19.x = dot(u_xlat16_4.xyz, u_xlat16_0.xyz);
    u_xlat16_19.x = half(u_xlat16_19.x + u_xlat16_19.x);
    u_xlat16_19.xyz = half3(u_xlat16_0.xyz * (-u_xlat16_19.xxx) + u_xlat16_4.xyz);
    u_xlatb1 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb1){
        u_xlatb1 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat15.xyz = input.TEXCOORD8.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat15.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD8.xxx + u_xlat15.xyz;
        u_xlat15.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD8.zzz + u_xlat15.xyz;
        u_xlat15.xyz = u_xlat15.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb1)) ? u_xlat15.xyz : input.TEXCOORD8.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat15.x = u_xlat1.y * 0.25;
        u_xlat6.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat20 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat15.x = max(u_xlat15.x, u_xlat6.x);
        u_xlat1.x = min(u_xlat20, u_xlat15.x);
        u_xlat10_6 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw));
        u_xlat7.xyz = u_xlat1.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_7 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat7.xyz));
        u_xlat1.xyz = u_xlat1.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_1 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xyz));
        u_xlat16_0.w = 1.0;
        u_xlat16_8.x = half(dot(float4(u_xlat10_6), float4(u_xlat16_0)));
        u_xlat16_8.y = half(dot(float4(u_xlat10_7), float4(u_xlat16_0)));
        u_xlat16_8.z = half(dot(float4(u_xlat10_1), float4(u_xlat16_0)));
    } else {
        u_xlat16_0.w = 1.0;
        u_xlat16_8.x = dot(Globals.unity_SHAr, u_xlat16_0);
        u_xlat16_8.y = dot(Globals.unity_SHAg, u_xlat16_0);
        u_xlat16_8.z = dot(Globals.unity_SHAb, u_xlat16_0);
    }
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz + input.TEXCOORD5.xyz);
    u_xlat16_8.xyz = half3(max(float3(u_xlat16_8.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_1.xyz = log2(u_xlat16_8.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_1.xyz = exp2(u_xlat16_1.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_1.xyz = half3(max(float3(u_xlat16_1.xyz), float3(0.0, 0.0, 0.0)));
    u_xlatb43 = 0.0<Globals.unity_SpecCube0_ProbePosition.w;
    if(u_xlatb43){
        u_xlat16_8.x = dot(u_xlat16_19.xyz, u_xlat16_19.xyz);
        u_xlat16_8.x = rsqrt(u_xlat16_8.x);
        u_xlat16_8.xyz = half3(u_xlat16_19.xyz * u_xlat16_8.xxx);
        u_xlat6.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMax.xyz;
        u_xlat6.xyz = u_xlat6.xyz / float3(u_xlat16_8.xyz);
        u_xlat7.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMin.xyz;
        u_xlat7.xyz = u_xlat7.xyz / float3(u_xlat16_8.xyz);
        u_xlatb9.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_8.xyz));
        u_xlat16_10.x = (u_xlatb9.x) ? half(u_xlat6.x) : half(u_xlat7.x);
        u_xlat16_10.y = (u_xlatb9.y) ? half(u_xlat6.y) : half(u_xlat7.y);
        u_xlat16_10.z = (u_xlatb9.z) ? half(u_xlat6.z) : half(u_xlat7.z);
        u_xlat16_50 = min(u_xlat16_10.y, u_xlat16_10.x);
        u_xlat16_50 = min(u_xlat16_10.z, u_xlat16_50);
        u_xlat6.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube0_ProbePosition.xyz);
        u_xlat6.xyz = float3(u_xlat16_8.xyz) * float3(u_xlat16_50) + u_xlat6.xyz;
        u_xlat16_6.xyz = half3(u_xlat6.xyz);
    } else {
        u_xlat16_6.xyz = u_xlat16_19.xyz;
    }
    u_xlat16_8.x = half((-float(u_xlat16_5.x)) * 0.699999988 + 1.70000005);
    u_xlat16_8.x = half(u_xlat16_5.x * u_xlat16_8.x);
    u_xlat16_8.x = half(float(u_xlat16_8.x) * 6.0);
    u_xlat10_6 = half4(unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_6.xyz), level(float(u_xlat16_8.x))));
    u_xlatb43 = Globals.unity_SpecCube0_HDR.w==1.0;
    u_xlat16_22 = (u_xlatb43) ? half(u_xlat10_6.w) : 1.0;
    u_xlat16_22 = half(u_xlat16_22 * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_10.xyz = half3(float3(u_xlat10_6.xyz) * float3(u_xlat16_22));
    u_xlatb43 = Globals.unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb43){
        u_xlatb43 = 0.0<Globals.unity_SpecCube1_ProbePosition.w;
        if(u_xlatb43){
            u_xlat16_36 = dot(u_xlat16_19.xyz, u_xlat16_19.xyz);
            u_xlat16_36 = rsqrt(u_xlat16_36);
            u_xlat16_11.xyz = half3(u_xlat16_19.xyz * half3(u_xlat16_36));
            u_xlat7.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMax.xyz;
            u_xlat7.xyz = u_xlat7.xyz / float3(u_xlat16_11.xyz);
            u_xlat9.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMin.xyz;
            u_xlat9.xyz = u_xlat9.xyz / float3(u_xlat16_11.xyz);
            u_xlatb12.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_11.xyz));
            u_xlat16_13.x = (u_xlatb12.x) ? half(u_xlat7.x) : half(u_xlat9.x);
            u_xlat16_13.y = (u_xlatb12.y) ? half(u_xlat7.y) : half(u_xlat9.y);
            u_xlat16_13.z = (u_xlatb12.z) ? half(u_xlat7.z) : half(u_xlat9.z);
            u_xlat16_36 = min(u_xlat16_13.y, u_xlat16_13.x);
            u_xlat16_36 = min(u_xlat16_13.z, u_xlat16_36);
            u_xlat7.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube1_ProbePosition.xyz);
            u_xlat19.xyz = float3(u_xlat16_11.xyz) * float3(u_xlat16_36) + u_xlat7.xyz;
            u_xlat16_19.xyz = half3(u_xlat19.xyz);
        }
        u_xlat10_7 = half4(unity_SpecCube1.sample(samplerunity_SpecCube0, float3(u_xlat16_19.xyz), level(float(u_xlat16_8.x))));
        u_xlatb43 = Globals.unity_SpecCube1_HDR.w==1.0;
        u_xlat16_19.x = (u_xlatb43) ? half(u_xlat10_7.w) : 1.0;
        u_xlat16_19.x = half(u_xlat16_19.x * Globals.unity_SpecCube1_HDR.x);
        u_xlat16_19.xyz = half3(float3(u_xlat10_7.xyz) * float3(u_xlat16_19.xxx));
        u_xlat16_7.xyz = half3(float3(u_xlat16_22) * float3(u_xlat10_6.xyz) + (-float3(u_xlat16_19.xyz)));
        u_xlat10.xyz = Globals.unity_SpecCube0_BoxMin.www * float3(u_xlat16_7.xyz) + float3(u_xlat16_19.xyz);
        u_xlat16_10.xyz = half3(u_xlat10.xyz);
    }
    u_xlat16_19.xyz = half3(half3(u_xlat16_46) * u_xlat16_10.xyz);
    u_xlat16_8.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_45) + Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_45 = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlat16_43 = half(max(float(u_xlat16_45), 0.00100000005));
    u_xlat16_45 = rsqrt(u_xlat16_43);
    u_xlat16_8.xyz = half3(half3(u_xlat16_45) * u_xlat16_8.xyz);
    u_xlat16_45 = dot(u_xlat16_0.xyz, (-u_xlat16_4.xyz));
    u_xlat16_4.x = dot(u_xlat16_0.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_18.x = dot(u_xlat16_0.xyz, u_xlat16_8.xyz);
    u_xlat16_18.x = clamp(u_xlat16_18.x, 0.0h, 1.0h);
    u_xlat16_32 = dot(Globals._WorldSpaceLightPos0.xyz, u_xlat16_8.xyz);
    u_xlat16_32 = clamp(u_xlat16_32, 0.0h, 1.0h);
    u_xlat16_8.x = half(u_xlat16_32 * u_xlat16_32);
    u_xlat16_8.x = dot(u_xlat16_8.xx, u_xlat16_5.xx);
    u_xlat16_8.x = half(float(u_xlat16_8.x) + -0.5);
    u_xlat16_22 = half((-float(u_xlat16_4.x)) + 1.0);
    u_xlat16_36 = half(u_xlat16_22 * u_xlat16_22);
    u_xlat16_36 = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_22 = half(u_xlat16_22 * u_xlat16_36);
    u_xlat16_22 = half(float(u_xlat16_8.x) * float(u_xlat16_22) + 1.0);
    u_xlat16_36 = half(-abs(float(u_xlat16_45)) + 1.0);
    u_xlat16_50 = half(u_xlat16_36 * u_xlat16_36);
    u_xlat16_50 = half(u_xlat16_50 * u_xlat16_50);
    u_xlat16_36 = half(u_xlat16_36 * u_xlat16_50);
    u_xlat16_8.x = half(float(u_xlat16_8.x) * float(u_xlat16_36) + 1.0);
    u_xlat16_8.x = half(u_xlat16_8.x * u_xlat16_22);
    u_xlat16_8.x = half(u_xlat16_4.x * u_xlat16_8.x);
    u_xlat16_22 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_50 = half((-float(u_xlat16_5.x)) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_10.x = half(abs(u_xlat16_45) * u_xlat16_50 + u_xlat16_22);
    u_xlat16_50 = half(u_xlat16_4.x * u_xlat16_50 + u_xlat16_22);
    u_xlat16_45 = half(abs(u_xlat16_45) * u_xlat16_50);
    u_xlat16_45 = half(u_xlat16_4.x * u_xlat16_10.x + u_xlat16_45);
    u_xlat16_43 = half(float(u_xlat16_45) + 9.99999975e-06);
    u_xlat16_43 = half(0.5 / float(u_xlat16_43));
    u_xlat16_45 = half(u_xlat16_22 * u_xlat16_22);
    u_xlat16_50 = half(u_xlat16_18.x * u_xlat16_45 + (-u_xlat16_18.x));
    u_xlat16_7.x = half(float(u_xlat16_50) * float(u_xlat16_18.x) + 1.0);
    u_xlat16_21 = half(float(u_xlat16_45) * 0.318309873);
    u_xlat16_7.x = half(float(u_xlat16_7.x) * float(u_xlat16_7.x) + 1.00000001e-07);
    u_xlat16_7.x = half(u_xlat16_21 / u_xlat16_7.x);
    u_xlat16_45 = half(u_xlat16_43 * u_xlat16_7.x);
    u_xlat16_43 = half(float(u_xlat16_45) * 3.14159274);
    u_xlat16_43 = half(max(float(u_xlat16_43), 9.99999975e-05));
    u_xlat16_43 = sqrt(u_xlat16_43);
    u_xlat16_45 = half(u_xlat16_4.x * u_xlat16_43);
    u_xlat16_4.x = half(u_xlat16_5.x * u_xlat16_22);
    u_xlat16_4.x = half((-float(u_xlat16_4.x)) * 0.280000001 + 1.0);
    u_xlat16_18.x = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb43 = u_xlat16_18.x!=0.0;
    u_xlat43 = u_xlatb43 ? 1.0 : float(0.0);
    u_xlat16_45 = half(u_xlat43 * float(u_xlat16_45));
    u_xlat16_44 = half((-u_xlat16_44) + Globals._Glossiness);
    u_xlat16_44 = half(float(u_xlat16_44) + 1.0);
    u_xlat16_44 = clamp(u_xlat16_44, 0.0h, 1.0h);
    u_xlat16_8.xyw = half3(u_xlat16_8.xxx * Globals._LightColor0.xyz);
    u_xlat16_8.xyw = half3(u_xlat16_1.xyz * half3(u_xlat16_46) + u_xlat16_8.xyw);
    u_xlat16_10.xyz = half3(half3(u_xlat16_45) * Globals._LightColor0.xyz);
    u_xlat16_45 = half((-float(u_xlat16_32)) + 1.0);
    u_xlat16_18.x = half(u_xlat16_45 * u_xlat16_45);
    u_xlat16_18.x = half(u_xlat16_18.x * u_xlat16_18.x);
    u_xlat16_45 = half(u_xlat16_45 * u_xlat16_18.x);
    u_xlat16_18.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_18.xyz = half3(u_xlat16_18.xyz * half3(u_xlat16_45) + u_xlat16_2.xyz);
    u_xlat16_18.xyz = half3(u_xlat16_18.xyz * u_xlat16_10.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * u_xlat16_8.xyw + u_xlat16_18.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_19.xyz * u_xlat16_4.xxx);
    u_xlat16_5.xyz = half3((-u_xlat16_2.xyz) + half3(u_xlat16_44));
    u_xlat16_2.xyz = half3(half3(u_xlat16_36) * u_xlat16_5.xyz + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_4.xyz * u_xlat16_2.xyz + u_xlat16_3.xyz);
    u_xlat16_1.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    output.SV_Target0.xyz = half3(u_xlat16_1.xyz * Globals._EmissionColor.xyz + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL DIRLIGHTMAP_COMBINED DYNAMICLIGHTMAP_ON _EMISSION 
-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "_EmissionMap" to slot 2
Set 2D Texture "unity_DynamicLightmap" to slot 3
Set 2D Texture "unity_DynamicDirectionality" to slot 4
Set CUBE Texture "unity_SpecCube0" to slot 5
Set CUBE Texture "unity_SpecCube1" to slot 6

Constant Buffer "Globals" (176 bytes) on slot 0 {
  VectorHalf4 _WorldSpaceLightPos0 at 0
  Vector4 unity_SpecCube0_BoxMax at 16
  Vector4 unity_SpecCube0_BoxMin at 32
  Vector4 unity_SpecCube0_ProbePosition at 48
  VectorHalf4 unity_SpecCube0_HDR at 64
  Vector4 unity_SpecCube1_BoxMax at 80
  Vector4 unity_SpecCube1_BoxMin at 96
  Vector4 unity_SpecCube1_ProbePosition at 112
  VectorHalf4 unity_SpecCube1_HDR at 128
  VectorHalf4 unity_DynamicLightmap_HDR at 136
  VectorHalf4 _LightColor0 at 144
  VectorHalf4 _Color at 152
  ScalarHalf _Metallic at 160
  ScalarHalf _Glossiness at 162
  ScalarHalf _OcclusionStrength at 164
  VectorHalf4 _EmissionColor at 168
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    half4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    half4 unity_SpecCube1_HDR;
    half4 unity_DynamicLightmap_HDR;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (2) ]] ,
    sampler sampler_EmissionMap [[ sampler (2) ]] ,
    texture2d<float, access::sample > unity_DynamicLightmap [[ texture (3) ]] ,
    sampler samplerunity_DynamicLightmap [[ sampler (3) ]] ,
    texture2d<float, access::sample > unity_DynamicDirectionality [[ texture (4) ]] ,
    sampler samplerunity_DynamicDirectionality [[ sampler (4) ]] ,
    texturecube<float, access::sample > unity_SpecCube0 [[ texture (5) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (5) ]] ,
    texturecube<float, access::sample > unity_SpecCube1 [[ texture (6) ]] ,
    sampler samplerunity_SpecCube1 [[ sampler (6) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half4 u_xlat10_0;
    float3 u_xlat1;
    half3 u_xlat16_1;
    half4 u_xlat10_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half4 u_xlat16_5;
    float3 u_xlat6;
    half3 u_xlat16_6;
    half4 u_xlat10_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    float3 u_xlat9;
    half3 u_xlat16_9;
    float3 u_xlat10;
    bool3 u_xlatb10;
    half3 u_xlat16_11;
    bool3 u_xlatb12;
    half3 u_xlat16_13;
    half3 u_xlat16_18;
    half u_xlat16_19;
    float3 u_xlat21;
    half3 u_xlat16_21;
    half u_xlat16_23;
    half u_xlat16_32;
    half u_xlat16_33;
    float u_xlat42;
    half u_xlat16_42;
    bool u_xlatb42;
    half u_xlat16_44;
    half u_xlat16_45;
    half u_xlat16_46;
    half u_xlat16_47;
    half u_xlat16_48;
    half u_xlat16_49;
    half u_xlat16_53;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_44 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_44));
    u_xlat16_45 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_45 = rsqrt(u_xlat16_45);
    u_xlat16_4.xyz = half3(half3(u_xlat16_45) * input.TEXCOORD4.xyz);
    u_xlat16_45 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_45 = rsqrt(u_xlat16_45);
    u_xlat16_5.xyz = half3(half3(u_xlat16_45) * input.TEXCOORD1.xyz);
    u_xlat16_0.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_46 = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_46 = half(u_xlat16_0.x * Globals._OcclusionStrength + u_xlat16_46);
    u_xlat16_47 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_6.x = dot(u_xlat16_5.xyz, u_xlat16_4.xyz);
    u_xlat16_6.x = half(u_xlat16_6.x + u_xlat16_6.x);
    u_xlat16_6.xyz = half3(u_xlat16_4.xyz * (-u_xlat16_6.xxx) + u_xlat16_5.xyz);
    u_xlat10_0 = half4(unity_DynamicLightmap.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_48 = half(float(u_xlat10_0.w) * float(Globals.unity_DynamicLightmap_HDR.x));
    u_xlat16_7.xyz = half3(float3(u_xlat10_0.xyz) * float3(u_xlat16_48));
    u_xlat16_7.xyz = log2(u_xlat16_7.xyz);
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * Globals.unity_DynamicLightmap_HDR.yyy);
    u_xlat16_7.xyz = exp2(u_xlat16_7.xyz);
    u_xlat10_0 = half4(unity_DynamicDirectionality.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_8.xyz = half3(float3(u_xlat10_0.xyz) + float3(-0.5, -0.5, -0.5));
    u_xlat16_48 = dot(u_xlat16_4.xyz, u_xlat16_8.xyz);
    u_xlat16_48 = half(float(u_xlat16_48) + 0.5);
    u_xlat16_7.xyz = half3(half3(u_xlat16_48) * u_xlat16_7.xyz);
    u_xlat16_0.x = half(max(float(u_xlat10_0.w), 9.99999975e-05));
    u_xlat16_0.xyz = half3(u_xlat16_7.xyz / u_xlat16_0.xxx);
    u_xlatb42 = 0.0<Globals.unity_SpecCube0_ProbePosition.w;
    if(u_xlatb42){
        u_xlat16_48 = dot(u_xlat16_6.xyz, u_xlat16_6.xyz);
        u_xlat16_48 = rsqrt(u_xlat16_48);
        u_xlat16_7.xyz = half3(half3(u_xlat16_48) * u_xlat16_6.xyz);
        u_xlat1.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMax.xyz;
        u_xlat1.xyz = u_xlat1.xyz / float3(u_xlat16_7.xyz);
        u_xlat9.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMin.xyz;
        u_xlat9.xyz = u_xlat9.xyz / float3(u_xlat16_7.xyz);
        u_xlatb10.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_7.xyz));
        u_xlat16_11.x = (u_xlatb10.x) ? half(u_xlat1.x) : half(u_xlat9.x);
        u_xlat16_11.y = (u_xlatb10.y) ? half(u_xlat1.y) : half(u_xlat9.y);
        u_xlat16_11.z = (u_xlatb10.z) ? half(u_xlat1.z) : half(u_xlat9.z);
        u_xlat16_48 = min(u_xlat16_11.y, u_xlat16_11.x);
        u_xlat16_48 = min(u_xlat16_11.z, u_xlat16_48);
        u_xlat1.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube0_ProbePosition.xyz);
        u_xlat1.xyz = float3(u_xlat16_7.xyz) * float3(u_xlat16_48) + u_xlat1.xyz;
        u_xlat16_1.xyz = half3(u_xlat1.xyz);
    } else {
        u_xlat16_1.xyz = u_xlat16_6.xyz;
    }
    u_xlat16_48 = half((-float(u_xlat16_47)) * 0.699999988 + 1.70000005);
    u_xlat16_48 = half(u_xlat16_47 * u_xlat16_48);
    u_xlat16_48 = half(float(u_xlat16_48) * 6.0);
    u_xlat10_1 = half4(unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_1.xyz), level(float(u_xlat16_48))));
    u_xlatb42 = Globals.unity_SpecCube0_HDR.w==1.0;
    u_xlat16_7.x = (u_xlatb42) ? half(u_xlat10_1.w) : 1.0;
    u_xlat16_7.x = half(u_xlat16_7.x * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_21.xyz = half3(float3(u_xlat10_1.xyz) * float3(u_xlat16_7.xxx));
    u_xlatb42 = Globals.unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb42){
        u_xlatb42 = 0.0<Globals.unity_SpecCube1_ProbePosition.w;
        if(u_xlatb42){
            u_xlat16_11.x = dot(u_xlat16_6.xyz, u_xlat16_6.xyz);
            u_xlat16_11.x = rsqrt(u_xlat16_11.x);
            u_xlat16_11.xyz = half3(u_xlat16_6.xyz * u_xlat16_11.xxx);
            u_xlat9.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMax.xyz;
            u_xlat9.xyz = u_xlat9.xyz / float3(u_xlat16_11.xyz);
            u_xlat10.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMin.xyz;
            u_xlat10.xyz = u_xlat10.xyz / float3(u_xlat16_11.xyz);
            u_xlatb12.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_11.xyz));
            u_xlat16_13.x = (u_xlatb12.x) ? half(u_xlat9.x) : half(u_xlat10.x);
            u_xlat16_13.y = (u_xlatb12.y) ? half(u_xlat9.y) : half(u_xlat10.y);
            u_xlat16_13.z = (u_xlatb12.z) ? half(u_xlat9.z) : half(u_xlat10.z);
            u_xlat16_53 = min(u_xlat16_13.y, u_xlat16_13.x);
            u_xlat16_53 = min(u_xlat16_13.z, u_xlat16_53);
            u_xlat9.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube1_ProbePosition.xyz);
            u_xlat6.xyz = float3(u_xlat16_11.xyz) * float3(u_xlat16_53) + u_xlat9.xyz;
            u_xlat16_6.xyz = half3(u_xlat6.xyz);
        }
        u_xlat10_6 = half4(unity_SpecCube1.sample(samplerunity_SpecCube0, float3(u_xlat16_6.xyz), level(float(u_xlat16_48))));
        u_xlatb42 = Globals.unity_SpecCube1_HDR.w==1.0;
        u_xlat16_11.x = (u_xlatb42) ? half(u_xlat10_6.w) : 1.0;
        u_xlat16_11.x = half(u_xlat16_11.x * Globals.unity_SpecCube1_HDR.x);
        u_xlat16_11.xyz = half3(float3(u_xlat10_6.xyz) * float3(u_xlat16_11.xxx));
        u_xlat16_9.xyz = half3(float3(u_xlat16_7.xxx) * float3(u_xlat10_1.xyz) + (-float3(u_xlat16_11.xyz)));
        u_xlat21.xyz = Globals.unity_SpecCube0_BoxMin.www * float3(u_xlat16_9.xyz) + float3(u_xlat16_11.xyz);
        u_xlat16_21.xyz = half3(u_xlat21.xyz);
    }
    u_xlat16_7.xyz = half3(half3(u_xlat16_46) * u_xlat16_21.xyz);
    u_xlat16_11.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_45) + Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_45 = dot(u_xlat16_11.xyz, u_xlat16_11.xyz);
    u_xlat16_42 = half(max(float(u_xlat16_45), 0.00100000005));
    u_xlat16_45 = rsqrt(u_xlat16_42);
    u_xlat16_11.xyz = half3(half3(u_xlat16_45) * u_xlat16_11.xyz);
    u_xlat16_45 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_5.x = dot(u_xlat16_4.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_5.x = clamp(u_xlat16_5.x, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_11.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_18.x = dot(Globals._WorldSpaceLightPos0.xyz, u_xlat16_11.xyz);
    u_xlat16_18.x = clamp(u_xlat16_18.x, 0.0h, 1.0h);
    u_xlat16_32 = half(u_xlat16_18.x * u_xlat16_18.x);
    u_xlat16_32 = dot(half2(u_xlat16_32), half2(u_xlat16_47));
    u_xlat16_32 = half(float(u_xlat16_32) + -0.5);
    u_xlat16_19 = half((-float(u_xlat16_5.x)) + 1.0);
    u_xlat16_33 = half(u_xlat16_19 * u_xlat16_19);
    u_xlat16_33 = half(u_xlat16_33 * u_xlat16_33);
    u_xlat16_19 = half(u_xlat16_19 * u_xlat16_33);
    u_xlat16_19 = half(float(u_xlat16_32) * float(u_xlat16_19) + 1.0);
    u_xlat16_33 = half(-abs(float(u_xlat16_45)) + 1.0);
    u_xlat16_49 = half(u_xlat16_33 * u_xlat16_33);
    u_xlat16_49 = half(u_xlat16_49 * u_xlat16_49);
    u_xlat16_33 = half(u_xlat16_33 * u_xlat16_49);
    u_xlat16_32 = half(float(u_xlat16_32) * float(u_xlat16_33) + 1.0);
    u_xlat16_32 = half(u_xlat16_32 * u_xlat16_19);
    u_xlat16_32 = half(u_xlat16_5.x * u_xlat16_32);
    u_xlat16_19 = half(u_xlat16_47 * u_xlat16_47);
    u_xlat16_49 = half((-float(u_xlat16_47)) * float(u_xlat16_47) + 1.0);
    u_xlat16_11.x = half(abs(u_xlat16_45) * u_xlat16_49 + u_xlat16_19);
    u_xlat16_49 = half(u_xlat16_5.x * u_xlat16_49 + u_xlat16_19);
    u_xlat16_45 = half(abs(u_xlat16_45) * u_xlat16_49);
    u_xlat16_45 = half(u_xlat16_5.x * u_xlat16_11.x + u_xlat16_45);
    u_xlat16_42 = half(float(u_xlat16_45) + 9.99999975e-06);
    u_xlat16_42 = half(0.5 / float(u_xlat16_42));
    u_xlat16_45 = half(u_xlat16_19 * u_xlat16_19);
    u_xlat16_49 = half(u_xlat16_4.x * u_xlat16_45 + (-u_xlat16_4.x));
    u_xlat16_9.x = half(float(u_xlat16_49) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_23 = half(float(u_xlat16_45) * 0.318309873);
    u_xlat16_9.x = half(float(u_xlat16_9.x) * float(u_xlat16_9.x) + 1.00000001e-07);
    u_xlat16_9.x = half(u_xlat16_23 / u_xlat16_9.x);
    u_xlat16_45 = half(u_xlat16_42 * u_xlat16_9.x);
    u_xlat16_42 = half(float(u_xlat16_45) * 3.14159274);
    u_xlat16_42 = half(max(float(u_xlat16_42), 9.99999975e-05));
    u_xlat16_42 = sqrt(u_xlat16_42);
    u_xlat16_45 = half(u_xlat16_5.x * u_xlat16_42);
    u_xlat16_4.x = half(u_xlat16_19 * u_xlat16_47);
    u_xlat16_4.x = half((-float(u_xlat16_4.x)) * 0.280000001 + 1.0);
    u_xlat16_5.x = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb42 = u_xlat16_5.x!=0.0;
    u_xlat42 = u_xlatb42 ? 1.0 : float(0.0);
    u_xlat16_45 = half(u_xlat42 * float(u_xlat16_45));
    u_xlat16_44 = half((-u_xlat16_44) + Globals._Glossiness);
    u_xlat16_44 = half(float(u_xlat16_44) + 1.0);
    u_xlat16_44 = clamp(u_xlat16_44, 0.0h, 1.0h);
    u_xlat16_5.xyw = half3(half3(u_xlat16_32) * Globals._LightColor0.xyz);
    u_xlat16_5.xyw = half3(u_xlat16_0.xyz * half3(u_xlat16_46) + u_xlat16_5.xyw);
    u_xlat16_11.xyz = half3(half3(u_xlat16_45) * Globals._LightColor0.xyz);
    u_xlat16_45 = half((-float(u_xlat16_18.x)) + 1.0);
    u_xlat16_18.x = half(u_xlat16_45 * u_xlat16_45);
    u_xlat16_18.x = half(u_xlat16_18.x * u_xlat16_18.x);
    u_xlat16_45 = half(u_xlat16_45 * u_xlat16_18.x);
    u_xlat16_18.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_18.xyz = half3(u_xlat16_18.xyz * half3(u_xlat16_45) + u_xlat16_2.xyz);
    u_xlat16_18.xyz = half3(u_xlat16_18.xyz * u_xlat16_11.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * u_xlat16_5.xyw + u_xlat16_18.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_7.xyz * u_xlat16_4.xxx);
    u_xlat16_5.xyw = half3((-u_xlat16_2.xyz) + half3(u_xlat16_44));
    u_xlat16_2.xyz = half3(half3(u_xlat16_33) * u_xlat16_5.xyw + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_4.xyz * u_xlat16_2.xyz + u_xlat16_3.xyz);
    u_xlat16_0.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    output.SV_Target0.xyz = half3(u_xlat16_0.xyz * Globals._EmissionColor.xyz + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_OcclusionMap" to slot 2
Set 2D Texture "_EmissionMap" to slot 3
Set CUBE Texture "unity_SpecCube0" to slot 4
Set CUBE Texture "unity_SpecCube1" to slot 5
Set 3D Texture "unity_ProbeVolumeSH" to slot 6

Constant Buffer "Globals" (304 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 176
  VectorHalf4 _WorldSpaceLightPos0 at 0
  VectorHalf4 unity_SHAr at 8
  VectorHalf4 unity_SHAg at 16
  VectorHalf4 unity_SHAb at 24
  Vector4 unity_SpecCube0_BoxMax at 32
  Vector4 unity_SpecCube0_BoxMin at 48
  Vector4 unity_SpecCube0_ProbePosition at 64
  VectorHalf4 unity_SpecCube0_HDR at 80
  Vector4 unity_SpecCube1_BoxMax at 96
  Vector4 unity_SpecCube1_BoxMin at 112
  Vector4 unity_SpecCube1_ProbePosition at 128
  VectorHalf4 unity_SpecCube1_HDR at 144
  Vector4 unity_ProbeVolumeParams at 160
  Vector3 unity_ProbeVolumeSizeInv at 240
  Vector3 unity_ProbeVolumeMin at 256
  VectorHalf4 _LightColor0 at 272
  VectorHalf4 _Color at 280
  ScalarHalf _Metallic at 288
  ScalarHalf _Glossiness at 290
  ScalarHalf _OcclusionStrength at 292
  VectorHalf4 _EmissionColor at 296
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    half4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    half4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (2) ]] ,
    sampler sampler_OcclusionMap [[ sampler (2) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (3) ]] ,
    sampler sampler_EmissionMap [[ sampler (3) ]] ,
    texturecube<float, access::sample > unity_SpecCube0 [[ texture (4) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (4) ]] ,
    texturecube<float, access::sample > unity_SpecCube1 [[ texture (5) ]] ,
    sampler samplerunity_SpecCube1 [[ sampler (5) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (6) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (6) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    float4 u_xlat1;
    half3 u_xlat16_1;
    half4 u_xlat10_1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    float3 u_xlat7;
    half3 u_xlat16_7;
    half4 u_xlat10_7;
    float3 u_xlat8;
    half3 u_xlat16_8;
    half4 u_xlat10_8;
    half4 u_xlat16_9;
    float3 u_xlat10;
    bool3 u_xlatb10;
    half3 u_xlat16_11;
    bool3 u_xlatb12;
    half3 u_xlat16_13;
    float3 u_xlat15;
    half u_xlat16_15;
    half3 u_xlat16_18;
    float3 u_xlat19;
    half3 u_xlat16_19;
    float u_xlat21;
    half u_xlat16_22;
    float3 u_xlat23;
    half3 u_xlat16_23;
    half u_xlat16_32;
    half u_xlat16_37;
    float u_xlat43;
    half u_xlat16_43;
    bool u_xlatb43;
    half u_xlat16_44;
    half u_xlat16_45;
    half u_xlat16_46;
    half u_xlat16_48;
    half u_xlat16_51;
    half u_xlat16_53;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_44 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_44));
    u_xlat16_45 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_45 = rsqrt(u_xlat16_45);
    u_xlat16_0.xyz = half3(half3(u_xlat16_45) * input.TEXCOORD4.xyz);
    u_xlat16_45 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_45 = rsqrt(u_xlat16_45);
    u_xlat16_4.xyz = half3(half3(u_xlat16_45) * input.TEXCOORD1.xyz);
    u_xlat1.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_1.x = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat1.xy).x;
    u_xlat16_15 = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_46 = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_46 = half(u_xlat16_15 * Globals._OcclusionStrength + u_xlat16_46);
    u_xlat16_5.x = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_19.x = dot(u_xlat16_4.xyz, u_xlat16_0.xyz);
    u_xlat16_19.x = half(u_xlat16_19.x + u_xlat16_19.x);
    u_xlat16_19.xyz = half3(u_xlat16_0.xyz * (-u_xlat16_19.xxx) + u_xlat16_4.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_1.xxx * Globals._LightColor0.xyz);
    u_xlatb1 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb1){
        u_xlatb1 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat15.xyz = input.TEXCOORD8.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat15.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD8.xxx + u_xlat15.xyz;
        u_xlat15.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD8.zzz + u_xlat15.xyz;
        u_xlat15.xyz = u_xlat15.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat1.xyz = (bool(u_xlatb1)) ? u_xlat15.xyz : input.TEXCOORD8.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat1.yzw = u_xlat1.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat15.x = u_xlat1.y * 0.25;
        u_xlat7.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat21 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat15.x = max(u_xlat15.x, u_xlat7.x);
        u_xlat1.x = min(u_xlat21, u_xlat15.x);
        u_xlat10_7 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xzw));
        u_xlat8.xyz = u_xlat1.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_8 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat8.xyz));
        u_xlat1.xyz = u_xlat1.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_1 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat1.xyz));
        u_xlat16_0.w = 1.0;
        u_xlat16_9.x = half(dot(float4(u_xlat10_7), float4(u_xlat16_0)));
        u_xlat16_9.y = half(dot(float4(u_xlat10_8), float4(u_xlat16_0)));
        u_xlat16_9.z = half(dot(float4(u_xlat10_1), float4(u_xlat16_0)));
    } else {
        u_xlat16_0.w = 1.0;
        u_xlat16_9.x = dot(Globals.unity_SHAr, u_xlat16_0);
        u_xlat16_9.y = dot(Globals.unity_SHAg, u_xlat16_0);
        u_xlat16_9.z = dot(Globals.unity_SHAb, u_xlat16_0);
    }
    u_xlat16_9.xyz = half3(u_xlat16_9.xyz + input.TEXCOORD5.xyz);
    u_xlat16_9.xyz = half3(max(float3(u_xlat16_9.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_1.xyz = log2(u_xlat16_9.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_1.xyz = exp2(u_xlat16_1.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_1.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_1.xyz = half3(max(float3(u_xlat16_1.xyz), float3(0.0, 0.0, 0.0)));
    u_xlatb43 = 0.0<Globals.unity_SpecCube0_ProbePosition.w;
    if(u_xlatb43){
        u_xlat16_48 = dot(u_xlat16_19.xyz, u_xlat16_19.xyz);
        u_xlat16_48 = rsqrt(u_xlat16_48);
        u_xlat16_9.xyz = half3(u_xlat16_19.xyz * half3(u_xlat16_48));
        u_xlat7.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMax.xyz;
        u_xlat7.xyz = u_xlat7.xyz / float3(u_xlat16_9.xyz);
        u_xlat8.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMin.xyz;
        u_xlat8.xyz = u_xlat8.xyz / float3(u_xlat16_9.xyz);
        u_xlatb10.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_9.xyz));
        u_xlat16_11.x = (u_xlatb10.x) ? half(u_xlat7.x) : half(u_xlat8.x);
        u_xlat16_11.y = (u_xlatb10.y) ? half(u_xlat7.y) : half(u_xlat8.y);
        u_xlat16_11.z = (u_xlatb10.z) ? half(u_xlat7.z) : half(u_xlat8.z);
        u_xlat16_48 = min(u_xlat16_11.y, u_xlat16_11.x);
        u_xlat16_48 = min(u_xlat16_11.z, u_xlat16_48);
        u_xlat7.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube0_ProbePosition.xyz);
        u_xlat7.xyz = float3(u_xlat16_9.xyz) * float3(u_xlat16_48) + u_xlat7.xyz;
        u_xlat16_7.xyz = half3(u_xlat7.xyz);
    } else {
        u_xlat16_7.xyz = u_xlat16_19.xyz;
    }
    u_xlat16_48 = half((-float(u_xlat16_5.x)) * 0.699999988 + 1.70000005);
    u_xlat16_48 = half(u_xlat16_5.x * u_xlat16_48);
    u_xlat16_48 = half(float(u_xlat16_48) * 6.0);
    u_xlat10_7 = half4(unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_7.xyz), level(float(u_xlat16_48))));
    u_xlatb43 = Globals.unity_SpecCube0_HDR.w==1.0;
    u_xlat16_9.x = (u_xlatb43) ? half(u_xlat10_7.w) : 1.0;
    u_xlat16_9.x = half(u_xlat16_9.x * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_23.xyz = half3(float3(u_xlat10_7.xyz) * float3(u_xlat16_9.xxx));
    u_xlatb43 = Globals.unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb43){
        u_xlatb43 = 0.0<Globals.unity_SpecCube1_ProbePosition.w;
        if(u_xlatb43){
            u_xlat16_11.x = dot(u_xlat16_19.xyz, u_xlat16_19.xyz);
            u_xlat16_11.x = rsqrt(u_xlat16_11.x);
            u_xlat16_11.xyz = half3(u_xlat16_19.xyz * u_xlat16_11.xxx);
            u_xlat8.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMax.xyz;
            u_xlat8.xyz = u_xlat8.xyz / float3(u_xlat16_11.xyz);
            u_xlat10.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMin.xyz;
            u_xlat10.xyz = u_xlat10.xyz / float3(u_xlat16_11.xyz);
            u_xlatb12.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_11.xyz));
            u_xlat16_13.x = (u_xlatb12.x) ? half(u_xlat8.x) : half(u_xlat10.x);
            u_xlat16_13.y = (u_xlatb12.y) ? half(u_xlat8.y) : half(u_xlat10.y);
            u_xlat16_13.z = (u_xlatb12.z) ? half(u_xlat8.z) : half(u_xlat10.z);
            u_xlat16_53 = min(u_xlat16_13.y, u_xlat16_13.x);
            u_xlat16_53 = min(u_xlat16_13.z, u_xlat16_53);
            u_xlat8.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube1_ProbePosition.xyz);
            u_xlat19.xyz = float3(u_xlat16_11.xyz) * float3(u_xlat16_53) + u_xlat8.xyz;
            u_xlat16_19.xyz = half3(u_xlat19.xyz);
        }
        u_xlat10_8 = half4(unity_SpecCube1.sample(samplerunity_SpecCube0, float3(u_xlat16_19.xyz), level(float(u_xlat16_48))));
        u_xlatb43 = Globals.unity_SpecCube1_HDR.w==1.0;
        u_xlat16_19.x = (u_xlatb43) ? half(u_xlat10_8.w) : 1.0;
        u_xlat16_19.x = half(u_xlat16_19.x * Globals.unity_SpecCube1_HDR.x);
        u_xlat16_19.xyz = half3(float3(u_xlat10_8.xyz) * float3(u_xlat16_19.xxx));
        u_xlat16_8.xyz = half3(float3(u_xlat16_9.xxx) * float3(u_xlat10_7.xyz) + (-float3(u_xlat16_19.xyz)));
        u_xlat23.xyz = Globals.unity_SpecCube0_BoxMin.www * float3(u_xlat16_8.xyz) + float3(u_xlat16_19.xyz);
        u_xlat16_23.xyz = half3(u_xlat23.xyz);
    }
    u_xlat16_19.xyz = half3(half3(u_xlat16_46) * u_xlat16_23.xyz);
    u_xlat16_9.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_45) + Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_45 = dot(u_xlat16_9.xyz, u_xlat16_9.xyz);
    u_xlat16_43 = half(max(float(u_xlat16_45), 0.00100000005));
    u_xlat16_45 = rsqrt(u_xlat16_43);
    u_xlat16_9.xyz = half3(half3(u_xlat16_45) * u_xlat16_9.xyz);
    u_xlat16_45 = dot(u_xlat16_0.xyz, (-u_xlat16_4.xyz));
    u_xlat16_4.x = dot(u_xlat16_0.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_18.x = dot(u_xlat16_0.xyz, u_xlat16_9.xyz);
    u_xlat16_18.x = clamp(u_xlat16_18.x, 0.0h, 1.0h);
    u_xlat16_32 = dot(Globals._WorldSpaceLightPos0.xyz, u_xlat16_9.xyz);
    u_xlat16_32 = clamp(u_xlat16_32, 0.0h, 1.0h);
    u_xlat16_48 = half(u_xlat16_32 * u_xlat16_32);
    u_xlat16_48 = dot(half2(u_xlat16_48), u_xlat16_5.xx);
    u_xlat16_48 = half(float(u_xlat16_48) + -0.5);
    u_xlat16_9.x = half((-float(u_xlat16_4.x)) + 1.0);
    u_xlat16_23.x = half(u_xlat16_9.x * u_xlat16_9.x);
    u_xlat16_23.x = half(u_xlat16_23.x * u_xlat16_23.x);
    u_xlat16_9.x = half(u_xlat16_9.x * u_xlat16_23.x);
    u_xlat16_9.x = half(float(u_xlat16_48) * float(u_xlat16_9.x) + 1.0);
    u_xlat16_23.x = half(-abs(float(u_xlat16_45)) + 1.0);
    u_xlat16_37 = half(u_xlat16_23.x * u_xlat16_23.x);
    u_xlat16_37 = half(u_xlat16_37 * u_xlat16_37);
    u_xlat16_23.x = half(u_xlat16_23.x * u_xlat16_37);
    u_xlat16_48 = half(float(u_xlat16_48) * float(u_xlat16_23.x) + 1.0);
    u_xlat16_48 = half(u_xlat16_48 * u_xlat16_9.x);
    u_xlat16_48 = half(u_xlat16_4.x * u_xlat16_48);
    u_xlat16_9.x = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_37 = half((-float(u_xlat16_5.x)) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_51 = half(abs(u_xlat16_45) * u_xlat16_37 + u_xlat16_9.x);
    u_xlat16_37 = half(u_xlat16_4.x * u_xlat16_37 + u_xlat16_9.x);
    u_xlat16_45 = half(abs(u_xlat16_45) * u_xlat16_37);
    u_xlat16_45 = half(u_xlat16_4.x * u_xlat16_51 + u_xlat16_45);
    u_xlat16_43 = half(float(u_xlat16_45) + 9.99999975e-06);
    u_xlat16_43 = half(0.5 / float(u_xlat16_43));
    u_xlat16_45 = half(u_xlat16_9.x * u_xlat16_9.x);
    u_xlat16_37 = half(u_xlat16_18.x * u_xlat16_45 + (-u_xlat16_18.x));
    u_xlat16_8.x = half(float(u_xlat16_37) * float(u_xlat16_18.x) + 1.0);
    u_xlat16_22 = half(float(u_xlat16_45) * 0.318309873);
    u_xlat16_8.x = half(float(u_xlat16_8.x) * float(u_xlat16_8.x) + 1.00000001e-07);
    u_xlat16_8.x = half(u_xlat16_22 / u_xlat16_8.x);
    u_xlat16_45 = half(u_xlat16_43 * u_xlat16_8.x);
    u_xlat16_43 = half(float(u_xlat16_45) * 3.14159274);
    u_xlat16_43 = half(max(float(u_xlat16_43), 9.99999975e-05));
    u_xlat16_43 = sqrt(u_xlat16_43);
    u_xlat16_45 = half(u_xlat16_4.x * u_xlat16_43);
    u_xlat16_4.x = half(u_xlat16_5.x * u_xlat16_9.x);
    u_xlat16_4.x = half((-float(u_xlat16_4.x)) * 0.280000001 + 1.0);
    u_xlat16_18.x = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb43 = u_xlat16_18.x!=0.0;
    u_xlat43 = u_xlatb43 ? 1.0 : float(0.0);
    u_xlat16_45 = half(u_xlat43 * float(u_xlat16_45));
    u_xlat16_44 = half((-u_xlat16_44) + Globals._Glossiness);
    u_xlat16_44 = half(float(u_xlat16_44) + 1.0);
    u_xlat16_44 = clamp(u_xlat16_44, 0.0h, 1.0h);
    u_xlat16_9.xzw = half3(half3(u_xlat16_48) * u_xlat16_6.xyz);
    u_xlat16_9.xzw = half3(u_xlat16_1.xyz * half3(u_xlat16_46) + u_xlat16_9.xzw);
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_45));
    u_xlat16_45 = half((-float(u_xlat16_32)) + 1.0);
    u_xlat16_18.x = half(u_xlat16_45 * u_xlat16_45);
    u_xlat16_18.x = half(u_xlat16_18.x * u_xlat16_18.x);
    u_xlat16_45 = half(u_xlat16_45 * u_xlat16_18.x);
    u_xlat16_18.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_18.xyz = half3(u_xlat16_18.xyz * half3(u_xlat16_45) + u_xlat16_2.xyz);
    u_xlat16_18.xyz = half3(u_xlat16_18.xyz * u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * u_xlat16_9.xzw + u_xlat16_18.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_19.xyz * u_xlat16_4.xxx);
    u_xlat16_5.xyz = half3((-u_xlat16_2.xyz) + half3(u_xlat16_44));
    u_xlat16_2.xyz = half3(u_xlat16_23.xxx * u_xlat16_5.xyz + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_4.xyz * u_xlat16_2.xyz + u_xlat16_3.xyz);
    u_xlat16_1.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    output.SV_Target0.xyz = half3(u_xlat16_1.xyz * Globals._EmissionColor.xyz + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN DIRLIGHTMAP_COMBINED DYNAMICLIGHTMAP_ON _EMISSION 
-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_OcclusionMap" to slot 2
Set 2D Texture "_EmissionMap" to slot 3
Set 2D Texture "unity_DynamicLightmap" to slot 4
Set 2D Texture "unity_DynamicDirectionality" to slot 5
Set CUBE Texture "unity_SpecCube0" to slot 6
Set CUBE Texture "unity_SpecCube1" to slot 7

Constant Buffer "Globals" (176 bytes) on slot 0 {
  VectorHalf4 _WorldSpaceLightPos0 at 0
  Vector4 unity_SpecCube0_BoxMax at 16
  Vector4 unity_SpecCube0_BoxMin at 32
  Vector4 unity_SpecCube0_ProbePosition at 48
  VectorHalf4 unity_SpecCube0_HDR at 64
  Vector4 unity_SpecCube1_BoxMax at 80
  Vector4 unity_SpecCube1_BoxMin at 96
  Vector4 unity_SpecCube1_ProbePosition at 112
  VectorHalf4 unity_SpecCube1_HDR at 128
  VectorHalf4 unity_DynamicLightmap_HDR at 136
  VectorHalf4 _LightColor0 at 144
  VectorHalf4 _Color at 152
  ScalarHalf _Metallic at 160
  ScalarHalf _Glossiness at 162
  ScalarHalf _OcclusionStrength at 164
  VectorHalf4 _EmissionColor at 168
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    half4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    half4 unity_SpecCube1_HDR;
    half4 unity_DynamicLightmap_HDR;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (2) ]] ,
    sampler sampler_OcclusionMap [[ sampler (2) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (3) ]] ,
    sampler sampler_EmissionMap [[ sampler (3) ]] ,
    texture2d<float, access::sample > unity_DynamicLightmap [[ texture (4) ]] ,
    sampler samplerunity_DynamicLightmap [[ sampler (4) ]] ,
    texture2d<float, access::sample > unity_DynamicDirectionality [[ texture (5) ]] ,
    sampler samplerunity_DynamicDirectionality [[ sampler (5) ]] ,
    texturecube<float, access::sample > unity_SpecCube0 [[ texture (6) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (6) ]] ,
    texturecube<float, access::sample > unity_SpecCube1 [[ texture (7) ]] ,
    sampler samplerunity_SpecCube1 [[ sampler (7) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float2 u_xlat0;
    half3 u_xlat16_0;
    half4 u_xlat10_0;
    float3 u_xlat1;
    half3 u_xlat16_1;
    half4 u_xlat10_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half4 u_xlat16_5;
    float3 u_xlat6;
    half3 u_xlat16_6;
    half4 u_xlat10_6;
    half3 u_xlat16_7;
    float3 u_xlat8;
    half3 u_xlat16_8;
    half3 u_xlat16_9;
    float3 u_xlat10;
    half3 u_xlat16_10;
    float3 u_xlat11;
    bool3 u_xlatb11;
    half3 u_xlat16_12;
    bool3 u_xlatb13;
    half3 u_xlat16_14;
    half u_xlat16_15;
    half3 u_xlat16_19;
    half u_xlat16_20;
    half u_xlat16_25;
    half u_xlat16_34;
    half u_xlat16_35;
    float u_xlat45;
    half u_xlat16_45;
    bool u_xlatb45;
    half u_xlat16_47;
    half u_xlat16_48;
    half u_xlat16_49;
    half u_xlat16_50;
    half u_xlat16_51;
    half u_xlat16_52;
    half u_xlat16_53;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_47 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_47));
    u_xlat16_48 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_48 = rsqrt(u_xlat16_48);
    u_xlat16_4.xyz = half3(half3(u_xlat16_48) * input.TEXCOORD4.xyz);
    u_xlat16_48 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_48 = rsqrt(u_xlat16_48);
    u_xlat16_5.xyz = half3(half3(u_xlat16_48) * input.TEXCOORD1.xyz);
    u_xlat0.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_0.x = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat0.xy).x;
    u_xlat16_15 = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_49 = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_49 = half(u_xlat16_15 * Globals._OcclusionStrength + u_xlat16_49);
    u_xlat16_50 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_6.x = dot(u_xlat16_5.xyz, u_xlat16_4.xyz);
    u_xlat16_6.x = half(u_xlat16_6.x + u_xlat16_6.x);
    u_xlat16_6.xyz = half3(u_xlat16_4.xyz * (-u_xlat16_6.xxx) + u_xlat16_5.xyz);
    u_xlat16_7.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat10_0 = half4(unity_DynamicLightmap.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_51 = half(float(u_xlat10_0.w) * float(Globals.unity_DynamicLightmap_HDR.x));
    u_xlat16_8.xyz = half3(float3(u_xlat10_0.xyz) * float3(u_xlat16_51));
    u_xlat16_8.xyz = log2(u_xlat16_8.xyz);
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * Globals.unity_DynamicLightmap_HDR.yyy);
    u_xlat16_8.xyz = exp2(u_xlat16_8.xyz);
    u_xlat10_0 = half4(unity_DynamicDirectionality.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_9.xyz = half3(float3(u_xlat10_0.xyz) + float3(-0.5, -0.5, -0.5));
    u_xlat16_51 = dot(u_xlat16_4.xyz, u_xlat16_9.xyz);
    u_xlat16_51 = half(float(u_xlat16_51) + 0.5);
    u_xlat16_8.xyz = half3(half3(u_xlat16_51) * u_xlat16_8.xyz);
    u_xlat16_0.x = half(max(float(u_xlat10_0.w), 9.99999975e-05));
    u_xlat16_0.xyz = half3(u_xlat16_8.xyz / u_xlat16_0.xxx);
    u_xlatb45 = 0.0<Globals.unity_SpecCube0_ProbePosition.w;
    if(u_xlatb45){
        u_xlat16_51 = dot(u_xlat16_6.xyz, u_xlat16_6.xyz);
        u_xlat16_51 = rsqrt(u_xlat16_51);
        u_xlat16_8.xyz = half3(half3(u_xlat16_51) * u_xlat16_6.xyz);
        u_xlat1.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMax.xyz;
        u_xlat1.xyz = u_xlat1.xyz / float3(u_xlat16_8.xyz);
        u_xlat10.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube0_BoxMin.xyz;
        u_xlat10.xyz = u_xlat10.xyz / float3(u_xlat16_8.xyz);
        u_xlatb11.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_8.xyz));
        u_xlat16_12.x = (u_xlatb11.x) ? half(u_xlat1.x) : half(u_xlat10.x);
        u_xlat16_12.y = (u_xlatb11.y) ? half(u_xlat1.y) : half(u_xlat10.y);
        u_xlat16_12.z = (u_xlatb11.z) ? half(u_xlat1.z) : half(u_xlat10.z);
        u_xlat16_51 = min(u_xlat16_12.y, u_xlat16_12.x);
        u_xlat16_51 = min(u_xlat16_12.z, u_xlat16_51);
        u_xlat1.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube0_ProbePosition.xyz);
        u_xlat1.xyz = float3(u_xlat16_8.xyz) * float3(u_xlat16_51) + u_xlat1.xyz;
        u_xlat16_1.xyz = half3(u_xlat1.xyz);
    } else {
        u_xlat16_1.xyz = u_xlat16_6.xyz;
    }
    u_xlat16_51 = half((-float(u_xlat16_50)) * 0.699999988 + 1.70000005);
    u_xlat16_51 = half(u_xlat16_50 * u_xlat16_51);
    u_xlat16_51 = half(float(u_xlat16_51) * 6.0);
    u_xlat10_1 = half4(unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_1.xyz), level(float(u_xlat16_51))));
    u_xlatb45 = Globals.unity_SpecCube0_HDR.w==1.0;
    u_xlat16_52 = (u_xlatb45) ? half(u_xlat10_1.w) : 1.0;
    u_xlat16_52 = half(u_xlat16_52 * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_8.xyz = half3(float3(u_xlat10_1.xyz) * float3(u_xlat16_52));
    u_xlatb45 = Globals.unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb45){
        u_xlatb45 = 0.0<Globals.unity_SpecCube1_ProbePosition.w;
        if(u_xlatb45){
            u_xlat16_53 = dot(u_xlat16_6.xyz, u_xlat16_6.xyz);
            u_xlat16_53 = rsqrt(u_xlat16_53);
            u_xlat16_12.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_53));
            u_xlat10.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMax.xyz;
            u_xlat10.xyz = u_xlat10.xyz / float3(u_xlat16_12.xyz);
            u_xlat11.xyz = (-input.TEXCOORD8.xyz) + Globals.unity_SpecCube1_BoxMin.xyz;
            u_xlat11.xyz = u_xlat11.xyz / float3(u_xlat16_12.xyz);
            u_xlatb13.xyz = (float3(0.0, 0.0, 0.0)<float3(u_xlat16_12.xyz));
            u_xlat16_14.x = (u_xlatb13.x) ? half(u_xlat10.x) : half(u_xlat11.x);
            u_xlat16_14.y = (u_xlatb13.y) ? half(u_xlat10.y) : half(u_xlat11.y);
            u_xlat16_14.z = (u_xlatb13.z) ? half(u_xlat10.z) : half(u_xlat11.z);
            u_xlat16_53 = min(u_xlat16_14.y, u_xlat16_14.x);
            u_xlat16_53 = min(u_xlat16_14.z, u_xlat16_53);
            u_xlat10.xyz = input.TEXCOORD8.xyz + (-Globals.unity_SpecCube1_ProbePosition.xyz);
            u_xlat6.xyz = float3(u_xlat16_12.xyz) * float3(u_xlat16_53) + u_xlat10.xyz;
            u_xlat16_6.xyz = half3(u_xlat6.xyz);
        }
        u_xlat10_6 = half4(unity_SpecCube1.sample(samplerunity_SpecCube0, float3(u_xlat16_6.xyz), level(float(u_xlat16_51))));
        u_xlatb45 = Globals.unity_SpecCube1_HDR.w==1.0;
        u_xlat16_53 = (u_xlatb45) ? half(u_xlat10_6.w) : 1.0;
        u_xlat16_53 = half(u_xlat16_53 * Globals.unity_SpecCube1_HDR.x);
        u_xlat16_12.xyz = half3(float3(u_xlat10_6.xyz) * float3(u_xlat16_53));
        u_xlat16_10.xyz = half3(float3(u_xlat16_52) * float3(u_xlat10_1.xyz) + (-float3(u_xlat16_12.xyz)));
        u_xlat8.xyz = Globals.unity_SpecCube0_BoxMin.www * float3(u_xlat16_10.xyz) + float3(u_xlat16_12.xyz);
        u_xlat16_8.xyz = half3(u_xlat8.xyz);
    }
    u_xlat16_8.xyz = half3(half3(u_xlat16_49) * u_xlat16_8.xyz);
    u_xlat16_12.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_48) + Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_48 = dot(u_xlat16_12.xyz, u_xlat16_12.xyz);
    u_xlat16_45 = half(max(float(u_xlat16_48), 0.00100000005));
    u_xlat16_48 = rsqrt(u_xlat16_45);
    u_xlat16_12.xyz = half3(half3(u_xlat16_48) * u_xlat16_12.xyz);
    u_xlat16_48 = dot(u_xlat16_4.xyz, (-u_xlat16_5.xyz));
    u_xlat16_5.x = dot(u_xlat16_4.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_5.x = clamp(u_xlat16_5.x, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_4.xyz, u_xlat16_12.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_19.x = dot(Globals._WorldSpaceLightPos0.xyz, u_xlat16_12.xyz);
    u_xlat16_19.x = clamp(u_xlat16_19.x, 0.0h, 1.0h);
    u_xlat16_34 = half(u_xlat16_19.x * u_xlat16_19.x);
    u_xlat16_34 = dot(half2(u_xlat16_34), half2(u_xlat16_50));
    u_xlat16_34 = half(float(u_xlat16_34) + -0.5);
    u_xlat16_20 = half((-float(u_xlat16_5.x)) + 1.0);
    u_xlat16_35 = half(u_xlat16_20 * u_xlat16_20);
    u_xlat16_35 = half(u_xlat16_35 * u_xlat16_35);
    u_xlat16_20 = half(u_xlat16_20 * u_xlat16_35);
    u_xlat16_20 = half(float(u_xlat16_34) * float(u_xlat16_20) + 1.0);
    u_xlat16_35 = half(-abs(float(u_xlat16_48)) + 1.0);
    u_xlat16_52 = half(u_xlat16_35 * u_xlat16_35);
    u_xlat16_52 = half(u_xlat16_52 * u_xlat16_52);
    u_xlat16_35 = half(u_xlat16_35 * u_xlat16_52);
    u_xlat16_34 = half(float(u_xlat16_34) * float(u_xlat16_35) + 1.0);
    u_xlat16_34 = half(u_xlat16_34 * u_xlat16_20);
    u_xlat16_34 = half(u_xlat16_5.x * u_xlat16_34);
    u_xlat16_20 = half(u_xlat16_50 * u_xlat16_50);
    u_xlat16_52 = half((-float(u_xlat16_50)) * float(u_xlat16_50) + 1.0);
    u_xlat16_53 = half(abs(u_xlat16_48) * u_xlat16_52 + u_xlat16_20);
    u_xlat16_52 = half(u_xlat16_5.x * u_xlat16_52 + u_xlat16_20);
    u_xlat16_48 = half(abs(u_xlat16_48) * u_xlat16_52);
    u_xlat16_48 = half(u_xlat16_5.x * u_xlat16_53 + u_xlat16_48);
    u_xlat16_45 = half(float(u_xlat16_48) + 9.99999975e-06);
    u_xlat16_45 = half(0.5 / float(u_xlat16_45));
    u_xlat16_48 = half(u_xlat16_20 * u_xlat16_20);
    u_xlat16_52 = half(u_xlat16_4.x * u_xlat16_48 + (-u_xlat16_4.x));
    u_xlat16_10.x = half(float(u_xlat16_52) * float(u_xlat16_4.x) + 1.0);
    u_xlat16_25 = half(float(u_xlat16_48) * 0.318309873);
    u_xlat16_10.x = half(float(u_xlat16_10.x) * float(u_xlat16_10.x) + 1.00000001e-07);
    u_xlat16_10.x = half(u_xlat16_25 / u_xlat16_10.x);
    u_xlat16_48 = half(u_xlat16_45 * u_xlat16_10.x);
    u_xlat16_45 = half(float(u_xlat16_48) * 3.14159274);
    u_xlat16_45 = half(max(float(u_xlat16_45), 9.99999975e-05));
    u_xlat16_45 = sqrt(u_xlat16_45);
    u_xlat16_48 = half(u_xlat16_5.x * u_xlat16_45);
    u_xlat16_4.x = half(u_xlat16_20 * u_xlat16_50);
    u_xlat16_4.x = half((-float(u_xlat16_4.x)) * 0.280000001 + 1.0);
    u_xlat16_5.x = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb45 = u_xlat16_5.x!=0.0;
    u_xlat45 = u_xlatb45 ? 1.0 : float(0.0);
    u_xlat16_48 = half(u_xlat45 * float(u_xlat16_48));
    u_xlat16_47 = half((-u_xlat16_47) + Globals._Glossiness);
    u_xlat16_47 = half(float(u_xlat16_47) + 1.0);
    u_xlat16_47 = clamp(u_xlat16_47, 0.0h, 1.0h);
    u_xlat16_5.xyw = half3(half3(u_xlat16_34) * u_xlat16_7.xyz);
    u_xlat16_5.xyw = half3(u_xlat16_0.xyz * half3(u_xlat16_49) + u_xlat16_5.xyw);
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * half3(u_xlat16_48));
    u_xlat16_48 = half((-float(u_xlat16_19.x)) + 1.0);
    u_xlat16_19.x = half(u_xlat16_48 * u_xlat16_48);
    u_xlat16_19.x = half(u_xlat16_19.x * u_xlat16_19.x);
    u_xlat16_48 = half(u_xlat16_48 * u_xlat16_19.x);
    u_xlat16_19.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_19.xyz = half3(u_xlat16_19.xyz * half3(u_xlat16_48) + u_xlat16_2.xyz);
    u_xlat16_19.xyz = half3(u_xlat16_19.xyz * u_xlat16_7.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * u_xlat16_5.xyw + u_xlat16_19.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_8.xyz * u_xlat16_4.xxx);
    u_xlat16_5.xyw = half3((-u_xlat16_2.xyz) + half3(u_xlat16_47));
    u_xlat16_2.xyz = half3(half3(u_xlat16_35) * u_xlat16_5.xyw + u_xlat16_2.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_4.xyz * u_xlat16_2.xyz + u_xlat16_3.xyz);
    u_xlat16_0.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    output.SV_Target0.xyz = half3(u_xlat16_0.xyz * Globals._EmissionColor.xyz + u_xlat16_2.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (402 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 176
  Matrix4x4 unity_ObjectToWorld at 240
  Matrix4x4 unity_WorldToObject at 304
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_4LightPosX0 at 16
  Vector4 unity_4LightPosY0 at 32
  Vector4 unity_4LightPosZ0 at 48
  VectorHalf4 unity_4LightAtten0 at 64
  VectorHalf4 unity_LightColor[8] at 72
  VectorHalf4 unity_SHBr at 136
  VectorHalf4 unity_SHBg at 144
  VectorHalf4 unity_SHBb at 152
  VectorHalf4 unity_SHC at 160
  Vector4 _MainTex_ST at 368
  Vector4 _DetailAlbedoMap_ST at 384
  ScalarHalf _UVSec at 400
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    half4 u_xlat16_1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    float u_xlat21;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD4.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat21 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    u_xlat2 = (-u_xlat0.yyyy) + Globals.unity_4LightPosY0;
    u_xlat3 = u_xlat1.yyyy * u_xlat2;
    u_xlat2 = u_xlat2 * u_xlat2;
    u_xlat4 = (-u_xlat0.xxxx) + Globals.unity_4LightPosX0;
    u_xlat3 = u_xlat4 * u_xlat1.xxxx + u_xlat3;
    u_xlat2 = u_xlat4 * u_xlat4 + u_xlat2;
    u_xlat4 = (-u_xlat0.zzzz) + Globals.unity_4LightPosZ0;
    output.TEXCOORD8.xyz = u_xlat0.xyz;
    u_xlat0 = u_xlat4 * u_xlat1.zzzz + u_xlat3;
    u_xlat2 = u_xlat4 * u_xlat4 + u_xlat2;
    u_xlat2 = max(u_xlat2, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat3 = rsqrt(u_xlat2);
    u_xlat2 = u_xlat2 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat2 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat2;
    u_xlat0 = u_xlat0 * u_xlat3;
    u_xlat0 = max(u_xlat0, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat2 * u_xlat0;
    u_xlat2.xyz = u_xlat0.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat2.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat0.xxx + u_xlat2.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat0.zzz + u_xlat2.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat0.www + u_xlat0.xyz;
    u_xlat2.xyz = u_xlat0.xyz * float3(0.305306017, 0.305306017, 0.305306017) + float3(0.682171106, 0.682171106, 0.682171106);
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz + float3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat16_5.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_5.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_5.x)));
    u_xlat16_1 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_6.x = dot(Globals.unity_SHBr, u_xlat16_1);
    u_xlat16_6.y = dot(Globals.unity_SHBg, u_xlat16_1);
    u_xlat16_6.z = dot(Globals.unity_SHBb, u_xlat16_1);
    u_xlat16_5.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_5.xxx + u_xlat16_6.xyz);
    output.TEXCOORD5.xyz = half3(u_xlat0.xyz * u_xlat2.xyz + float3(u_xlat16_5.xyz));
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
float u_xlat15;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD4.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = inversesqrt(u_xlat15);
    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat2 = (-u_xlat0.yyyy) + unity_4LightPosY0;
    u_xlat3 = u_xlat1.yyyy * u_xlat2;
    u_xlat2 = u_xlat2 * u_xlat2;
    u_xlat4 = (-u_xlat0.xxxx) + unity_4LightPosX0;
    u_xlat3 = u_xlat4 * u_xlat1.xxxx + u_xlat3;
    u_xlat2 = u_xlat4 * u_xlat4 + u_xlat2;
    u_xlat4 = (-u_xlat0.zzzz) + unity_4LightPosZ0;
    vs_TEXCOORD8.xyz = u_xlat0.xyz;
    u_xlat0 = u_xlat4 * u_xlat1.zzzz + u_xlat3;
    u_xlat2 = u_xlat4 * u_xlat4 + u_xlat2;
    u_xlat2 = max(u_xlat2, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat3 = inversesqrt(u_xlat2);
    u_xlat2 = u_xlat2 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat2 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat2;
    u_xlat0 = u_xlat0 * u_xlat3;
    u_xlat0 = max(u_xlat0, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat2 * u_xlat0;
    u_xlat2.xyz = u_xlat0.yyy * unity_LightColor[1].xyz;
    u_xlat2.xyz = unity_LightColor[0].xyz * u_xlat0.xxx + u_xlat2.xyz;
    u_xlat0.xyz = unity_LightColor[2].xyz * u_xlat0.zzz + u_xlat2.xyz;
    u_xlat0.xyz = unity_LightColor[3].xyz * u_xlat0.www + u_xlat0.xyz;
    u_xlat2.xyz = u_xlat0.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat15 = u_xlat1.y * u_xlat1.y;
    u_xlat15 = u_xlat1.x * u_xlat1.x + (-u_xlat15);
    u_xlat1 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat3.x = dot(unity_SHBr, u_xlat1);
    u_xlat3.y = dot(unity_SHBg, u_xlat1);
    u_xlat3.z = dot(unity_SHBb, u_xlat1);
    u_xlat1.xyz = unity_SHC.xyz * vec3(u_xlat15) + u_xlat3.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz * u_xlat2.xyz + u_xlat1.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
float u_xlat4;
lowp vec4 u_xlat10_4;
vec4 u_xlat5;
lowp vec4 u_xlat10_5;
bool u_xlatb5;
vec3 u_xlat6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
lowp vec4 u_xlat10_7;
vec3 u_xlat8;
lowp vec4 u_xlat10_8;
vec3 u_xlat9;
bvec3 u_xlatb9;
vec3 u_xlat10;
bvec3 u_xlatb11;
vec3 u_xlat14;
float u_xlat15;
vec3 u_xlat16;
vec3 u_xlat17;
float u_xlat18;
float u_xlat26;
float u_xlat27;
float u_xlat36;
float u_xlat37;
float u_xlat38;
bool u_xlatb38;
float u_xlat39;
float u_xlat41;
bool u_xlatb41;
float u_xlat42;
bool u_xlatb42;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat36 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat36) * u_xlat1.xyz;
    u_xlat37 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat2.xyz = vec3(u_xlat37) * vs_TEXCOORD4.xyz;
    u_xlat37 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat3.xyz = vec3(u_xlat37) * vs_TEXCOORD1.xyz;
    u_xlat10_4 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat39 = (-_OcclusionStrength) + 1.0;
    u_xlat39 = u_xlat10_4.y * _OcclusionStrength + u_xlat39;
    u_xlat4 = (-_Glossiness) + 1.0;
    u_xlat16.x = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat16.x = u_xlat16.x + u_xlat16.x;
    u_xlat16.xyz = u_xlat2.xyz * (-u_xlat16.xxx) + u_xlat3.xyz;
    u_xlatb5 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb5){
        u_xlatb5 = unity_ProbeVolumeParams.y==1.0;
        u_xlat17.xyz = vs_TEXCOORD8.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat17.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD8.xxx + u_xlat17.xyz;
        u_xlat17.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD8.zzz + u_xlat17.xyz;
        u_xlat17.xyz = u_xlat17.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb5)) ? u_xlat17.xyz : vs_TEXCOORD8.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat17.x = u_xlat5.y * 0.25;
        u_xlat6.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat18 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat17.x = max(u_xlat17.x, u_xlat6.x);
        u_xlat5.x = min(u_xlat18, u_xlat17.x);
        u_xlat10_6 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
        u_xlat7.xyz = u_xlat5.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_7 = texture(unity_ProbeVolumeSH, u_xlat7.xyz);
        u_xlat5.xyz = u_xlat5.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_5 = texture(unity_ProbeVolumeSH, u_xlat5.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat10_6, u_xlat2);
        u_xlat6.y = dot(u_xlat10_7, u_xlat2);
        u_xlat6.z = dot(u_xlat10_5, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(unity_SHAr, u_xlat2);
        u_xlat6.y = dot(unity_SHAg, u_xlat2);
        u_xlat6.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat5.xyz = u_xlat6.xyz + vs_TEXCOORD5.xyz;
    u_xlat5.xyz = max(u_xlat5.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat5.xyz = log2(u_xlat5.xyz);
    u_xlat5.xyz = u_xlat5.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat5.xyz = exp2(u_xlat5.xyz);
    u_xlat5.xyz = u_xlat5.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat5.xyz = max(u_xlat5.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb38 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb38){
        u_xlat38 = dot(u_xlat16.xyz, u_xlat16.xyz);
        u_xlat38 = inversesqrt(u_xlat38);
        u_xlat6.xyz = vec3(u_xlat38) * u_xlat16.xyz;
        u_xlat7.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat7.xyz = u_xlat7.xyz / u_xlat6.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat6.xyz;
        u_xlatb9.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat6.xyzx).xyz;
        u_xlat7.x = (u_xlatb9.x) ? u_xlat7.x : u_xlat8.x;
        u_xlat7.y = (u_xlatb9.y) ? u_xlat7.y : u_xlat8.y;
        u_xlat7.z = (u_xlatb9.z) ? u_xlat7.z : u_xlat8.z;
        u_xlat38 = min(u_xlat7.y, u_xlat7.x);
        u_xlat38 = min(u_xlat7.z, u_xlat38);
        u_xlat7.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat6.xyz = u_xlat6.xyz * vec3(u_xlat38) + u_xlat7.xyz;
    } else {
        u_xlat6.xyz = u_xlat16.xyz;
    //ENDIF
    }
    u_xlat38 = (-u_xlat4) * 0.699999988 + 1.70000005;
    u_xlat38 = u_xlat38 * u_xlat4;
    u_xlat38 = u_xlat38 * 6.0;
    u_xlat10_6 = textureLod(unity_SpecCube0, u_xlat6.xyz, u_xlat38);
    u_xlatb41 = unity_SpecCube0_HDR.w==1.0;
    u_xlat41 = (u_xlatb41) ? u_xlat10_6.w : 1.0;
    u_xlat41 = u_xlat41 * unity_SpecCube0_HDR.x;
    u_xlat7.xyz = u_xlat10_6.xyz * vec3(u_xlat41);
    u_xlatb42 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb42){
        u_xlatb42 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb42){
            u_xlat42 = dot(u_xlat16.xyz, u_xlat16.xyz);
            u_xlat42 = inversesqrt(u_xlat42);
            u_xlat8.xyz = u_xlat16.xyz * vec3(u_xlat42);
            u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat9.xyz = u_xlat9.xyz / u_xlat8.xyz;
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat8.xyz;
            u_xlatb11.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat8.xyzx).xyz;
            u_xlat9.x = (u_xlatb11.x) ? u_xlat9.x : u_xlat10.x;
            u_xlat9.y = (u_xlatb11.y) ? u_xlat9.y : u_xlat10.y;
            u_xlat9.z = (u_xlatb11.z) ? u_xlat9.z : u_xlat10.z;
            u_xlat42 = min(u_xlat9.y, u_xlat9.x);
            u_xlat42 = min(u_xlat9.z, u_xlat42);
            u_xlat9.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat16.xyz = u_xlat8.xyz * vec3(u_xlat42) + u_xlat9.xyz;
        //ENDIF
        }
        u_xlat10_8 = textureLod(unity_SpecCube1, u_xlat16.xyz, u_xlat38);
        u_xlatb38 = unity_SpecCube1_HDR.w==1.0;
        u_xlat38 = (u_xlatb38) ? u_xlat10_8.w : 1.0;
        u_xlat38 = u_xlat38 * unity_SpecCube1_HDR.x;
        u_xlat16.xyz = u_xlat10_8.xyz * vec3(u_xlat38);
        u_xlat6.xyz = vec3(u_xlat41) * u_xlat10_6.xyz + (-u_xlat16.xyz);
        u_xlat7.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat16.xyz;
    //ENDIF
    }
    u_xlat16.xyz = vec3(u_xlat39) * u_xlat7.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat37) + _WorldSpaceLightPos0.xyz;
    u_xlat37 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat37 = max(u_xlat37, 0.00100000005);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat6.xyz = vec3(u_xlat37) * u_xlat6.xyz;
    u_xlat37 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat38 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat38 = clamp(u_xlat38, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat14.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat14.x = clamp(u_xlat14.x, 0.0, 1.0);
    u_xlat26 = u_xlat14.x * u_xlat14.x;
    u_xlat26 = dot(vec2(u_xlat26), vec2(u_xlat4));
    u_xlat26 = u_xlat26 + -0.5;
    u_xlat3.x = (-u_xlat38) + 1.0;
    u_xlat15 = u_xlat3.x * u_xlat3.x;
    u_xlat15 = u_xlat15 * u_xlat15;
    u_xlat3.x = u_xlat3.x * u_xlat15;
    u_xlat3.x = u_xlat26 * u_xlat3.x + 1.0;
    u_xlat15 = -abs(u_xlat37) + 1.0;
    u_xlat27 = u_xlat15 * u_xlat15;
    u_xlat27 = u_xlat27 * u_xlat27;
    u_xlat15 = u_xlat15 * u_xlat27;
    u_xlat26 = u_xlat26 * u_xlat15 + 1.0;
    u_xlat26 = u_xlat26 * u_xlat3.x;
    u_xlat26 = u_xlat38 * u_xlat26;
    u_xlat3.x = u_xlat4 * u_xlat4;
    u_xlat27 = (-u_xlat4) * u_xlat4 + 1.0;
    u_xlat41 = abs(u_xlat37) * u_xlat27 + u_xlat3.x;
    u_xlat27 = u_xlat38 * u_xlat27 + u_xlat3.x;
    u_xlat37 = abs(u_xlat37) * u_xlat27;
    u_xlat37 = u_xlat38 * u_xlat41 + u_xlat37;
    u_xlat37 = u_xlat37 + 9.99999975e-06;
    u_xlat37 = 0.5 / u_xlat37;
    u_xlat27 = u_xlat3.x * u_xlat3.x;
    u_xlat41 = u_xlat2.x * u_xlat27 + (-u_xlat2.x);
    u_xlat2.x = u_xlat41 * u_xlat2.x + 1.0;
    u_xlat27 = u_xlat27 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat27 / u_xlat2.x;
    u_xlat37 = u_xlat37 * u_xlat2.x;
    u_xlat37 = u_xlat37 * 3.14159274;
    u_xlat37 = max(u_xlat37, 9.99999975e-05);
    u_xlat37 = sqrt(u_xlat37);
    u_xlat37 = u_xlat38 * u_xlat37;
    u_xlat2.x = u_xlat3.x * u_xlat4;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat38 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb38 = u_xlat38!=0.0;
    u_xlat38 = u_xlatb38 ? 1.0 : float(0.0);
    u_xlat37 = u_xlat37 * u_xlat38;
    u_xlat36 = (-u_xlat36) + _Glossiness;
    u_xlat36 = u_xlat36 + 1.0;
    u_xlat36 = clamp(u_xlat36, 0.0, 1.0);
    u_xlat6.xyz = vec3(u_xlat26) * _LightColor0.xyz;
    u_xlat3.xzw = u_xlat5.xyz * vec3(u_xlat39) + u_xlat6.xyz;
    u_xlat5.xyz = vec3(u_xlat37) * _LightColor0.xyz;
    u_xlat37 = (-u_xlat14.x) + 1.0;
    u_xlat14.x = u_xlat37 * u_xlat37;
    u_xlat14.x = u_xlat14.x * u_xlat14.x;
    u_xlat37 = u_xlat37 * u_xlat14.x;
    u_xlat14.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat14.xyz = u_xlat14.xyz * vec3(u_xlat37) + u_xlat0.xyz;
    u_xlat14.xyz = u_xlat14.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat14.xyz;
    u_xlat2.xyz = u_xlat16.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat36);
    u_xlat0.xyz = vec3(u_xlat15) * u_xlat3.xzw + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL DIRLIGHTMAP_COMBINED DYNAMICLIGHTMAP_ON VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 16
  Matrix4x4 unity_ObjectToWorld at 80
  Matrix4x4 unity_WorldToObject at 144
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_WorldTransformParams at 208
  Vector4 unity_DynamicLightmapST at 224
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    float2 TEXCOORD2 [[ attribute(4) ]] ;
    half4 TANGENT0 [[ attribute(5) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    float u_xlat9;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD8.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat1.xyz = float3(u_xlat9) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.w = 0.0;
    u_xlat0.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    output.TEXCOORD5.zw = half2(u_xlat0.xy);
    output.TEXCOORD5.xy = half2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD8.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.w = 0.0;
    vs_TEXCOORD5.zw = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    vs_TEXCOORD5.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_DynamicLightmap_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_DynamicLightmap;
uniform  sampler2D unity_DynamicDirectionality;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
vec3 u_xlat2;
vec4 u_xlat3;
bool u_xlatb3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
lowp vec4 u_xlat10_5;
vec3 u_xlat6;
mediump vec3 u_xlat16_6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
vec3 u_xlat8;
vec3 u_xlat9;
bvec3 u_xlatb9;
vec3 u_xlat10;
bvec3 u_xlatb11;
vec3 u_xlat14;
float u_xlat15;
float u_xlat26;
float u_xlat27;
float u_xlat36;
float u_xlat37;
float u_xlat38;
float u_xlat39;
float u_xlat40;
mediump float u_xlat16_40;
bool u_xlatb40;
float u_xlat41;
bool u_xlatb41;
float u_xlat42;
bool u_xlatb42;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat36 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat36) * u_xlat1.xyz;
    u_xlat37 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat2.xyz = vec3(u_xlat37) * vs_TEXCOORD4.xyz;
    u_xlat37 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat3.xyz = vec3(u_xlat37) * vs_TEXCOORD1.xyz;
    u_xlat10_4 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat38 = (-_OcclusionStrength) + 1.0;
    u_xlat38 = u_xlat10_4.y * _OcclusionStrength + u_xlat38;
    u_xlat39 = (-_Glossiness) + 1.0;
    u_xlat4.x = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat4.x = u_xlat4.x + u_xlat4.x;
    u_xlat4.xyz = u_xlat2.xyz * (-u_xlat4.xxx) + u_xlat3.xyz;
    u_xlat10_5 = texture(unity_DynamicLightmap, vs_TEXCOORD5.zw);
    u_xlat40 = u_xlat10_5.w * unity_DynamicLightmap_HDR.x;
    u_xlat5.xyz = u_xlat10_5.xyz * vec3(u_xlat40);
    u_xlat5.xyz = log2(u_xlat5.xyz);
    u_xlat5.xyz = u_xlat5.xyz * unity_DynamicLightmap_HDR.yyy;
    u_xlat5.xyz = exp2(u_xlat5.xyz);
    u_xlat10_6 = texture(unity_DynamicDirectionality, vs_TEXCOORD5.zw);
    u_xlat16_6.xyz = u_xlat10_6.xyz + vec3(-0.5, -0.5, -0.5);
    u_xlat40 = dot(u_xlat2.xyz, u_xlat16_6.xyz);
    u_xlat40 = u_xlat40 + 0.5;
    u_xlat5.xyz = vec3(u_xlat40) * u_xlat5.xyz;
    u_xlat16_40 = max(u_xlat10_6.w, 9.99999975e-05);
    u_xlat5.xyz = u_xlat5.xyz / vec3(u_xlat16_40);
    u_xlatb40 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb40){
        u_xlat40 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat40 = inversesqrt(u_xlat40);
        u_xlat6.xyz = vec3(u_xlat40) * u_xlat4.xyz;
        u_xlat7.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat7.xyz = u_xlat7.xyz / u_xlat6.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat6.xyz;
        u_xlatb9.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat6.xyzx).xyz;
        u_xlat7.x = (u_xlatb9.x) ? u_xlat7.x : u_xlat8.x;
        u_xlat7.y = (u_xlatb9.y) ? u_xlat7.y : u_xlat8.y;
        u_xlat7.z = (u_xlatb9.z) ? u_xlat7.z : u_xlat8.z;
        u_xlat40 = min(u_xlat7.y, u_xlat7.x);
        u_xlat40 = min(u_xlat7.z, u_xlat40);
        u_xlat7.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat6.xyz = u_xlat6.xyz * vec3(u_xlat40) + u_xlat7.xyz;
    } else {
        u_xlat6.xyz = u_xlat4.xyz;
    //ENDIF
    }
    u_xlat40 = (-u_xlat39) * 0.699999988 + 1.70000005;
    u_xlat40 = u_xlat39 * u_xlat40;
    u_xlat40 = u_xlat40 * 6.0;
    u_xlat10_6 = textureLod(unity_SpecCube0, u_xlat6.xyz, u_xlat40);
    u_xlatb41 = unity_SpecCube0_HDR.w==1.0;
    u_xlat41 = (u_xlatb41) ? u_xlat10_6.w : 1.0;
    u_xlat41 = u_xlat41 * unity_SpecCube0_HDR.x;
    u_xlat7.xyz = u_xlat10_6.xyz * vec3(u_xlat41);
    u_xlatb42 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb42){
        u_xlatb42 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb42){
            u_xlat42 = dot(u_xlat4.xyz, u_xlat4.xyz);
            u_xlat42 = inversesqrt(u_xlat42);
            u_xlat8.xyz = u_xlat4.xyz * vec3(u_xlat42);
            u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat9.xyz = u_xlat9.xyz / u_xlat8.xyz;
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat8.xyz;
            u_xlatb11.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat8.xyzx).xyz;
            u_xlat9.x = (u_xlatb11.x) ? u_xlat9.x : u_xlat10.x;
            u_xlat9.y = (u_xlatb11.y) ? u_xlat9.y : u_xlat10.y;
            u_xlat9.z = (u_xlatb11.z) ? u_xlat9.z : u_xlat10.z;
            u_xlat42 = min(u_xlat9.y, u_xlat9.x);
            u_xlat42 = min(u_xlat9.z, u_xlat42);
            u_xlat9.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat4.xyz = u_xlat8.xyz * vec3(u_xlat42) + u_xlat9.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat4.xyz, u_xlat40);
        u_xlatb42 = unity_SpecCube1_HDR.w==1.0;
        u_xlat40 = (u_xlatb42) ? u_xlat10_4.w : 1.0;
        u_xlat40 = u_xlat40 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat40);
        u_xlat6.xyz = vec3(u_xlat41) * u_xlat10_6.xyz + (-u_xlat4.xyz);
        u_xlat7.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = vec3(u_xlat38) * u_xlat7.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat37) + _WorldSpaceLightPos0.xyz;
    u_xlat37 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat37 = max(u_xlat37, 0.00100000005);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat6.xyz = vec3(u_xlat37) * u_xlat6.xyz;
    u_xlat37 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat3.x = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat3.x = clamp(u_xlat3.x, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat14.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat14.x = clamp(u_xlat14.x, 0.0, 1.0);
    u_xlat26 = u_xlat14.x * u_xlat14.x;
    u_xlat26 = dot(vec2(u_xlat26), vec2(u_xlat39));
    u_xlat26 = u_xlat26 + -0.5;
    u_xlat15 = (-u_xlat3.x) + 1.0;
    u_xlat27 = u_xlat15 * u_xlat15;
    u_xlat27 = u_xlat27 * u_xlat27;
    u_xlat15 = u_xlat15 * u_xlat27;
    u_xlat15 = u_xlat26 * u_xlat15 + 1.0;
    u_xlat27 = -abs(u_xlat37) + 1.0;
    u_xlat40 = u_xlat27 * u_xlat27;
    u_xlat40 = u_xlat40 * u_xlat40;
    u_xlat27 = u_xlat27 * u_xlat40;
    u_xlat26 = u_xlat26 * u_xlat27 + 1.0;
    u_xlat26 = u_xlat26 * u_xlat15;
    u_xlat26 = u_xlat3.x * u_xlat26;
    u_xlat15 = u_xlat39 * u_xlat39;
    u_xlat40 = (-u_xlat39) * u_xlat39 + 1.0;
    u_xlat41 = abs(u_xlat37) * u_xlat40 + u_xlat15;
    u_xlat40 = u_xlat3.x * u_xlat40 + u_xlat15;
    u_xlat37 = abs(u_xlat37) * u_xlat40;
    u_xlat37 = u_xlat3.x * u_xlat41 + u_xlat37;
    u_xlat37 = u_xlat37 + 9.99999975e-06;
    u_xlat37 = 0.5 / u_xlat37;
    u_xlat40 = u_xlat15 * u_xlat15;
    u_xlat41 = u_xlat2.x * u_xlat40 + (-u_xlat2.x);
    u_xlat2.x = u_xlat41 * u_xlat2.x + 1.0;
    u_xlat40 = u_xlat40 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat40 / u_xlat2.x;
    u_xlat37 = u_xlat37 * u_xlat2.x;
    u_xlat37 = u_xlat37 * 3.14159274;
    u_xlat37 = max(u_xlat37, 9.99999975e-05);
    u_xlat37 = sqrt(u_xlat37);
    u_xlat37 = u_xlat3.x * u_xlat37;
    u_xlat2.x = u_xlat15 * u_xlat39;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat3.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb3 = u_xlat3.x!=0.0;
    u_xlat3.x = u_xlatb3 ? 1.0 : float(0.0);
    u_xlat37 = u_xlat37 * u_xlat3.x;
    u_xlat36 = (-u_xlat36) + _Glossiness;
    u_xlat36 = u_xlat36 + 1.0;
    u_xlat36 = clamp(u_xlat36, 0.0, 1.0);
    u_xlat3.xyw = vec3(u_xlat26) * _LightColor0.xyz;
    u_xlat3.xyw = u_xlat5.xyz * vec3(u_xlat38) + u_xlat3.xyw;
    u_xlat5.xyz = vec3(u_xlat37) * _LightColor0.xyz;
    u_xlat37 = (-u_xlat14.x) + 1.0;
    u_xlat14.x = u_xlat37 * u_xlat37;
    u_xlat14.x = u_xlat14.x * u_xlat14.x;
    u_xlat37 = u_xlat37 * u_xlat14.x;
    u_xlat14.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat14.xyz = u_xlat14.xyz * vec3(u_xlat37) + u_xlat0.xyz;
    u_xlat14.xyz = u_xlat14.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xyw + u_xlat14.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xyw = (-u_xlat0.xyz) + vec3(u_xlat36);
    u_xlat0.xyz = vec3(u_xlat27) * u_xlat3.xyw + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (418 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 192
  Matrix4x4 unity_ObjectToWorld at 256
  Matrix4x4 unity_WorldToObject at 320
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  Vector4 unity_4LightPosX0 at 32
  Vector4 unity_4LightPosY0 at 48
  Vector4 unity_4LightPosZ0 at 64
  VectorHalf4 unity_4LightAtten0 at 80
  VectorHalf4 unity_LightColor[8] at 88
  VectorHalf4 unity_SHBr at 152
  VectorHalf4 unity_SHBg at 160
  VectorHalf4 unity_SHBb at 168
  VectorHalf4 unity_SHC at 176
  Vector4 _MainTex_ST at 384
  Vector4 _DetailAlbedoMap_ST at 400
  ScalarHalf _UVSec at 416
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float3 u_xlat2;
    half4 u_xlat16_2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    float u_xlat25;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD4.w = 0.0;
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat25 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat25 = rsqrt(u_xlat25);
    u_xlat2.xyz = float3(u_xlat25) * u_xlat2.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat2.xyz);
    u_xlat3 = (-u_xlat1.yyyy) + Globals.unity_4LightPosY0;
    u_xlat4 = u_xlat2.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat5 = (-u_xlat1.xxxx) + Globals.unity_4LightPosX0;
    u_xlat4 = u_xlat5 * u_xlat2.xxxx + u_xlat4;
    u_xlat3 = u_xlat5 * u_xlat5 + u_xlat3;
    u_xlat5 = (-u_xlat1.zzzz) + Globals.unity_4LightPosZ0;
    output.TEXCOORD8.xyz = u_xlat1.xyz;
    u_xlat1 = u_xlat5 * u_xlat2.zzzz + u_xlat4;
    u_xlat3 = u_xlat5 * u_xlat5 + u_xlat3;
    u_xlat3 = max(u_xlat3, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = rsqrt(u_xlat3);
    u_xlat3 = u_xlat3 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat3 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat3;
    u_xlat1 = u_xlat1 * u_xlat4;
    u_xlat1 = max(u_xlat1, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat3 * u_xlat1;
    u_xlat3.xyz = u_xlat1.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat3.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat1.zzz + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat1.www + u_xlat1.xyz;
    u_xlat3.xyz = u_xlat1.xyz * float3(0.305306017, 0.305306017, 0.305306017) + float3(0.682171106, 0.682171106, 0.682171106);
    u_xlat3.xyz = u_xlat1.xyz * u_xlat3.xyz + float3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat16_6.x = half(u_xlat2.y * u_xlat2.y);
    u_xlat16_6.x = half(u_xlat2.x * u_xlat2.x + (-float(u_xlat16_6.x)));
    u_xlat16_2 = half4(u_xlat2.yzzx * u_xlat2.xyzz);
    u_xlat16_7.x = dot(Globals.unity_SHBr, u_xlat16_2);
    u_xlat16_7.y = dot(Globals.unity_SHBg, u_xlat16_2);
    u_xlat16_7.z = dot(Globals.unity_SHBb, u_xlat16_2);
    u_xlat16_6.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_6.xxx + u_xlat16_7.xyz);
    output.TEXCOORD5.xyz = half3(u_xlat1.xyz * u_xlat3.xyz + float3(u_xlat16_6.xyz));
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat5;
float u_xlat19;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD4.w = 0.0;
    u_xlat2.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat19 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat19 = inversesqrt(u_xlat19);
    u_xlat2.xyz = vec3(u_xlat19) * u_xlat2.xyz;
    vs_TEXCOORD4.xyz = u_xlat2.xyz;
    u_xlat3 = (-u_xlat1.yyyy) + unity_4LightPosY0;
    u_xlat4 = u_xlat2.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat5 = (-u_xlat1.xxxx) + unity_4LightPosX0;
    u_xlat4 = u_xlat5 * u_xlat2.xxxx + u_xlat4;
    u_xlat3 = u_xlat5 * u_xlat5 + u_xlat3;
    u_xlat5 = (-u_xlat1.zzzz) + unity_4LightPosZ0;
    vs_TEXCOORD8.xyz = u_xlat1.xyz;
    u_xlat1 = u_xlat5 * u_xlat2.zzzz + u_xlat4;
    u_xlat3 = u_xlat5 * u_xlat5 + u_xlat3;
    u_xlat3 = max(u_xlat3, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = inversesqrt(u_xlat3);
    u_xlat3 = u_xlat3 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat3 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat3;
    u_xlat1 = u_xlat1 * u_xlat4;
    u_xlat1 = max(u_xlat1, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat3 * u_xlat1;
    u_xlat3.xyz = u_xlat1.yyy * unity_LightColor[1].xyz;
    u_xlat3.xyz = unity_LightColor[0].xyz * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat1.xyz = unity_LightColor[2].xyz * u_xlat1.zzz + u_xlat3.xyz;
    u_xlat1.xyz = unity_LightColor[3].xyz * u_xlat1.www + u_xlat1.xyz;
    u_xlat3.xyz = u_xlat1.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat3.xyz = u_xlat1.xyz * u_xlat3.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat19 = u_xlat2.y * u_xlat2.y;
    u_xlat19 = u_xlat2.x * u_xlat2.x + (-u_xlat19);
    u_xlat2 = u_xlat2.yzzx * u_xlat2.xyzz;
    u_xlat4.x = dot(unity_SHBr, u_xlat2);
    u_xlat4.y = dot(unity_SHBg, u_xlat2);
    u_xlat4.z = dot(unity_SHBb, u_xlat2);
    u_xlat2.xyz = unity_SHC.xyz * vec3(u_xlat19) + u_xlat4.xyz;
    vs_TEXCOORD5.xyz = u_xlat1.xyz * u_xlat3.xyz + u_xlat2.xyz;
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
lowp vec4 u_xlat10_5;
vec4 u_xlat6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
lowp vec4 u_xlat10_7;
vec3 u_xlat8;
lowp vec4 u_xlat10_8;
vec3 u_xlat9;
lowp vec4 u_xlat10_9;
vec3 u_xlat10;
bvec3 u_xlatb10;
vec3 u_xlat11;
bvec3 u_xlatb12;
vec3 u_xlat15;
float u_xlat16;
float u_xlat17;
float u_xlat19;
float u_xlat28;
float u_xlat29;
float u_xlat30;
float u_xlat39;
float u_xlat40;
float u_xlat41;
bool u_xlatb41;
float u_xlat42;
float u_xlat44;
bool u_xlatb44;
float u_xlat45;
bool u_xlatb45;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat39 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat39) * u_xlat1.xyz;
    u_xlat40 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat2.xyz = vec3(u_xlat40) * vs_TEXCOORD4.xyz;
    u_xlat40 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat3.xyz = vec3(u_xlat40) * vs_TEXCOORD1.xyz;
    u_xlat4.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_4 = texture(_ShadowMapTexture, u_xlat4.xy);
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat42 = (-_OcclusionStrength) + 1.0;
    u_xlat42 = u_xlat10_5.y * _OcclusionStrength + u_xlat42;
    u_xlat17 = (-_Glossiness) + 1.0;
    u_xlat30 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat30 = u_xlat30 + u_xlat30;
    u_xlat5.xyz = u_xlat2.xyz * (-vec3(u_xlat30)) + u_xlat3.xyz;
    u_xlat4.xzw = u_xlat10_4.xxx * _LightColor0.xyz;
    u_xlatb44 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb44){
        u_xlatb44 = unity_ProbeVolumeParams.y==1.0;
        u_xlat6.xyz = vs_TEXCOORD8.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat6.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD8.xxx + u_xlat6.xyz;
        u_xlat6.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD8.zzz + u_xlat6.xyz;
        u_xlat6.xyz = u_xlat6.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat6.xyz = (bool(u_xlatb44)) ? u_xlat6.xyz : vs_TEXCOORD8.xyz;
        u_xlat6.xyz = u_xlat6.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat6.yzw = u_xlat6.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat44 = u_xlat6.y * 0.25;
        u_xlat19 = unity_ProbeVolumeParams.z * 0.5;
        u_xlat7.x = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat44 = max(u_xlat44, u_xlat19);
        u_xlat6.x = min(u_xlat7.x, u_xlat44);
        u_xlat10_7 = texture(unity_ProbeVolumeSH, u_xlat6.xzw);
        u_xlat8.xyz = u_xlat6.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat8.xyz);
        u_xlat6.xyz = u_xlat6.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_6 = texture(unity_ProbeVolumeSH, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat7.x = dot(u_xlat10_7, u_xlat2);
        u_xlat7.y = dot(u_xlat10_8, u_xlat2);
        u_xlat7.z = dot(u_xlat10_6, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat7.x = dot(unity_SHAr, u_xlat2);
        u_xlat7.y = dot(unity_SHAg, u_xlat2);
        u_xlat7.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat6.xyz = u_xlat7.xyz + vs_TEXCOORD5.xyz;
    u_xlat6.xyz = max(u_xlat6.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat6.xyz = log2(u_xlat6.xyz);
    u_xlat6.xyz = u_xlat6.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat6.xyz = exp2(u_xlat6.xyz);
    u_xlat6.xyz = u_xlat6.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat6.xyz = max(u_xlat6.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb41 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb41){
        u_xlat41 = dot(u_xlat5.xyz, u_xlat5.xyz);
        u_xlat41 = inversesqrt(u_xlat41);
        u_xlat7.xyz = vec3(u_xlat41) * u_xlat5.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat7.xyz;
        u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat9.xyz = u_xlat9.xyz / u_xlat7.xyz;
        u_xlatb10.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat7.xyzx).xyz;
        u_xlat8.x = (u_xlatb10.x) ? u_xlat8.x : u_xlat9.x;
        u_xlat8.y = (u_xlatb10.y) ? u_xlat8.y : u_xlat9.y;
        u_xlat8.z = (u_xlatb10.z) ? u_xlat8.z : u_xlat9.z;
        u_xlat41 = min(u_xlat8.y, u_xlat8.x);
        u_xlat41 = min(u_xlat8.z, u_xlat41);
        u_xlat8.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat7.xyz = u_xlat7.xyz * vec3(u_xlat41) + u_xlat8.xyz;
    } else {
        u_xlat7.xyz = u_xlat5.xyz;
    //ENDIF
    }
    u_xlat41 = (-u_xlat17) * 0.699999988 + 1.70000005;
    u_xlat41 = u_xlat41 * u_xlat17;
    u_xlat41 = u_xlat41 * 6.0;
    u_xlat10_7 = textureLod(unity_SpecCube0, u_xlat7.xyz, u_xlat41);
    u_xlatb44 = unity_SpecCube0_HDR.w==1.0;
    u_xlat44 = (u_xlatb44) ? u_xlat10_7.w : 1.0;
    u_xlat44 = u_xlat44 * unity_SpecCube0_HDR.x;
    u_xlat8.xyz = u_xlat10_7.xyz * vec3(u_xlat44);
    u_xlatb45 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb45){
        u_xlatb45 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb45){
            u_xlat45 = dot(u_xlat5.xyz, u_xlat5.xyz);
            u_xlat45 = inversesqrt(u_xlat45);
            u_xlat9.xyz = u_xlat5.xyz * vec3(u_xlat45);
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
            u_xlat11.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
            u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
            u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
            u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
            u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
            u_xlat45 = min(u_xlat10.y, u_xlat10.x);
            u_xlat45 = min(u_xlat10.z, u_xlat45);
            u_xlat10.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat5.xyz = u_xlat9.xyz * vec3(u_xlat45) + u_xlat10.xyz;
        //ENDIF
        }
        u_xlat10_9 = textureLod(unity_SpecCube1, u_xlat5.xyz, u_xlat41);
        u_xlatb41 = unity_SpecCube1_HDR.w==1.0;
        u_xlat41 = (u_xlatb41) ? u_xlat10_9.w : 1.0;
        u_xlat41 = u_xlat41 * unity_SpecCube1_HDR.x;
        u_xlat5.xyz = u_xlat10_9.xyz * vec3(u_xlat41);
        u_xlat7.xyz = vec3(u_xlat44) * u_xlat10_7.xyz + (-u_xlat5.xyz);
        u_xlat8.xyz = unity_SpecCube0_BoxMin.www * u_xlat7.xyz + u_xlat5.xyz;
    //ENDIF
    }
    u_xlat5.xyz = vec3(u_xlat42) * u_xlat8.xyz;
    u_xlat7.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat40) + _WorldSpaceLightPos0.xyz;
    u_xlat40 = dot(u_xlat7.xyz, u_xlat7.xyz);
    u_xlat40 = max(u_xlat40, 0.00100000005);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat7.xyz = vec3(u_xlat40) * u_xlat7.xyz;
    u_xlat40 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat41 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat41 = clamp(u_xlat41, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat7.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat15.x = dot(_WorldSpaceLightPos0.xyz, u_xlat7.xyz);
    u_xlat15.x = clamp(u_xlat15.x, 0.0, 1.0);
    u_xlat28 = u_xlat15.x * u_xlat15.x;
    u_xlat28 = dot(vec2(u_xlat28), vec2(u_xlat17));
    u_xlat28 = u_xlat28 + -0.5;
    u_xlat3.x = (-u_xlat41) + 1.0;
    u_xlat16 = u_xlat3.x * u_xlat3.x;
    u_xlat16 = u_xlat16 * u_xlat16;
    u_xlat3.x = u_xlat3.x * u_xlat16;
    u_xlat3.x = u_xlat28 * u_xlat3.x + 1.0;
    u_xlat16 = -abs(u_xlat40) + 1.0;
    u_xlat29 = u_xlat16 * u_xlat16;
    u_xlat29 = u_xlat29 * u_xlat29;
    u_xlat16 = u_xlat16 * u_xlat29;
    u_xlat28 = u_xlat28 * u_xlat16 + 1.0;
    u_xlat28 = u_xlat28 * u_xlat3.x;
    u_xlat28 = u_xlat41 * u_xlat28;
    u_xlat3.x = u_xlat17 * u_xlat17;
    u_xlat29 = (-u_xlat17) * u_xlat17 + 1.0;
    u_xlat44 = abs(u_xlat40) * u_xlat29 + u_xlat3.x;
    u_xlat29 = u_xlat41 * u_xlat29 + u_xlat3.x;
    u_xlat40 = abs(u_xlat40) * u_xlat29;
    u_xlat40 = u_xlat41 * u_xlat44 + u_xlat40;
    u_xlat40 = u_xlat40 + 9.99999975e-06;
    u_xlat40 = 0.5 / u_xlat40;
    u_xlat29 = u_xlat3.x * u_xlat3.x;
    u_xlat44 = u_xlat2.x * u_xlat29 + (-u_xlat2.x);
    u_xlat2.x = u_xlat44 * u_xlat2.x + 1.0;
    u_xlat29 = u_xlat29 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat29 / u_xlat2.x;
    u_xlat40 = u_xlat40 * u_xlat2.x;
    u_xlat40 = u_xlat40 * 3.14159274;
    u_xlat40 = max(u_xlat40, 9.99999975e-05);
    u_xlat40 = sqrt(u_xlat40);
    u_xlat40 = u_xlat41 * u_xlat40;
    u_xlat2.x = u_xlat3.x * u_xlat17;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat41 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb41 = u_xlat41!=0.0;
    u_xlat41 = u_xlatb41 ? 1.0 : float(0.0);
    u_xlat40 = u_xlat40 * u_xlat41;
    u_xlat39 = (-u_xlat39) + _Glossiness;
    u_xlat39 = u_xlat39 + 1.0;
    u_xlat39 = clamp(u_xlat39, 0.0, 1.0);
    u_xlat7.xyz = vec3(u_xlat28) * u_xlat4.xzw;
    u_xlat3.xzw = u_xlat6.xyz * vec3(u_xlat42) + u_xlat7.xyz;
    u_xlat4.xyz = u_xlat4.xzw * vec3(u_xlat40);
    u_xlat40 = (-u_xlat15.x) + 1.0;
    u_xlat15.x = u_xlat40 * u_xlat40;
    u_xlat15.x = u_xlat15.x * u_xlat15.x;
    u_xlat40 = u_xlat40 * u_xlat15.x;
    u_xlat15.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat15.xyz = u_xlat15.xyz * vec3(u_xlat40) + u_xlat0.xyz;
    u_xlat15.xyz = u_xlat15.xyz * u_xlat4.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat15.xyz;
    u_xlat2.xyz = u_xlat5.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat39);
    u_xlat0.xyz = vec3(u_xlat16) * u_xlat3.xzw + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN DIRLIGHTMAP_COMBINED DYNAMICLIGHTMAP_ON VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  Vector4 unity_WorldTransformParams at 224
  Vector4 unity_DynamicLightmapST at 240
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    float2 TEXCOORD2 [[ attribute(4) ]] ;
    half4 TANGENT0 [[ attribute(5) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float3 u_xlat2;
    half3 u_xlat16_3;
    float u_xlat13;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD8.xyz = u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    u_xlat1.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat1.xyz;
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat1.xyz = float3(u_xlat13) * u_xlat1.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat16_3.xyz = half3(u_xlat1.yzx * u_xlat2.zxy);
    u_xlat16_3.xyz = half3(u_xlat2.yzx * u_xlat1.zxy + (-float3(u_xlat16_3.xyz)));
    output.TEXCOORD4.xyz = half3(u_xlat2.xyz);
    u_xlat1.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat1.xxx * float3(u_xlat16_3.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.w = 0.0;
    u_xlat1.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    output.TEXCOORD5.zw = half2(u_xlat1.xy);
    output.TEXCOORD5.xy = half2(0.0, 0.0);
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec3 u_xlat2;
vec3 u_xlat3;
float u_xlat13;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD8.xyz = u_xlat1.xyz;
    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = inversesqrt(u_xlat13);
    u_xlat1.xyz = vec3(u_xlat13) * u_xlat1.xyz;
    vs_TEXCOORD2.xyz = u_xlat1.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat2.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = inversesqrt(u_xlat13);
    u_xlat2.xyz = vec3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.yzx * u_xlat2.zxy;
    u_xlat1.xyz = u_xlat2.yzx * u_xlat1.zxy + (-u_xlat3.xyz);
    vs_TEXCOORD4.xyz = u_xlat2.xyz;
    u_xlat13 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat13) * u_xlat1.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.w = 0.0;
    vs_TEXCOORD5.zw = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    vs_TEXCOORD5.xy = vec2(0.0, 0.0);
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_DynamicLightmap_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_DynamicLightmap;
uniform  sampler2D unity_DynamicDirectionality;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
vec3 u_xlat2;
vec4 u_xlat3;
bool u_xlatb3;
vec3 u_xlat4;
mediump float u_xlat16_4;
lowp vec4 u_xlat10_4;
bool u_xlatb4;
vec3 u_xlat5;
lowp vec4 u_xlat10_5;
vec3 u_xlat6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
mediump vec3 u_xlat16_7;
lowp vec4 u_xlat10_7;
vec3 u_xlat8;
vec3 u_xlat9;
vec3 u_xlat10;
bvec3 u_xlatb10;
vec3 u_xlat11;
bvec3 u_xlatb12;
vec3 u_xlat15;
float u_xlat16;
vec3 u_xlat17;
float u_xlat28;
float u_xlat29;
float u_xlat39;
float u_xlat40;
float u_xlat41;
float u_xlat42;
float u_xlat43;
float u_xlat44;
bool u_xlatb44;
float u_xlat45;
bool u_xlatb45;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat39 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat39) * u_xlat1.xyz;
    u_xlat40 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat2.xyz = vec3(u_xlat40) * vs_TEXCOORD4.xyz;
    u_xlat40 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat3.xyz = vec3(u_xlat40) * vs_TEXCOORD1.xyz;
    u_xlat4.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_4 = texture(_ShadowMapTexture, u_xlat4.xy);
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat41 = (-_OcclusionStrength) + 1.0;
    u_xlat41 = u_xlat10_5.y * _OcclusionStrength + u_xlat41;
    u_xlat42 = (-_Glossiness) + 1.0;
    u_xlat17.x = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat17.x = u_xlat17.x + u_xlat17.x;
    u_xlat17.xyz = u_xlat2.xyz * (-u_xlat17.xxx) + u_xlat3.xyz;
    u_xlat5.xyz = u_xlat10_4.xxx * _LightColor0.xyz;
    u_xlat10_6 = texture(unity_DynamicLightmap, vs_TEXCOORD5.zw);
    u_xlat4.x = u_xlat10_6.w * unity_DynamicLightmap_HDR.x;
    u_xlat6.xyz = u_xlat10_6.xyz * u_xlat4.xxx;
    u_xlat6.xyz = log2(u_xlat6.xyz);
    u_xlat6.xyz = u_xlat6.xyz * unity_DynamicLightmap_HDR.yyy;
    u_xlat6.xyz = exp2(u_xlat6.xyz);
    u_xlat10_7 = texture(unity_DynamicDirectionality, vs_TEXCOORD5.zw);
    u_xlat16_7.xyz = u_xlat10_7.xyz + vec3(-0.5, -0.5, -0.5);
    u_xlat4.x = dot(u_xlat2.xyz, u_xlat16_7.xyz);
    u_xlat4.x = u_xlat4.x + 0.5;
    u_xlat6.xyz = u_xlat4.xxx * u_xlat6.xyz;
    u_xlat16_4 = max(u_xlat10_7.w, 9.99999975e-05);
    u_xlat6.xyz = u_xlat6.xyz / vec3(u_xlat16_4);
    u_xlatb4 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb4){
        u_xlat4.x = dot(u_xlat17.xyz, u_xlat17.xyz);
        u_xlat4.x = inversesqrt(u_xlat4.x);
        u_xlat7.xyz = u_xlat4.xxx * u_xlat17.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat7.xyz;
        u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat9.xyz = u_xlat9.xyz / u_xlat7.xyz;
        u_xlatb10.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat7.xyzx).xyz;
        u_xlat8.x = (u_xlatb10.x) ? u_xlat8.x : u_xlat9.x;
        u_xlat8.y = (u_xlatb10.y) ? u_xlat8.y : u_xlat9.y;
        u_xlat8.z = (u_xlatb10.z) ? u_xlat8.z : u_xlat9.z;
        u_xlat4.x = min(u_xlat8.y, u_xlat8.x);
        u_xlat4.x = min(u_xlat8.z, u_xlat4.x);
        u_xlat8.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat7.xyz = u_xlat7.xyz * u_xlat4.xxx + u_xlat8.xyz;
    } else {
        u_xlat7.xyz = u_xlat17.xyz;
    //ENDIF
    }
    u_xlat4.x = (-u_xlat42) * 0.699999988 + 1.70000005;
    u_xlat4.x = u_xlat42 * u_xlat4.x;
    u_xlat4.x = u_xlat4.x * 6.0;
    u_xlat10_7 = textureLod(unity_SpecCube0, u_xlat7.xyz, u_xlat4.x);
    u_xlatb44 = unity_SpecCube0_HDR.w==1.0;
    u_xlat44 = (u_xlatb44) ? u_xlat10_7.w : 1.0;
    u_xlat44 = u_xlat44 * unity_SpecCube0_HDR.x;
    u_xlat8.xyz = u_xlat10_7.xyz * vec3(u_xlat44);
    u_xlatb45 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb45){
        u_xlatb45 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb45){
            u_xlat45 = dot(u_xlat17.xyz, u_xlat17.xyz);
            u_xlat45 = inversesqrt(u_xlat45);
            u_xlat9.xyz = u_xlat17.xyz * vec3(u_xlat45);
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
            u_xlat11.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
            u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
            u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
            u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
            u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
            u_xlat45 = min(u_xlat10.y, u_xlat10.x);
            u_xlat45 = min(u_xlat10.z, u_xlat45);
            u_xlat10.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat17.xyz = u_xlat9.xyz * vec3(u_xlat45) + u_xlat10.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat17.xyz, u_xlat4.x);
        u_xlatb45 = unity_SpecCube1_HDR.w==1.0;
        u_xlat43 = (u_xlatb45) ? u_xlat10_4.w : 1.0;
        u_xlat43 = u_xlat43 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat43);
        u_xlat7.xyz = vec3(u_xlat44) * u_xlat10_7.xyz + (-u_xlat4.xyz);
        u_xlat8.xyz = unity_SpecCube0_BoxMin.www * u_xlat7.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = vec3(u_xlat41) * u_xlat8.xyz;
    u_xlat7.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat40) + _WorldSpaceLightPos0.xyz;
    u_xlat40 = dot(u_xlat7.xyz, u_xlat7.xyz);
    u_xlat40 = max(u_xlat40, 0.00100000005);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat7.xyz = vec3(u_xlat40) * u_xlat7.xyz;
    u_xlat40 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat3.x = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat3.x = clamp(u_xlat3.x, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat7.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat15.x = dot(_WorldSpaceLightPos0.xyz, u_xlat7.xyz);
    u_xlat15.x = clamp(u_xlat15.x, 0.0, 1.0);
    u_xlat28 = u_xlat15.x * u_xlat15.x;
    u_xlat28 = dot(vec2(u_xlat28), vec2(u_xlat42));
    u_xlat28 = u_xlat28 + -0.5;
    u_xlat16 = (-u_xlat3.x) + 1.0;
    u_xlat29 = u_xlat16 * u_xlat16;
    u_xlat29 = u_xlat29 * u_xlat29;
    u_xlat16 = u_xlat16 * u_xlat29;
    u_xlat16 = u_xlat28 * u_xlat16 + 1.0;
    u_xlat29 = -abs(u_xlat40) + 1.0;
    u_xlat43 = u_xlat29 * u_xlat29;
    u_xlat43 = u_xlat43 * u_xlat43;
    u_xlat29 = u_xlat29 * u_xlat43;
    u_xlat28 = u_xlat28 * u_xlat29 + 1.0;
    u_xlat28 = u_xlat28 * u_xlat16;
    u_xlat28 = u_xlat3.x * u_xlat28;
    u_xlat16 = u_xlat42 * u_xlat42;
    u_xlat43 = (-u_xlat42) * u_xlat42 + 1.0;
    u_xlat44 = abs(u_xlat40) * u_xlat43 + u_xlat16;
    u_xlat43 = u_xlat3.x * u_xlat43 + u_xlat16;
    u_xlat40 = abs(u_xlat40) * u_xlat43;
    u_xlat40 = u_xlat3.x * u_xlat44 + u_xlat40;
    u_xlat40 = u_xlat40 + 9.99999975e-06;
    u_xlat40 = 0.5 / u_xlat40;
    u_xlat43 = u_xlat16 * u_xlat16;
    u_xlat44 = u_xlat2.x * u_xlat43 + (-u_xlat2.x);
    u_xlat2.x = u_xlat44 * u_xlat2.x + 1.0;
    u_xlat43 = u_xlat43 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat43 / u_xlat2.x;
    u_xlat40 = u_xlat40 * u_xlat2.x;
    u_xlat40 = u_xlat40 * 3.14159274;
    u_xlat40 = max(u_xlat40, 9.99999975e-05);
    u_xlat40 = sqrt(u_xlat40);
    u_xlat40 = u_xlat3.x * u_xlat40;
    u_xlat2.x = u_xlat16 * u_xlat42;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat3.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb3 = u_xlat3.x!=0.0;
    u_xlat3.x = u_xlatb3 ? 1.0 : float(0.0);
    u_xlat40 = u_xlat40 * u_xlat3.x;
    u_xlat39 = (-u_xlat39) + _Glossiness;
    u_xlat39 = u_xlat39 + 1.0;
    u_xlat39 = clamp(u_xlat39, 0.0, 1.0);
    u_xlat3.xyw = vec3(u_xlat28) * u_xlat5.xyz;
    u_xlat3.xyw = u_xlat6.xyz * vec3(u_xlat41) + u_xlat3.xyw;
    u_xlat5.xyz = u_xlat5.xyz * vec3(u_xlat40);
    u_xlat40 = (-u_xlat15.x) + 1.0;
    u_xlat15.x = u_xlat40 * u_xlat40;
    u_xlat15.x = u_xlat15.x * u_xlat15.x;
    u_xlat40 = u_xlat40 * u_xlat15.x;
    u_xlat15.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat15.xyz = u_xlat15.xyz * vec3(u_xlat40) + u_xlat0.xyz;
    u_xlat15.xyz = u_xlat15.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xyw + u_xlat15.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xyw = (-u_xlat0.xyz) + vec3(u_xlat39);
    u_xlat0.xyz = vec3(u_xlat29) * u_xlat3.xyw + u_xlat0.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD8.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_2 = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_2 = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_2)));
    u_xlat16_0 = half4(u_xlat0.yzzx * u_xlat0.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_2) + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD8.xyz = u_xlat0.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat6 = u_xlat0.y * u_xlat0.y;
    u_xlat6 = u_xlat0.x * u_xlat0.x + (-u_xlat6);
    u_xlat1 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat0.x = dot(unity_SHBr, u_xlat1);
    u_xlat0.y = dot(unity_SHBg, u_xlat1);
    u_xlat0.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat6) + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec4 u_xlat2;
vec4 u_xlat3;
float u_xlat4;
lowp vec4 u_xlat10_4;
vec4 u_xlat5;
lowp vec4 u_xlat10_5;
bool u_xlatb5;
vec3 u_xlat6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
lowp vec4 u_xlat10_7;
vec3 u_xlat8;
lowp vec4 u_xlat10_8;
vec3 u_xlat9;
bvec3 u_xlatb9;
vec3 u_xlat10;
bvec3 u_xlatb11;
vec3 u_xlat14;
float u_xlat15;
vec3 u_xlat16;
vec3 u_xlat17;
float u_xlat18;
float u_xlat26;
float u_xlat27;
float u_xlat36;
float u_xlat37;
float u_xlat38;
bool u_xlatb38;
float u_xlat39;
float u_xlat41;
bool u_xlatb41;
float u_xlat42;
bool u_xlatb42;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat36 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat36) * u_xlat1.xyz;
    u_xlat37 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat2.xyz = vec3(u_xlat37) * vs_TEXCOORD4.xyz;
    u_xlat37 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat3.xyz = vec3(u_xlat37) * vs_TEXCOORD1.xyz;
    u_xlat10_4 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat39 = (-_OcclusionStrength) + 1.0;
    u_xlat39 = u_xlat10_4.y * _OcclusionStrength + u_xlat39;
    u_xlat4 = (-_Glossiness) + 1.0;
    u_xlat16.x = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat16.x = u_xlat16.x + u_xlat16.x;
    u_xlat16.xyz = u_xlat2.xyz * (-u_xlat16.xxx) + u_xlat3.xyz;
    u_xlatb5 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb5){
        u_xlatb5 = unity_ProbeVolumeParams.y==1.0;
        u_xlat17.xyz = vs_TEXCOORD8.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat17.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD8.xxx + u_xlat17.xyz;
        u_xlat17.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD8.zzz + u_xlat17.xyz;
        u_xlat17.xyz = u_xlat17.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb5)) ? u_xlat17.xyz : vs_TEXCOORD8.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat17.x = u_xlat5.y * 0.25;
        u_xlat6.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat18 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat17.x = max(u_xlat17.x, u_xlat6.x);
        u_xlat5.x = min(u_xlat18, u_xlat17.x);
        u_xlat10_6 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
        u_xlat7.xyz = u_xlat5.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_7 = texture(unity_ProbeVolumeSH, u_xlat7.xyz);
        u_xlat5.xyz = u_xlat5.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_5 = texture(unity_ProbeVolumeSH, u_xlat5.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat10_6, u_xlat2);
        u_xlat6.y = dot(u_xlat10_7, u_xlat2);
        u_xlat6.z = dot(u_xlat10_5, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(unity_SHAr, u_xlat2);
        u_xlat6.y = dot(unity_SHAg, u_xlat2);
        u_xlat6.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat5.xyz = u_xlat6.xyz + vs_TEXCOORD5.xyz;
    u_xlat5.xyz = max(u_xlat5.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat5.xyz = log2(u_xlat5.xyz);
    u_xlat5.xyz = u_xlat5.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat5.xyz = exp2(u_xlat5.xyz);
    u_xlat5.xyz = u_xlat5.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat5.xyz = max(u_xlat5.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb38 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb38){
        u_xlat38 = dot(u_xlat16.xyz, u_xlat16.xyz);
        u_xlat38 = inversesqrt(u_xlat38);
        u_xlat6.xyz = vec3(u_xlat38) * u_xlat16.xyz;
        u_xlat7.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat7.xyz = u_xlat7.xyz / u_xlat6.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat6.xyz;
        u_xlatb9.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat6.xyzx).xyz;
        u_xlat7.x = (u_xlatb9.x) ? u_xlat7.x : u_xlat8.x;
        u_xlat7.y = (u_xlatb9.y) ? u_xlat7.y : u_xlat8.y;
        u_xlat7.z = (u_xlatb9.z) ? u_xlat7.z : u_xlat8.z;
        u_xlat38 = min(u_xlat7.y, u_xlat7.x);
        u_xlat38 = min(u_xlat7.z, u_xlat38);
        u_xlat7.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat6.xyz = u_xlat6.xyz * vec3(u_xlat38) + u_xlat7.xyz;
    } else {
        u_xlat6.xyz = u_xlat16.xyz;
    //ENDIF
    }
    u_xlat38 = (-u_xlat4) * 0.699999988 + 1.70000005;
    u_xlat38 = u_xlat38 * u_xlat4;
    u_xlat38 = u_xlat38 * 6.0;
    u_xlat10_6 = textureLod(unity_SpecCube0, u_xlat6.xyz, u_xlat38);
    u_xlatb41 = unity_SpecCube0_HDR.w==1.0;
    u_xlat41 = (u_xlatb41) ? u_xlat10_6.w : 1.0;
    u_xlat41 = u_xlat41 * unity_SpecCube0_HDR.x;
    u_xlat7.xyz = u_xlat10_6.xyz * vec3(u_xlat41);
    u_xlatb42 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb42){
        u_xlatb42 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb42){
            u_xlat42 = dot(u_xlat16.xyz, u_xlat16.xyz);
            u_xlat42 = inversesqrt(u_xlat42);
            u_xlat8.xyz = u_xlat16.xyz * vec3(u_xlat42);
            u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat9.xyz = u_xlat9.xyz / u_xlat8.xyz;
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat8.xyz;
            u_xlatb11.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat8.xyzx).xyz;
            u_xlat9.x = (u_xlatb11.x) ? u_xlat9.x : u_xlat10.x;
            u_xlat9.y = (u_xlatb11.y) ? u_xlat9.y : u_xlat10.y;
            u_xlat9.z = (u_xlatb11.z) ? u_xlat9.z : u_xlat10.z;
            u_xlat42 = min(u_xlat9.y, u_xlat9.x);
            u_xlat42 = min(u_xlat9.z, u_xlat42);
            u_xlat9.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat16.xyz = u_xlat8.xyz * vec3(u_xlat42) + u_xlat9.xyz;
        //ENDIF
        }
        u_xlat10_8 = textureLod(unity_SpecCube1, u_xlat16.xyz, u_xlat38);
        u_xlatb38 = unity_SpecCube1_HDR.w==1.0;
        u_xlat38 = (u_xlatb38) ? u_xlat10_8.w : 1.0;
        u_xlat38 = u_xlat38 * unity_SpecCube1_HDR.x;
        u_xlat16.xyz = u_xlat10_8.xyz * vec3(u_xlat38);
        u_xlat6.xyz = vec3(u_xlat41) * u_xlat10_6.xyz + (-u_xlat16.xyz);
        u_xlat7.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat16.xyz;
    //ENDIF
    }
    u_xlat16.xyz = vec3(u_xlat39) * u_xlat7.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat37) + _WorldSpaceLightPos0.xyz;
    u_xlat37 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat37 = max(u_xlat37, 0.00100000005);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat6.xyz = vec3(u_xlat37) * u_xlat6.xyz;
    u_xlat37 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat38 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat38 = clamp(u_xlat38, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat14.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat14.x = clamp(u_xlat14.x, 0.0, 1.0);
    u_xlat26 = u_xlat14.x * u_xlat14.x;
    u_xlat26 = dot(vec2(u_xlat26), vec2(u_xlat4));
    u_xlat26 = u_xlat26 + -0.5;
    u_xlat3.x = (-u_xlat38) + 1.0;
    u_xlat15 = u_xlat3.x * u_xlat3.x;
    u_xlat15 = u_xlat15 * u_xlat15;
    u_xlat3.x = u_xlat3.x * u_xlat15;
    u_xlat3.x = u_xlat26 * u_xlat3.x + 1.0;
    u_xlat15 = -abs(u_xlat37) + 1.0;
    u_xlat27 = u_xlat15 * u_xlat15;
    u_xlat27 = u_xlat27 * u_xlat27;
    u_xlat15 = u_xlat15 * u_xlat27;
    u_xlat26 = u_xlat26 * u_xlat15 + 1.0;
    u_xlat26 = u_xlat26 * u_xlat3.x;
    u_xlat26 = u_xlat38 * u_xlat26;
    u_xlat3.x = u_xlat4 * u_xlat4;
    u_xlat27 = (-u_xlat4) * u_xlat4 + 1.0;
    u_xlat41 = abs(u_xlat37) * u_xlat27 + u_xlat3.x;
    u_xlat27 = u_xlat38 * u_xlat27 + u_xlat3.x;
    u_xlat37 = abs(u_xlat37) * u_xlat27;
    u_xlat37 = u_xlat38 * u_xlat41 + u_xlat37;
    u_xlat37 = u_xlat37 + 9.99999975e-06;
    u_xlat37 = 0.5 / u_xlat37;
    u_xlat27 = u_xlat3.x * u_xlat3.x;
    u_xlat41 = u_xlat2.x * u_xlat27 + (-u_xlat2.x);
    u_xlat2.x = u_xlat41 * u_xlat2.x + 1.0;
    u_xlat27 = u_xlat27 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat27 / u_xlat2.x;
    u_xlat37 = u_xlat37 * u_xlat2.x;
    u_xlat37 = u_xlat37 * 3.14159274;
    u_xlat37 = max(u_xlat37, 9.99999975e-05);
    u_xlat37 = sqrt(u_xlat37);
    u_xlat37 = u_xlat38 * u_xlat37;
    u_xlat2.x = u_xlat3.x * u_xlat4;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat38 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb38 = u_xlat38!=0.0;
    u_xlat38 = u_xlatb38 ? 1.0 : float(0.0);
    u_xlat37 = u_xlat37 * u_xlat38;
    u_xlat36 = (-u_xlat36) + _Glossiness;
    u_xlat36 = u_xlat36 + 1.0;
    u_xlat36 = clamp(u_xlat36, 0.0, 1.0);
    u_xlat6.xyz = vec3(u_xlat26) * _LightColor0.xyz;
    u_xlat3.xzw = u_xlat5.xyz * vec3(u_xlat39) + u_xlat6.xyz;
    u_xlat5.xyz = vec3(u_xlat37) * _LightColor0.xyz;
    u_xlat37 = (-u_xlat14.x) + 1.0;
    u_xlat14.x = u_xlat37 * u_xlat37;
    u_xlat14.x = u_xlat14.x * u_xlat14.x;
    u_xlat37 = u_xlat37 * u_xlat14.x;
    u_xlat14.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat14.xyz = u_xlat14.xyz * vec3(u_xlat37) + u_xlat0.xyz;
    u_xlat14.xyz = u_xlat14.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat14.xyz;
    u_xlat2.xyz = u_xlat16.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat36);
    u_xlat0.xyz = vec3(u_xlat15) * u_xlat3.xzw + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL DIRLIGHTMAP_COMBINED DYNAMICLIGHTMAP_ON _EMISSION 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 16
  Matrix4x4 unity_ObjectToWorld at 80
  Matrix4x4 unity_WorldToObject at 144
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_WorldTransformParams at 208
  Vector4 unity_DynamicLightmapST at 224
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    float2 TEXCOORD2 [[ attribute(4) ]] ;
    half4 TANGENT0 [[ attribute(5) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    float u_xlat9;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD8.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat1.xyz = float3(u_xlat9) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.w = 0.0;
    u_xlat0.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    output.TEXCOORD5.zw = half2(u_xlat0.xy);
    output.TEXCOORD5.xy = half2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD8.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.w = 0.0;
    vs_TEXCOORD5.zw = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    vs_TEXCOORD5.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_DynamicLightmap_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  sampler2D unity_DynamicLightmap;
uniform  sampler2D unity_DynamicDirectionality;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
vec4 u_xlat3;
bool u_xlatb3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
lowp vec4 u_xlat10_5;
vec3 u_xlat6;
mediump vec3 u_xlat16_6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
vec3 u_xlat8;
vec3 u_xlat9;
bvec3 u_xlatb9;
vec3 u_xlat10;
bvec3 u_xlatb11;
vec3 u_xlat14;
float u_xlat15;
float u_xlat26;
float u_xlat27;
float u_xlat36;
float u_xlat37;
float u_xlat38;
float u_xlat39;
float u_xlat40;
mediump float u_xlat16_40;
bool u_xlatb40;
float u_xlat41;
bool u_xlatb41;
float u_xlat42;
bool u_xlatb42;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat36 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat36) * u_xlat1.xyz;
    u_xlat37 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat2.xyz = vec3(u_xlat37) * vs_TEXCOORD4.xyz;
    u_xlat37 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat3.xyz = vec3(u_xlat37) * vs_TEXCOORD1.xyz;
    u_xlat10_4 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat38 = (-_OcclusionStrength) + 1.0;
    u_xlat38 = u_xlat10_4.y * _OcclusionStrength + u_xlat38;
    u_xlat39 = (-_Glossiness) + 1.0;
    u_xlat4.x = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat4.x = u_xlat4.x + u_xlat4.x;
    u_xlat4.xyz = u_xlat2.xyz * (-u_xlat4.xxx) + u_xlat3.xyz;
    u_xlat10_5 = texture(unity_DynamicLightmap, vs_TEXCOORD5.zw);
    u_xlat40 = u_xlat10_5.w * unity_DynamicLightmap_HDR.x;
    u_xlat5.xyz = u_xlat10_5.xyz * vec3(u_xlat40);
    u_xlat5.xyz = log2(u_xlat5.xyz);
    u_xlat5.xyz = u_xlat5.xyz * unity_DynamicLightmap_HDR.yyy;
    u_xlat5.xyz = exp2(u_xlat5.xyz);
    u_xlat10_6 = texture(unity_DynamicDirectionality, vs_TEXCOORD5.zw);
    u_xlat16_6.xyz = u_xlat10_6.xyz + vec3(-0.5, -0.5, -0.5);
    u_xlat40 = dot(u_xlat2.xyz, u_xlat16_6.xyz);
    u_xlat40 = u_xlat40 + 0.5;
    u_xlat5.xyz = vec3(u_xlat40) * u_xlat5.xyz;
    u_xlat16_40 = max(u_xlat10_6.w, 9.99999975e-05);
    u_xlat5.xyz = u_xlat5.xyz / vec3(u_xlat16_40);
    u_xlatb40 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb40){
        u_xlat40 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat40 = inversesqrt(u_xlat40);
        u_xlat6.xyz = vec3(u_xlat40) * u_xlat4.xyz;
        u_xlat7.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat7.xyz = u_xlat7.xyz / u_xlat6.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat6.xyz;
        u_xlatb9.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat6.xyzx).xyz;
        u_xlat7.x = (u_xlatb9.x) ? u_xlat7.x : u_xlat8.x;
        u_xlat7.y = (u_xlatb9.y) ? u_xlat7.y : u_xlat8.y;
        u_xlat7.z = (u_xlatb9.z) ? u_xlat7.z : u_xlat8.z;
        u_xlat40 = min(u_xlat7.y, u_xlat7.x);
        u_xlat40 = min(u_xlat7.z, u_xlat40);
        u_xlat7.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat6.xyz = u_xlat6.xyz * vec3(u_xlat40) + u_xlat7.xyz;
    } else {
        u_xlat6.xyz = u_xlat4.xyz;
    //ENDIF
    }
    u_xlat40 = (-u_xlat39) * 0.699999988 + 1.70000005;
    u_xlat40 = u_xlat39 * u_xlat40;
    u_xlat40 = u_xlat40 * 6.0;
    u_xlat10_6 = textureLod(unity_SpecCube0, u_xlat6.xyz, u_xlat40);
    u_xlatb41 = unity_SpecCube0_HDR.w==1.0;
    u_xlat41 = (u_xlatb41) ? u_xlat10_6.w : 1.0;
    u_xlat41 = u_xlat41 * unity_SpecCube0_HDR.x;
    u_xlat7.xyz = u_xlat10_6.xyz * vec3(u_xlat41);
    u_xlatb42 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb42){
        u_xlatb42 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb42){
            u_xlat42 = dot(u_xlat4.xyz, u_xlat4.xyz);
            u_xlat42 = inversesqrt(u_xlat42);
            u_xlat8.xyz = u_xlat4.xyz * vec3(u_xlat42);
            u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat9.xyz = u_xlat9.xyz / u_xlat8.xyz;
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat8.xyz;
            u_xlatb11.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat8.xyzx).xyz;
            u_xlat9.x = (u_xlatb11.x) ? u_xlat9.x : u_xlat10.x;
            u_xlat9.y = (u_xlatb11.y) ? u_xlat9.y : u_xlat10.y;
            u_xlat9.z = (u_xlatb11.z) ? u_xlat9.z : u_xlat10.z;
            u_xlat42 = min(u_xlat9.y, u_xlat9.x);
            u_xlat42 = min(u_xlat9.z, u_xlat42);
            u_xlat9.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat4.xyz = u_xlat8.xyz * vec3(u_xlat42) + u_xlat9.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat4.xyz, u_xlat40);
        u_xlatb42 = unity_SpecCube1_HDR.w==1.0;
        u_xlat40 = (u_xlatb42) ? u_xlat10_4.w : 1.0;
        u_xlat40 = u_xlat40 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat40);
        u_xlat6.xyz = vec3(u_xlat41) * u_xlat10_6.xyz + (-u_xlat4.xyz);
        u_xlat7.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = vec3(u_xlat38) * u_xlat7.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat37) + _WorldSpaceLightPos0.xyz;
    u_xlat37 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat37 = max(u_xlat37, 0.00100000005);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat6.xyz = vec3(u_xlat37) * u_xlat6.xyz;
    u_xlat37 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat3.x = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat3.x = clamp(u_xlat3.x, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat14.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat14.x = clamp(u_xlat14.x, 0.0, 1.0);
    u_xlat26 = u_xlat14.x * u_xlat14.x;
    u_xlat26 = dot(vec2(u_xlat26), vec2(u_xlat39));
    u_xlat26 = u_xlat26 + -0.5;
    u_xlat15 = (-u_xlat3.x) + 1.0;
    u_xlat27 = u_xlat15 * u_xlat15;
    u_xlat27 = u_xlat27 * u_xlat27;
    u_xlat15 = u_xlat15 * u_xlat27;
    u_xlat15 = u_xlat26 * u_xlat15 + 1.0;
    u_xlat27 = -abs(u_xlat37) + 1.0;
    u_xlat40 = u_xlat27 * u_xlat27;
    u_xlat40 = u_xlat40 * u_xlat40;
    u_xlat27 = u_xlat27 * u_xlat40;
    u_xlat26 = u_xlat26 * u_xlat27 + 1.0;
    u_xlat26 = u_xlat26 * u_xlat15;
    u_xlat26 = u_xlat3.x * u_xlat26;
    u_xlat15 = u_xlat39 * u_xlat39;
    u_xlat40 = (-u_xlat39) * u_xlat39 + 1.0;
    u_xlat41 = abs(u_xlat37) * u_xlat40 + u_xlat15;
    u_xlat40 = u_xlat3.x * u_xlat40 + u_xlat15;
    u_xlat37 = abs(u_xlat37) * u_xlat40;
    u_xlat37 = u_xlat3.x * u_xlat41 + u_xlat37;
    u_xlat37 = u_xlat37 + 9.99999975e-06;
    u_xlat37 = 0.5 / u_xlat37;
    u_xlat40 = u_xlat15 * u_xlat15;
    u_xlat41 = u_xlat2.x * u_xlat40 + (-u_xlat2.x);
    u_xlat2.x = u_xlat41 * u_xlat2.x + 1.0;
    u_xlat40 = u_xlat40 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat40 / u_xlat2.x;
    u_xlat37 = u_xlat37 * u_xlat2.x;
    u_xlat37 = u_xlat37 * 3.14159274;
    u_xlat37 = max(u_xlat37, 9.99999975e-05);
    u_xlat37 = sqrt(u_xlat37);
    u_xlat37 = u_xlat3.x * u_xlat37;
    u_xlat2.x = u_xlat15 * u_xlat39;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat3.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb3 = u_xlat3.x!=0.0;
    u_xlat3.x = u_xlatb3 ? 1.0 : float(0.0);
    u_xlat37 = u_xlat37 * u_xlat3.x;
    u_xlat36 = (-u_xlat36) + _Glossiness;
    u_xlat36 = u_xlat36 + 1.0;
    u_xlat36 = clamp(u_xlat36, 0.0, 1.0);
    u_xlat3.xyw = vec3(u_xlat26) * _LightColor0.xyz;
    u_xlat3.xyw = u_xlat5.xyz * vec3(u_xlat38) + u_xlat3.xyw;
    u_xlat5.xyz = vec3(u_xlat37) * _LightColor0.xyz;
    u_xlat37 = (-u_xlat14.x) + 1.0;
    u_xlat14.x = u_xlat37 * u_xlat37;
    u_xlat14.x = u_xlat14.x * u_xlat14.x;
    u_xlat37 = u_xlat37 * u_xlat14.x;
    u_xlat14.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat14.xyz = u_xlat14.xyz * vec3(u_xlat37) + u_xlat0.xyz;
    u_xlat14.xyz = u_xlat14.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xyw + u_xlat14.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xyw = (-u_xlat0.xyz) + vec3(u_xlat36);
    u_xlat0.xyz = vec3(u_xlat27) * u_xlat3.xyw + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 64
  Matrix4x4 unity_ObjectToWorld at 128
  Matrix4x4 unity_WorldToObject at 192
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 unity_SHBr at 32
  VectorHalf4 unity_SHBg at 40
  VectorHalf4 unity_SHBb at 48
  VectorHalf4 unity_SHC at 56
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float3 u_xlat1;
    half4 u_xlat16_1;
    bool u_xlatb1;
    float4 u_xlat2;
    half u_xlat16_3;
    half3 u_xlat16_4;
    float u_xlat16;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD8.xyz = u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat16 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat1.xyz = float3(u_xlat16) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_3 = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_3 = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_3)));
    u_xlat16_1 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_4.x = dot(Globals.unity_SHBr, u_xlat16_1);
    u_xlat16_4.y = dot(Globals.unity_SHBg, u_xlat16_1);
    u_xlat16_4.z = dot(Globals.unity_SHBb, u_xlat16_1);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_3) + u_xlat16_4.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat2.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat2.zz + u_xlat2.xw;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
float u_xlat10;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD8.xyz = u_xlat1.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = inversesqrt(u_xlat10);
    u_xlat1.xyz = vec3(u_xlat10) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat10 = u_xlat1.y * u_xlat1.y;
    u_xlat10 = u_xlat1.x * u_xlat1.x + (-u_xlat10);
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat1.x = dot(unity_SHBr, u_xlat2);
    u_xlat1.y = dot(unity_SHBg, u_xlat2);
    u_xlat1.z = dot(unity_SHBb, u_xlat2);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat10) + u_xlat1.xyz;
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
lowp vec4 u_xlat10_5;
vec4 u_xlat6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
lowp vec4 u_xlat10_7;
vec3 u_xlat8;
lowp vec4 u_xlat10_8;
vec3 u_xlat9;
lowp vec4 u_xlat10_9;
vec3 u_xlat10;
bvec3 u_xlatb10;
vec3 u_xlat11;
bvec3 u_xlatb12;
vec3 u_xlat15;
float u_xlat16;
float u_xlat17;
float u_xlat19;
float u_xlat28;
float u_xlat29;
float u_xlat30;
float u_xlat39;
float u_xlat40;
float u_xlat41;
bool u_xlatb41;
float u_xlat42;
float u_xlat44;
bool u_xlatb44;
float u_xlat45;
bool u_xlatb45;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat39 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat39) * u_xlat1.xyz;
    u_xlat40 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat2.xyz = vec3(u_xlat40) * vs_TEXCOORD4.xyz;
    u_xlat40 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat3.xyz = vec3(u_xlat40) * vs_TEXCOORD1.xyz;
    u_xlat4.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_4 = texture(_ShadowMapTexture, u_xlat4.xy);
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat42 = (-_OcclusionStrength) + 1.0;
    u_xlat42 = u_xlat10_5.y * _OcclusionStrength + u_xlat42;
    u_xlat17 = (-_Glossiness) + 1.0;
    u_xlat30 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat30 = u_xlat30 + u_xlat30;
    u_xlat5.xyz = u_xlat2.xyz * (-vec3(u_xlat30)) + u_xlat3.xyz;
    u_xlat4.xzw = u_xlat10_4.xxx * _LightColor0.xyz;
    u_xlatb44 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb44){
        u_xlatb44 = unity_ProbeVolumeParams.y==1.0;
        u_xlat6.xyz = vs_TEXCOORD8.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat6.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD8.xxx + u_xlat6.xyz;
        u_xlat6.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD8.zzz + u_xlat6.xyz;
        u_xlat6.xyz = u_xlat6.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat6.xyz = (bool(u_xlatb44)) ? u_xlat6.xyz : vs_TEXCOORD8.xyz;
        u_xlat6.xyz = u_xlat6.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat6.yzw = u_xlat6.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat44 = u_xlat6.y * 0.25;
        u_xlat19 = unity_ProbeVolumeParams.z * 0.5;
        u_xlat7.x = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat44 = max(u_xlat44, u_xlat19);
        u_xlat6.x = min(u_xlat7.x, u_xlat44);
        u_xlat10_7 = texture(unity_ProbeVolumeSH, u_xlat6.xzw);
        u_xlat8.xyz = u_xlat6.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat8.xyz);
        u_xlat6.xyz = u_xlat6.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_6 = texture(unity_ProbeVolumeSH, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat7.x = dot(u_xlat10_7, u_xlat2);
        u_xlat7.y = dot(u_xlat10_8, u_xlat2);
        u_xlat7.z = dot(u_xlat10_6, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat7.x = dot(unity_SHAr, u_xlat2);
        u_xlat7.y = dot(unity_SHAg, u_xlat2);
        u_xlat7.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat6.xyz = u_xlat7.xyz + vs_TEXCOORD5.xyz;
    u_xlat6.xyz = max(u_xlat6.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat6.xyz = log2(u_xlat6.xyz);
    u_xlat6.xyz = u_xlat6.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat6.xyz = exp2(u_xlat6.xyz);
    u_xlat6.xyz = u_xlat6.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat6.xyz = max(u_xlat6.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb41 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb41){
        u_xlat41 = dot(u_xlat5.xyz, u_xlat5.xyz);
        u_xlat41 = inversesqrt(u_xlat41);
        u_xlat7.xyz = vec3(u_xlat41) * u_xlat5.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat7.xyz;
        u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat9.xyz = u_xlat9.xyz / u_xlat7.xyz;
        u_xlatb10.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat7.xyzx).xyz;
        u_xlat8.x = (u_xlatb10.x) ? u_xlat8.x : u_xlat9.x;
        u_xlat8.y = (u_xlatb10.y) ? u_xlat8.y : u_xlat9.y;
        u_xlat8.z = (u_xlatb10.z) ? u_xlat8.z : u_xlat9.z;
        u_xlat41 = min(u_xlat8.y, u_xlat8.x);
        u_xlat41 = min(u_xlat8.z, u_xlat41);
        u_xlat8.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat7.xyz = u_xlat7.xyz * vec3(u_xlat41) + u_xlat8.xyz;
    } else {
        u_xlat7.xyz = u_xlat5.xyz;
    //ENDIF
    }
    u_xlat41 = (-u_xlat17) * 0.699999988 + 1.70000005;
    u_xlat41 = u_xlat41 * u_xlat17;
    u_xlat41 = u_xlat41 * 6.0;
    u_xlat10_7 = textureLod(unity_SpecCube0, u_xlat7.xyz, u_xlat41);
    u_xlatb44 = unity_SpecCube0_HDR.w==1.0;
    u_xlat44 = (u_xlatb44) ? u_xlat10_7.w : 1.0;
    u_xlat44 = u_xlat44 * unity_SpecCube0_HDR.x;
    u_xlat8.xyz = u_xlat10_7.xyz * vec3(u_xlat44);
    u_xlatb45 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb45){
        u_xlatb45 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb45){
            u_xlat45 = dot(u_xlat5.xyz, u_xlat5.xyz);
            u_xlat45 = inversesqrt(u_xlat45);
            u_xlat9.xyz = u_xlat5.xyz * vec3(u_xlat45);
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
            u_xlat11.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
            u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
            u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
            u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
            u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
            u_xlat45 = min(u_xlat10.y, u_xlat10.x);
            u_xlat45 = min(u_xlat10.z, u_xlat45);
            u_xlat10.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat5.xyz = u_xlat9.xyz * vec3(u_xlat45) + u_xlat10.xyz;
        //ENDIF
        }
        u_xlat10_9 = textureLod(unity_SpecCube1, u_xlat5.xyz, u_xlat41);
        u_xlatb41 = unity_SpecCube1_HDR.w==1.0;
        u_xlat41 = (u_xlatb41) ? u_xlat10_9.w : 1.0;
        u_xlat41 = u_xlat41 * unity_SpecCube1_HDR.x;
        u_xlat5.xyz = u_xlat10_9.xyz * vec3(u_xlat41);
        u_xlat7.xyz = vec3(u_xlat44) * u_xlat10_7.xyz + (-u_xlat5.xyz);
        u_xlat8.xyz = unity_SpecCube0_BoxMin.www * u_xlat7.xyz + u_xlat5.xyz;
    //ENDIF
    }
    u_xlat5.xyz = vec3(u_xlat42) * u_xlat8.xyz;
    u_xlat7.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat40) + _WorldSpaceLightPos0.xyz;
    u_xlat40 = dot(u_xlat7.xyz, u_xlat7.xyz);
    u_xlat40 = max(u_xlat40, 0.00100000005);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat7.xyz = vec3(u_xlat40) * u_xlat7.xyz;
    u_xlat40 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat41 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat41 = clamp(u_xlat41, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat7.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat15.x = dot(_WorldSpaceLightPos0.xyz, u_xlat7.xyz);
    u_xlat15.x = clamp(u_xlat15.x, 0.0, 1.0);
    u_xlat28 = u_xlat15.x * u_xlat15.x;
    u_xlat28 = dot(vec2(u_xlat28), vec2(u_xlat17));
    u_xlat28 = u_xlat28 + -0.5;
    u_xlat3.x = (-u_xlat41) + 1.0;
    u_xlat16 = u_xlat3.x * u_xlat3.x;
    u_xlat16 = u_xlat16 * u_xlat16;
    u_xlat3.x = u_xlat3.x * u_xlat16;
    u_xlat3.x = u_xlat28 * u_xlat3.x + 1.0;
    u_xlat16 = -abs(u_xlat40) + 1.0;
    u_xlat29 = u_xlat16 * u_xlat16;
    u_xlat29 = u_xlat29 * u_xlat29;
    u_xlat16 = u_xlat16 * u_xlat29;
    u_xlat28 = u_xlat28 * u_xlat16 + 1.0;
    u_xlat28 = u_xlat28 * u_xlat3.x;
    u_xlat28 = u_xlat41 * u_xlat28;
    u_xlat3.x = u_xlat17 * u_xlat17;
    u_xlat29 = (-u_xlat17) * u_xlat17 + 1.0;
    u_xlat44 = abs(u_xlat40) * u_xlat29 + u_xlat3.x;
    u_xlat29 = u_xlat41 * u_xlat29 + u_xlat3.x;
    u_xlat40 = abs(u_xlat40) * u_xlat29;
    u_xlat40 = u_xlat41 * u_xlat44 + u_xlat40;
    u_xlat40 = u_xlat40 + 9.99999975e-06;
    u_xlat40 = 0.5 / u_xlat40;
    u_xlat29 = u_xlat3.x * u_xlat3.x;
    u_xlat44 = u_xlat2.x * u_xlat29 + (-u_xlat2.x);
    u_xlat2.x = u_xlat44 * u_xlat2.x + 1.0;
    u_xlat29 = u_xlat29 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat29 / u_xlat2.x;
    u_xlat40 = u_xlat40 * u_xlat2.x;
    u_xlat40 = u_xlat40 * 3.14159274;
    u_xlat40 = max(u_xlat40, 9.99999975e-05);
    u_xlat40 = sqrt(u_xlat40);
    u_xlat40 = u_xlat41 * u_xlat40;
    u_xlat2.x = u_xlat3.x * u_xlat17;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat41 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb41 = u_xlat41!=0.0;
    u_xlat41 = u_xlatb41 ? 1.0 : float(0.0);
    u_xlat40 = u_xlat40 * u_xlat41;
    u_xlat39 = (-u_xlat39) + _Glossiness;
    u_xlat39 = u_xlat39 + 1.0;
    u_xlat39 = clamp(u_xlat39, 0.0, 1.0);
    u_xlat7.xyz = vec3(u_xlat28) * u_xlat4.xzw;
    u_xlat3.xzw = u_xlat6.xyz * vec3(u_xlat42) + u_xlat7.xyz;
    u_xlat4.xyz = u_xlat4.xzw * vec3(u_xlat40);
    u_xlat40 = (-u_xlat15.x) + 1.0;
    u_xlat15.x = u_xlat40 * u_xlat40;
    u_xlat15.x = u_xlat15.x * u_xlat15.x;
    u_xlat40 = u_xlat40 * u_xlat15.x;
    u_xlat15.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat15.xyz = u_xlat15.xyz * vec3(u_xlat40) + u_xlat0.xyz;
    u_xlat15.xyz = u_xlat15.xyz * u_xlat4.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat15.xyz;
    u_xlat2.xyz = u_xlat5.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat39);
    u_xlat0.xyz = vec3(u_xlat16) * u_xlat3.xzw + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN DIRLIGHTMAP_COMBINED DYNAMICLIGHTMAP_ON _EMISSION 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  Vector4 unity_WorldTransformParams at 224
  Vector4 unity_DynamicLightmapST at 240
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    float2 TEXCOORD2 [[ attribute(4) ]] ;
    half4 TANGENT0 [[ attribute(5) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float3 u_xlat2;
    half3 u_xlat16_3;
    float u_xlat13;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD8.xyz = u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    u_xlat1.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat1.xyz;
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat1.xyz = float3(u_xlat13) * u_xlat1.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat16_3.xyz = half3(u_xlat1.yzx * u_xlat2.zxy);
    u_xlat16_3.xyz = half3(u_xlat2.yzx * u_xlat1.zxy + (-float3(u_xlat16_3.xyz)));
    output.TEXCOORD4.xyz = half3(u_xlat2.xyz);
    u_xlat1.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat1.xxx * float3(u_xlat16_3.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.w = 0.0;
    u_xlat1.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    output.TEXCOORD5.zw = half2(u_xlat1.xy);
    output.TEXCOORD5.xy = half2(0.0, 0.0);
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec3 u_xlat2;
vec3 u_xlat3;
float u_xlat13;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD8.xyz = u_xlat1.xyz;
    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = inversesqrt(u_xlat13);
    u_xlat1.xyz = vec3(u_xlat13) * u_xlat1.xyz;
    vs_TEXCOORD2.xyz = u_xlat1.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat2.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = inversesqrt(u_xlat13);
    u_xlat2.xyz = vec3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.yzx * u_xlat2.zxy;
    u_xlat1.xyz = u_xlat2.yzx * u_xlat1.zxy + (-u_xlat3.xyz);
    vs_TEXCOORD4.xyz = u_xlat2.xyz;
    u_xlat13 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat13) * u_xlat1.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.w = 0.0;
    vs_TEXCOORD5.zw = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    vs_TEXCOORD5.xy = vec2(0.0, 0.0);
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_DynamicLightmap_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  sampler2D unity_DynamicLightmap;
uniform  sampler2D unity_DynamicDirectionality;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
vec4 u_xlat3;
bool u_xlatb3;
vec3 u_xlat4;
mediump float u_xlat16_4;
lowp vec4 u_xlat10_4;
bool u_xlatb4;
vec3 u_xlat5;
lowp vec4 u_xlat10_5;
vec3 u_xlat6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
mediump vec3 u_xlat16_7;
lowp vec4 u_xlat10_7;
vec3 u_xlat8;
vec3 u_xlat9;
vec3 u_xlat10;
bvec3 u_xlatb10;
vec3 u_xlat11;
bvec3 u_xlatb12;
vec3 u_xlat15;
float u_xlat16;
vec3 u_xlat17;
float u_xlat28;
float u_xlat29;
float u_xlat39;
float u_xlat40;
float u_xlat41;
float u_xlat42;
float u_xlat43;
float u_xlat44;
bool u_xlatb44;
float u_xlat45;
bool u_xlatb45;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat39 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat39) * u_xlat1.xyz;
    u_xlat40 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat2.xyz = vec3(u_xlat40) * vs_TEXCOORD4.xyz;
    u_xlat40 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat3.xyz = vec3(u_xlat40) * vs_TEXCOORD1.xyz;
    u_xlat4.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_4 = texture(_ShadowMapTexture, u_xlat4.xy);
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat41 = (-_OcclusionStrength) + 1.0;
    u_xlat41 = u_xlat10_5.y * _OcclusionStrength + u_xlat41;
    u_xlat42 = (-_Glossiness) + 1.0;
    u_xlat17.x = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat17.x = u_xlat17.x + u_xlat17.x;
    u_xlat17.xyz = u_xlat2.xyz * (-u_xlat17.xxx) + u_xlat3.xyz;
    u_xlat5.xyz = u_xlat10_4.xxx * _LightColor0.xyz;
    u_xlat10_6 = texture(unity_DynamicLightmap, vs_TEXCOORD5.zw);
    u_xlat4.x = u_xlat10_6.w * unity_DynamicLightmap_HDR.x;
    u_xlat6.xyz = u_xlat10_6.xyz * u_xlat4.xxx;
    u_xlat6.xyz = log2(u_xlat6.xyz);
    u_xlat6.xyz = u_xlat6.xyz * unity_DynamicLightmap_HDR.yyy;
    u_xlat6.xyz = exp2(u_xlat6.xyz);
    u_xlat10_7 = texture(unity_DynamicDirectionality, vs_TEXCOORD5.zw);
    u_xlat16_7.xyz = u_xlat10_7.xyz + vec3(-0.5, -0.5, -0.5);
    u_xlat4.x = dot(u_xlat2.xyz, u_xlat16_7.xyz);
    u_xlat4.x = u_xlat4.x + 0.5;
    u_xlat6.xyz = u_xlat4.xxx * u_xlat6.xyz;
    u_xlat16_4 = max(u_xlat10_7.w, 9.99999975e-05);
    u_xlat6.xyz = u_xlat6.xyz / vec3(u_xlat16_4);
    u_xlatb4 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb4){
        u_xlat4.x = dot(u_xlat17.xyz, u_xlat17.xyz);
        u_xlat4.x = inversesqrt(u_xlat4.x);
        u_xlat7.xyz = u_xlat4.xxx * u_xlat17.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat7.xyz;
        u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat9.xyz = u_xlat9.xyz / u_xlat7.xyz;
        u_xlatb10.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat7.xyzx).xyz;
        u_xlat8.x = (u_xlatb10.x) ? u_xlat8.x : u_xlat9.x;
        u_xlat8.y = (u_xlatb10.y) ? u_xlat8.y : u_xlat9.y;
        u_xlat8.z = (u_xlatb10.z) ? u_xlat8.z : u_xlat9.z;
        u_xlat4.x = min(u_xlat8.y, u_xlat8.x);
        u_xlat4.x = min(u_xlat8.z, u_xlat4.x);
        u_xlat8.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat7.xyz = u_xlat7.xyz * u_xlat4.xxx + u_xlat8.xyz;
    } else {
        u_xlat7.xyz = u_xlat17.xyz;
    //ENDIF
    }
    u_xlat4.x = (-u_xlat42) * 0.699999988 + 1.70000005;
    u_xlat4.x = u_xlat42 * u_xlat4.x;
    u_xlat4.x = u_xlat4.x * 6.0;
    u_xlat10_7 = textureLod(unity_SpecCube0, u_xlat7.xyz, u_xlat4.x);
    u_xlatb44 = unity_SpecCube0_HDR.w==1.0;
    u_xlat44 = (u_xlatb44) ? u_xlat10_7.w : 1.0;
    u_xlat44 = u_xlat44 * unity_SpecCube0_HDR.x;
    u_xlat8.xyz = u_xlat10_7.xyz * vec3(u_xlat44);
    u_xlatb45 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb45){
        u_xlatb45 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb45){
            u_xlat45 = dot(u_xlat17.xyz, u_xlat17.xyz);
            u_xlat45 = inversesqrt(u_xlat45);
            u_xlat9.xyz = u_xlat17.xyz * vec3(u_xlat45);
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
            u_xlat11.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
            u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
            u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
            u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
            u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
            u_xlat45 = min(u_xlat10.y, u_xlat10.x);
            u_xlat45 = min(u_xlat10.z, u_xlat45);
            u_xlat10.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat17.xyz = u_xlat9.xyz * vec3(u_xlat45) + u_xlat10.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat17.xyz, u_xlat4.x);
        u_xlatb45 = unity_SpecCube1_HDR.w==1.0;
        u_xlat43 = (u_xlatb45) ? u_xlat10_4.w : 1.0;
        u_xlat43 = u_xlat43 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat43);
        u_xlat7.xyz = vec3(u_xlat44) * u_xlat10_7.xyz + (-u_xlat4.xyz);
        u_xlat8.xyz = unity_SpecCube0_BoxMin.www * u_xlat7.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = vec3(u_xlat41) * u_xlat8.xyz;
    u_xlat7.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat40) + _WorldSpaceLightPos0.xyz;
    u_xlat40 = dot(u_xlat7.xyz, u_xlat7.xyz);
    u_xlat40 = max(u_xlat40, 0.00100000005);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat7.xyz = vec3(u_xlat40) * u_xlat7.xyz;
    u_xlat40 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat3.x = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat3.x = clamp(u_xlat3.x, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat7.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat15.x = dot(_WorldSpaceLightPos0.xyz, u_xlat7.xyz);
    u_xlat15.x = clamp(u_xlat15.x, 0.0, 1.0);
    u_xlat28 = u_xlat15.x * u_xlat15.x;
    u_xlat28 = dot(vec2(u_xlat28), vec2(u_xlat42));
    u_xlat28 = u_xlat28 + -0.5;
    u_xlat16 = (-u_xlat3.x) + 1.0;
    u_xlat29 = u_xlat16 * u_xlat16;
    u_xlat29 = u_xlat29 * u_xlat29;
    u_xlat16 = u_xlat16 * u_xlat29;
    u_xlat16 = u_xlat28 * u_xlat16 + 1.0;
    u_xlat29 = -abs(u_xlat40) + 1.0;
    u_xlat43 = u_xlat29 * u_xlat29;
    u_xlat43 = u_xlat43 * u_xlat43;
    u_xlat29 = u_xlat29 * u_xlat43;
    u_xlat28 = u_xlat28 * u_xlat29 + 1.0;
    u_xlat28 = u_xlat28 * u_xlat16;
    u_xlat28 = u_xlat3.x * u_xlat28;
    u_xlat16 = u_xlat42 * u_xlat42;
    u_xlat43 = (-u_xlat42) * u_xlat42 + 1.0;
    u_xlat44 = abs(u_xlat40) * u_xlat43 + u_xlat16;
    u_xlat43 = u_xlat3.x * u_xlat43 + u_xlat16;
    u_xlat40 = abs(u_xlat40) * u_xlat43;
    u_xlat40 = u_xlat3.x * u_xlat44 + u_xlat40;
    u_xlat40 = u_xlat40 + 9.99999975e-06;
    u_xlat40 = 0.5 / u_xlat40;
    u_xlat43 = u_xlat16 * u_xlat16;
    u_xlat44 = u_xlat2.x * u_xlat43 + (-u_xlat2.x);
    u_xlat2.x = u_xlat44 * u_xlat2.x + 1.0;
    u_xlat43 = u_xlat43 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat43 / u_xlat2.x;
    u_xlat40 = u_xlat40 * u_xlat2.x;
    u_xlat40 = u_xlat40 * 3.14159274;
    u_xlat40 = max(u_xlat40, 9.99999975e-05);
    u_xlat40 = sqrt(u_xlat40);
    u_xlat40 = u_xlat3.x * u_xlat40;
    u_xlat2.x = u_xlat16 * u_xlat42;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat3.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb3 = u_xlat3.x!=0.0;
    u_xlat3.x = u_xlatb3 ? 1.0 : float(0.0);
    u_xlat40 = u_xlat40 * u_xlat3.x;
    u_xlat39 = (-u_xlat39) + _Glossiness;
    u_xlat39 = u_xlat39 + 1.0;
    u_xlat39 = clamp(u_xlat39, 0.0, 1.0);
    u_xlat3.xyw = vec3(u_xlat28) * u_xlat5.xyz;
    u_xlat3.xyw = u_xlat6.xyz * vec3(u_xlat41) + u_xlat3.xyw;
    u_xlat5.xyz = u_xlat5.xyz * vec3(u_xlat40);
    u_xlat40 = (-u_xlat15.x) + 1.0;
    u_xlat15.x = u_xlat40 * u_xlat40;
    u_xlat15.x = u_xlat15.x * u_xlat15.x;
    u_xlat40 = u_xlat40 * u_xlat15.x;
    u_xlat15.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat15.xyz = u_xlat15.xyz * vec3(u_xlat40) + u_xlat0.xyz;
    u_xlat15.xyz = u_xlat15.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xyw + u_xlat15.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xyw = (-u_xlat0.xyz) + vec3(u_xlat39);
    u_xlat0.xyz = vec3(u_xlat29) * u_xlat3.xyw + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL _EMISSION VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (402 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 176
  Matrix4x4 unity_ObjectToWorld at 240
  Matrix4x4 unity_WorldToObject at 304
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_4LightPosX0 at 16
  Vector4 unity_4LightPosY0 at 32
  Vector4 unity_4LightPosZ0 at 48
  VectorHalf4 unity_4LightAtten0 at 64
  VectorHalf4 unity_LightColor[8] at 72
  VectorHalf4 unity_SHBr at 136
  VectorHalf4 unity_SHBg at 144
  VectorHalf4 unity_SHBb at 152
  VectorHalf4 unity_SHC at 160
  Vector4 _MainTex_ST at 368
  Vector4 _DetailAlbedoMap_ST at 384
  ScalarHalf _UVSec at 400
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    half4 u_xlat16_1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    float u_xlat21;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD4.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat21 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    u_xlat2 = (-u_xlat0.yyyy) + Globals.unity_4LightPosY0;
    u_xlat3 = u_xlat1.yyyy * u_xlat2;
    u_xlat2 = u_xlat2 * u_xlat2;
    u_xlat4 = (-u_xlat0.xxxx) + Globals.unity_4LightPosX0;
    u_xlat3 = u_xlat4 * u_xlat1.xxxx + u_xlat3;
    u_xlat2 = u_xlat4 * u_xlat4 + u_xlat2;
    u_xlat4 = (-u_xlat0.zzzz) + Globals.unity_4LightPosZ0;
    output.TEXCOORD8.xyz = u_xlat0.xyz;
    u_xlat0 = u_xlat4 * u_xlat1.zzzz + u_xlat3;
    u_xlat2 = u_xlat4 * u_xlat4 + u_xlat2;
    u_xlat2 = max(u_xlat2, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat3 = rsqrt(u_xlat2);
    u_xlat2 = u_xlat2 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat2 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat2;
    u_xlat0 = u_xlat0 * u_xlat3;
    u_xlat0 = max(u_xlat0, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat2 * u_xlat0;
    u_xlat2.xyz = u_xlat0.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat2.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat0.xxx + u_xlat2.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat0.zzz + u_xlat2.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat0.www + u_xlat0.xyz;
    u_xlat2.xyz = u_xlat0.xyz * float3(0.305306017, 0.305306017, 0.305306017) + float3(0.682171106, 0.682171106, 0.682171106);
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz + float3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat16_5.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_5.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_5.x)));
    u_xlat16_1 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_6.x = dot(Globals.unity_SHBr, u_xlat16_1);
    u_xlat16_6.y = dot(Globals.unity_SHBg, u_xlat16_1);
    u_xlat16_6.z = dot(Globals.unity_SHBb, u_xlat16_1);
    u_xlat16_5.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_5.xxx + u_xlat16_6.xyz);
    output.TEXCOORD5.xyz = half3(u_xlat0.xyz * u_xlat2.xyz + float3(u_xlat16_5.xyz));
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
float u_xlat15;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD4.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = inversesqrt(u_xlat15);
    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat2 = (-u_xlat0.yyyy) + unity_4LightPosY0;
    u_xlat3 = u_xlat1.yyyy * u_xlat2;
    u_xlat2 = u_xlat2 * u_xlat2;
    u_xlat4 = (-u_xlat0.xxxx) + unity_4LightPosX0;
    u_xlat3 = u_xlat4 * u_xlat1.xxxx + u_xlat3;
    u_xlat2 = u_xlat4 * u_xlat4 + u_xlat2;
    u_xlat4 = (-u_xlat0.zzzz) + unity_4LightPosZ0;
    vs_TEXCOORD8.xyz = u_xlat0.xyz;
    u_xlat0 = u_xlat4 * u_xlat1.zzzz + u_xlat3;
    u_xlat2 = u_xlat4 * u_xlat4 + u_xlat2;
    u_xlat2 = max(u_xlat2, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat3 = inversesqrt(u_xlat2);
    u_xlat2 = u_xlat2 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat2 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat2;
    u_xlat0 = u_xlat0 * u_xlat3;
    u_xlat0 = max(u_xlat0, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat2 * u_xlat0;
    u_xlat2.xyz = u_xlat0.yyy * unity_LightColor[1].xyz;
    u_xlat2.xyz = unity_LightColor[0].xyz * u_xlat0.xxx + u_xlat2.xyz;
    u_xlat0.xyz = unity_LightColor[2].xyz * u_xlat0.zzz + u_xlat2.xyz;
    u_xlat0.xyz = unity_LightColor[3].xyz * u_xlat0.www + u_xlat0.xyz;
    u_xlat2.xyz = u_xlat0.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat15 = u_xlat1.y * u_xlat1.y;
    u_xlat15 = u_xlat1.x * u_xlat1.x + (-u_xlat15);
    u_xlat1 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat3.x = dot(unity_SHBr, u_xlat1);
    u_xlat3.y = dot(unity_SHBg, u_xlat1);
    u_xlat3.z = dot(unity_SHBb, u_xlat1);
    u_xlat1.xyz = unity_SHC.xyz * vec3(u_xlat15) + u_xlat3.xyz;
    vs_TEXCOORD5.xyz = u_xlat0.xyz * u_xlat2.xyz + u_xlat1.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec4 u_xlat2;
vec4 u_xlat3;
float u_xlat4;
lowp vec4 u_xlat10_4;
vec4 u_xlat5;
lowp vec4 u_xlat10_5;
bool u_xlatb5;
vec3 u_xlat6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
lowp vec4 u_xlat10_7;
vec3 u_xlat8;
lowp vec4 u_xlat10_8;
vec3 u_xlat9;
bvec3 u_xlatb9;
vec3 u_xlat10;
bvec3 u_xlatb11;
vec3 u_xlat14;
float u_xlat15;
vec3 u_xlat16;
vec3 u_xlat17;
float u_xlat18;
float u_xlat26;
float u_xlat27;
float u_xlat36;
float u_xlat37;
float u_xlat38;
bool u_xlatb38;
float u_xlat39;
float u_xlat41;
bool u_xlatb41;
float u_xlat42;
bool u_xlatb42;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat36 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat36) * u_xlat1.xyz;
    u_xlat37 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat2.xyz = vec3(u_xlat37) * vs_TEXCOORD4.xyz;
    u_xlat37 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat3.xyz = vec3(u_xlat37) * vs_TEXCOORD1.xyz;
    u_xlat10_4 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat39 = (-_OcclusionStrength) + 1.0;
    u_xlat39 = u_xlat10_4.y * _OcclusionStrength + u_xlat39;
    u_xlat4 = (-_Glossiness) + 1.0;
    u_xlat16.x = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat16.x = u_xlat16.x + u_xlat16.x;
    u_xlat16.xyz = u_xlat2.xyz * (-u_xlat16.xxx) + u_xlat3.xyz;
    u_xlatb5 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb5){
        u_xlatb5 = unity_ProbeVolumeParams.y==1.0;
        u_xlat17.xyz = vs_TEXCOORD8.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat17.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD8.xxx + u_xlat17.xyz;
        u_xlat17.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD8.zzz + u_xlat17.xyz;
        u_xlat17.xyz = u_xlat17.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat5.xyz = (bool(u_xlatb5)) ? u_xlat17.xyz : vs_TEXCOORD8.xyz;
        u_xlat5.xyz = u_xlat5.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat5.yzw = u_xlat5.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat17.x = u_xlat5.y * 0.25;
        u_xlat6.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat18 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat17.x = max(u_xlat17.x, u_xlat6.x);
        u_xlat5.x = min(u_xlat18, u_xlat17.x);
        u_xlat10_6 = texture(unity_ProbeVolumeSH, u_xlat5.xzw);
        u_xlat7.xyz = u_xlat5.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_7 = texture(unity_ProbeVolumeSH, u_xlat7.xyz);
        u_xlat5.xyz = u_xlat5.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_5 = texture(unity_ProbeVolumeSH, u_xlat5.xyz);
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(u_xlat10_6, u_xlat2);
        u_xlat6.y = dot(u_xlat10_7, u_xlat2);
        u_xlat6.z = dot(u_xlat10_5, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat6.x = dot(unity_SHAr, u_xlat2);
        u_xlat6.y = dot(unity_SHAg, u_xlat2);
        u_xlat6.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat5.xyz = u_xlat6.xyz + vs_TEXCOORD5.xyz;
    u_xlat5.xyz = max(u_xlat5.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat5.xyz = log2(u_xlat5.xyz);
    u_xlat5.xyz = u_xlat5.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat5.xyz = exp2(u_xlat5.xyz);
    u_xlat5.xyz = u_xlat5.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat5.xyz = max(u_xlat5.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb38 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb38){
        u_xlat38 = dot(u_xlat16.xyz, u_xlat16.xyz);
        u_xlat38 = inversesqrt(u_xlat38);
        u_xlat6.xyz = vec3(u_xlat38) * u_xlat16.xyz;
        u_xlat7.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat7.xyz = u_xlat7.xyz / u_xlat6.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat6.xyz;
        u_xlatb9.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat6.xyzx).xyz;
        u_xlat7.x = (u_xlatb9.x) ? u_xlat7.x : u_xlat8.x;
        u_xlat7.y = (u_xlatb9.y) ? u_xlat7.y : u_xlat8.y;
        u_xlat7.z = (u_xlatb9.z) ? u_xlat7.z : u_xlat8.z;
        u_xlat38 = min(u_xlat7.y, u_xlat7.x);
        u_xlat38 = min(u_xlat7.z, u_xlat38);
        u_xlat7.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat6.xyz = u_xlat6.xyz * vec3(u_xlat38) + u_xlat7.xyz;
    } else {
        u_xlat6.xyz = u_xlat16.xyz;
    //ENDIF
    }
    u_xlat38 = (-u_xlat4) * 0.699999988 + 1.70000005;
    u_xlat38 = u_xlat38 * u_xlat4;
    u_xlat38 = u_xlat38 * 6.0;
    u_xlat10_6 = textureLod(unity_SpecCube0, u_xlat6.xyz, u_xlat38);
    u_xlatb41 = unity_SpecCube0_HDR.w==1.0;
    u_xlat41 = (u_xlatb41) ? u_xlat10_6.w : 1.0;
    u_xlat41 = u_xlat41 * unity_SpecCube0_HDR.x;
    u_xlat7.xyz = u_xlat10_6.xyz * vec3(u_xlat41);
    u_xlatb42 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb42){
        u_xlatb42 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb42){
            u_xlat42 = dot(u_xlat16.xyz, u_xlat16.xyz);
            u_xlat42 = inversesqrt(u_xlat42);
            u_xlat8.xyz = u_xlat16.xyz * vec3(u_xlat42);
            u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat9.xyz = u_xlat9.xyz / u_xlat8.xyz;
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat8.xyz;
            u_xlatb11.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat8.xyzx).xyz;
            u_xlat9.x = (u_xlatb11.x) ? u_xlat9.x : u_xlat10.x;
            u_xlat9.y = (u_xlatb11.y) ? u_xlat9.y : u_xlat10.y;
            u_xlat9.z = (u_xlatb11.z) ? u_xlat9.z : u_xlat10.z;
            u_xlat42 = min(u_xlat9.y, u_xlat9.x);
            u_xlat42 = min(u_xlat9.z, u_xlat42);
            u_xlat9.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat16.xyz = u_xlat8.xyz * vec3(u_xlat42) + u_xlat9.xyz;
        //ENDIF
        }
        u_xlat10_8 = textureLod(unity_SpecCube1, u_xlat16.xyz, u_xlat38);
        u_xlatb38 = unity_SpecCube1_HDR.w==1.0;
        u_xlat38 = (u_xlatb38) ? u_xlat10_8.w : 1.0;
        u_xlat38 = u_xlat38 * unity_SpecCube1_HDR.x;
        u_xlat16.xyz = u_xlat10_8.xyz * vec3(u_xlat38);
        u_xlat6.xyz = vec3(u_xlat41) * u_xlat10_6.xyz + (-u_xlat16.xyz);
        u_xlat7.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat16.xyz;
    //ENDIF
    }
    u_xlat16.xyz = vec3(u_xlat39) * u_xlat7.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat37) + _WorldSpaceLightPos0.xyz;
    u_xlat37 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat37 = max(u_xlat37, 0.00100000005);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat6.xyz = vec3(u_xlat37) * u_xlat6.xyz;
    u_xlat37 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat38 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat38 = clamp(u_xlat38, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat14.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat14.x = clamp(u_xlat14.x, 0.0, 1.0);
    u_xlat26 = u_xlat14.x * u_xlat14.x;
    u_xlat26 = dot(vec2(u_xlat26), vec2(u_xlat4));
    u_xlat26 = u_xlat26 + -0.5;
    u_xlat3.x = (-u_xlat38) + 1.0;
    u_xlat15 = u_xlat3.x * u_xlat3.x;
    u_xlat15 = u_xlat15 * u_xlat15;
    u_xlat3.x = u_xlat3.x * u_xlat15;
    u_xlat3.x = u_xlat26 * u_xlat3.x + 1.0;
    u_xlat15 = -abs(u_xlat37) + 1.0;
    u_xlat27 = u_xlat15 * u_xlat15;
    u_xlat27 = u_xlat27 * u_xlat27;
    u_xlat15 = u_xlat15 * u_xlat27;
    u_xlat26 = u_xlat26 * u_xlat15 + 1.0;
    u_xlat26 = u_xlat26 * u_xlat3.x;
    u_xlat26 = u_xlat38 * u_xlat26;
    u_xlat3.x = u_xlat4 * u_xlat4;
    u_xlat27 = (-u_xlat4) * u_xlat4 + 1.0;
    u_xlat41 = abs(u_xlat37) * u_xlat27 + u_xlat3.x;
    u_xlat27 = u_xlat38 * u_xlat27 + u_xlat3.x;
    u_xlat37 = abs(u_xlat37) * u_xlat27;
    u_xlat37 = u_xlat38 * u_xlat41 + u_xlat37;
    u_xlat37 = u_xlat37 + 9.99999975e-06;
    u_xlat37 = 0.5 / u_xlat37;
    u_xlat27 = u_xlat3.x * u_xlat3.x;
    u_xlat41 = u_xlat2.x * u_xlat27 + (-u_xlat2.x);
    u_xlat2.x = u_xlat41 * u_xlat2.x + 1.0;
    u_xlat27 = u_xlat27 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat27 / u_xlat2.x;
    u_xlat37 = u_xlat37 * u_xlat2.x;
    u_xlat37 = u_xlat37 * 3.14159274;
    u_xlat37 = max(u_xlat37, 9.99999975e-05);
    u_xlat37 = sqrt(u_xlat37);
    u_xlat37 = u_xlat38 * u_xlat37;
    u_xlat2.x = u_xlat3.x * u_xlat4;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat38 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb38 = u_xlat38!=0.0;
    u_xlat38 = u_xlatb38 ? 1.0 : float(0.0);
    u_xlat37 = u_xlat37 * u_xlat38;
    u_xlat36 = (-u_xlat36) + _Glossiness;
    u_xlat36 = u_xlat36 + 1.0;
    u_xlat36 = clamp(u_xlat36, 0.0, 1.0);
    u_xlat6.xyz = vec3(u_xlat26) * _LightColor0.xyz;
    u_xlat3.xzw = u_xlat5.xyz * vec3(u_xlat39) + u_xlat6.xyz;
    u_xlat5.xyz = vec3(u_xlat37) * _LightColor0.xyz;
    u_xlat37 = (-u_xlat14.x) + 1.0;
    u_xlat14.x = u_xlat37 * u_xlat37;
    u_xlat14.x = u_xlat14.x * u_xlat14.x;
    u_xlat37 = u_xlat37 * u_xlat14.x;
    u_xlat14.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat14.xyz = u_xlat14.xyz * vec3(u_xlat37) + u_xlat0.xyz;
    u_xlat14.xyz = u_xlat14.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat14.xyz;
    u_xlat2.xyz = u_xlat16.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat36);
    u_xlat0.xyz = vec3(u_xlat15) * u_xlat3.xzw + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL DIRLIGHTMAP_COMBINED DYNAMICLIGHTMAP_ON _EMISSION VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 16
  Matrix4x4 unity_ObjectToWorld at 80
  Matrix4x4 unity_WorldToObject at 144
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_WorldTransformParams at 208
  Vector4 unity_DynamicLightmapST at 224
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    float2 TEXCOORD2 [[ attribute(4) ]] ;
    half4 TANGENT0 [[ attribute(5) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    float u_xlat9;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD8.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat1.xyz = float3(u_xlat9) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.w = 0.0;
    u_xlat0.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    output.TEXCOORD5.zw = half2(u_xlat0.xy);
    output.TEXCOORD5.xy = half2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD8.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.w = 0.0;
    vs_TEXCOORD5.zw = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    vs_TEXCOORD5.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_DynamicLightmap_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  sampler2D unity_DynamicLightmap;
uniform  sampler2D unity_DynamicDirectionality;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
vec4 u_xlat3;
bool u_xlatb3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
lowp vec4 u_xlat10_5;
vec3 u_xlat6;
mediump vec3 u_xlat16_6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
vec3 u_xlat8;
vec3 u_xlat9;
bvec3 u_xlatb9;
vec3 u_xlat10;
bvec3 u_xlatb11;
vec3 u_xlat14;
float u_xlat15;
float u_xlat26;
float u_xlat27;
float u_xlat36;
float u_xlat37;
float u_xlat38;
float u_xlat39;
float u_xlat40;
mediump float u_xlat16_40;
bool u_xlatb40;
float u_xlat41;
bool u_xlatb41;
float u_xlat42;
bool u_xlatb42;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat36 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat36) * u_xlat1.xyz;
    u_xlat37 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat2.xyz = vec3(u_xlat37) * vs_TEXCOORD4.xyz;
    u_xlat37 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat3.xyz = vec3(u_xlat37) * vs_TEXCOORD1.xyz;
    u_xlat10_4 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat38 = (-_OcclusionStrength) + 1.0;
    u_xlat38 = u_xlat10_4.y * _OcclusionStrength + u_xlat38;
    u_xlat39 = (-_Glossiness) + 1.0;
    u_xlat4.x = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat4.x = u_xlat4.x + u_xlat4.x;
    u_xlat4.xyz = u_xlat2.xyz * (-u_xlat4.xxx) + u_xlat3.xyz;
    u_xlat10_5 = texture(unity_DynamicLightmap, vs_TEXCOORD5.zw);
    u_xlat40 = u_xlat10_5.w * unity_DynamicLightmap_HDR.x;
    u_xlat5.xyz = u_xlat10_5.xyz * vec3(u_xlat40);
    u_xlat5.xyz = log2(u_xlat5.xyz);
    u_xlat5.xyz = u_xlat5.xyz * unity_DynamicLightmap_HDR.yyy;
    u_xlat5.xyz = exp2(u_xlat5.xyz);
    u_xlat10_6 = texture(unity_DynamicDirectionality, vs_TEXCOORD5.zw);
    u_xlat16_6.xyz = u_xlat10_6.xyz + vec3(-0.5, -0.5, -0.5);
    u_xlat40 = dot(u_xlat2.xyz, u_xlat16_6.xyz);
    u_xlat40 = u_xlat40 + 0.5;
    u_xlat5.xyz = vec3(u_xlat40) * u_xlat5.xyz;
    u_xlat16_40 = max(u_xlat10_6.w, 9.99999975e-05);
    u_xlat5.xyz = u_xlat5.xyz / vec3(u_xlat16_40);
    u_xlatb40 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb40){
        u_xlat40 = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat40 = inversesqrt(u_xlat40);
        u_xlat6.xyz = vec3(u_xlat40) * u_xlat4.xyz;
        u_xlat7.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat7.xyz = u_xlat7.xyz / u_xlat6.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat6.xyz;
        u_xlatb9.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat6.xyzx).xyz;
        u_xlat7.x = (u_xlatb9.x) ? u_xlat7.x : u_xlat8.x;
        u_xlat7.y = (u_xlatb9.y) ? u_xlat7.y : u_xlat8.y;
        u_xlat7.z = (u_xlatb9.z) ? u_xlat7.z : u_xlat8.z;
        u_xlat40 = min(u_xlat7.y, u_xlat7.x);
        u_xlat40 = min(u_xlat7.z, u_xlat40);
        u_xlat7.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat6.xyz = u_xlat6.xyz * vec3(u_xlat40) + u_xlat7.xyz;
    } else {
        u_xlat6.xyz = u_xlat4.xyz;
    //ENDIF
    }
    u_xlat40 = (-u_xlat39) * 0.699999988 + 1.70000005;
    u_xlat40 = u_xlat39 * u_xlat40;
    u_xlat40 = u_xlat40 * 6.0;
    u_xlat10_6 = textureLod(unity_SpecCube0, u_xlat6.xyz, u_xlat40);
    u_xlatb41 = unity_SpecCube0_HDR.w==1.0;
    u_xlat41 = (u_xlatb41) ? u_xlat10_6.w : 1.0;
    u_xlat41 = u_xlat41 * unity_SpecCube0_HDR.x;
    u_xlat7.xyz = u_xlat10_6.xyz * vec3(u_xlat41);
    u_xlatb42 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb42){
        u_xlatb42 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb42){
            u_xlat42 = dot(u_xlat4.xyz, u_xlat4.xyz);
            u_xlat42 = inversesqrt(u_xlat42);
            u_xlat8.xyz = u_xlat4.xyz * vec3(u_xlat42);
            u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat9.xyz = u_xlat9.xyz / u_xlat8.xyz;
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat8.xyz;
            u_xlatb11.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat8.xyzx).xyz;
            u_xlat9.x = (u_xlatb11.x) ? u_xlat9.x : u_xlat10.x;
            u_xlat9.y = (u_xlatb11.y) ? u_xlat9.y : u_xlat10.y;
            u_xlat9.z = (u_xlatb11.z) ? u_xlat9.z : u_xlat10.z;
            u_xlat42 = min(u_xlat9.y, u_xlat9.x);
            u_xlat42 = min(u_xlat9.z, u_xlat42);
            u_xlat9.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat4.xyz = u_xlat8.xyz * vec3(u_xlat42) + u_xlat9.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat4.xyz, u_xlat40);
        u_xlatb42 = unity_SpecCube1_HDR.w==1.0;
        u_xlat40 = (u_xlatb42) ? u_xlat10_4.w : 1.0;
        u_xlat40 = u_xlat40 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat40);
        u_xlat6.xyz = vec3(u_xlat41) * u_xlat10_6.xyz + (-u_xlat4.xyz);
        u_xlat7.xyz = unity_SpecCube0_BoxMin.www * u_xlat6.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = vec3(u_xlat38) * u_xlat7.xyz;
    u_xlat6.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat37) + _WorldSpaceLightPos0.xyz;
    u_xlat37 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlat37 = max(u_xlat37, 0.00100000005);
    u_xlat37 = inversesqrt(u_xlat37);
    u_xlat6.xyz = vec3(u_xlat37) * u_xlat6.xyz;
    u_xlat37 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat3.x = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat3.x = clamp(u_xlat3.x, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat6.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat14.x = dot(_WorldSpaceLightPos0.xyz, u_xlat6.xyz);
    u_xlat14.x = clamp(u_xlat14.x, 0.0, 1.0);
    u_xlat26 = u_xlat14.x * u_xlat14.x;
    u_xlat26 = dot(vec2(u_xlat26), vec2(u_xlat39));
    u_xlat26 = u_xlat26 + -0.5;
    u_xlat15 = (-u_xlat3.x) + 1.0;
    u_xlat27 = u_xlat15 * u_xlat15;
    u_xlat27 = u_xlat27 * u_xlat27;
    u_xlat15 = u_xlat15 * u_xlat27;
    u_xlat15 = u_xlat26 * u_xlat15 + 1.0;
    u_xlat27 = -abs(u_xlat37) + 1.0;
    u_xlat40 = u_xlat27 * u_xlat27;
    u_xlat40 = u_xlat40 * u_xlat40;
    u_xlat27 = u_xlat27 * u_xlat40;
    u_xlat26 = u_xlat26 * u_xlat27 + 1.0;
    u_xlat26 = u_xlat26 * u_xlat15;
    u_xlat26 = u_xlat3.x * u_xlat26;
    u_xlat15 = u_xlat39 * u_xlat39;
    u_xlat40 = (-u_xlat39) * u_xlat39 + 1.0;
    u_xlat41 = abs(u_xlat37) * u_xlat40 + u_xlat15;
    u_xlat40 = u_xlat3.x * u_xlat40 + u_xlat15;
    u_xlat37 = abs(u_xlat37) * u_xlat40;
    u_xlat37 = u_xlat3.x * u_xlat41 + u_xlat37;
    u_xlat37 = u_xlat37 + 9.99999975e-06;
    u_xlat37 = 0.5 / u_xlat37;
    u_xlat40 = u_xlat15 * u_xlat15;
    u_xlat41 = u_xlat2.x * u_xlat40 + (-u_xlat2.x);
    u_xlat2.x = u_xlat41 * u_xlat2.x + 1.0;
    u_xlat40 = u_xlat40 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat40 / u_xlat2.x;
    u_xlat37 = u_xlat37 * u_xlat2.x;
    u_xlat37 = u_xlat37 * 3.14159274;
    u_xlat37 = max(u_xlat37, 9.99999975e-05);
    u_xlat37 = sqrt(u_xlat37);
    u_xlat37 = u_xlat3.x * u_xlat37;
    u_xlat2.x = u_xlat15 * u_xlat39;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat3.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb3 = u_xlat3.x!=0.0;
    u_xlat3.x = u_xlatb3 ? 1.0 : float(0.0);
    u_xlat37 = u_xlat37 * u_xlat3.x;
    u_xlat36 = (-u_xlat36) + _Glossiness;
    u_xlat36 = u_xlat36 + 1.0;
    u_xlat36 = clamp(u_xlat36, 0.0, 1.0);
    u_xlat3.xyw = vec3(u_xlat26) * _LightColor0.xyz;
    u_xlat3.xyw = u_xlat5.xyz * vec3(u_xlat38) + u_xlat3.xyw;
    u_xlat5.xyz = vec3(u_xlat37) * _LightColor0.xyz;
    u_xlat37 = (-u_xlat14.x) + 1.0;
    u_xlat14.x = u_xlat37 * u_xlat37;
    u_xlat14.x = u_xlat14.x * u_xlat14.x;
    u_xlat37 = u_xlat37 * u_xlat14.x;
    u_xlat14.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat14.xyz = u_xlat14.xyz * vec3(u_xlat37) + u_xlat0.xyz;
    u_xlat14.xyz = u_xlat14.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xyw + u_xlat14.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xyw = (-u_xlat0.xyz) + vec3(u_xlat36);
    u_xlat0.xyz = vec3(u_xlat27) * u_xlat3.xyw + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (418 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 192
  Matrix4x4 unity_ObjectToWorld at 256
  Matrix4x4 unity_WorldToObject at 320
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  Vector4 unity_4LightPosX0 at 32
  Vector4 unity_4LightPosY0 at 48
  Vector4 unity_4LightPosZ0 at 64
  VectorHalf4 unity_4LightAtten0 at 80
  VectorHalf4 unity_LightColor[8] at 88
  VectorHalf4 unity_SHBr at 152
  VectorHalf4 unity_SHBg at 160
  VectorHalf4 unity_SHBb at 168
  VectorHalf4 unity_SHC at 176
  Vector4 _MainTex_ST at 384
  Vector4 _DetailAlbedoMap_ST at 400
  ScalarHalf _UVSec at 416
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float3 u_xlat2;
    half4 u_xlat16_2;
    float4 u_xlat3;
    float4 u_xlat4;
    float4 u_xlat5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    float u_xlat25;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD4.w = 0.0;
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat25 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat25 = rsqrt(u_xlat25);
    u_xlat2.xyz = float3(u_xlat25) * u_xlat2.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat2.xyz);
    u_xlat3 = (-u_xlat1.yyyy) + Globals.unity_4LightPosY0;
    u_xlat4 = u_xlat2.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat5 = (-u_xlat1.xxxx) + Globals.unity_4LightPosX0;
    u_xlat4 = u_xlat5 * u_xlat2.xxxx + u_xlat4;
    u_xlat3 = u_xlat5 * u_xlat5 + u_xlat3;
    u_xlat5 = (-u_xlat1.zzzz) + Globals.unity_4LightPosZ0;
    output.TEXCOORD8.xyz = u_xlat1.xyz;
    u_xlat1 = u_xlat5 * u_xlat2.zzzz + u_xlat4;
    u_xlat3 = u_xlat5 * u_xlat5 + u_xlat3;
    u_xlat3 = max(u_xlat3, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = rsqrt(u_xlat3);
    u_xlat3 = u_xlat3 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat3 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat3;
    u_xlat1 = u_xlat1 * u_xlat4;
    u_xlat1 = max(u_xlat1, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat3 * u_xlat1;
    u_xlat3.xyz = u_xlat1.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat3.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat1.zzz + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat1.www + u_xlat1.xyz;
    u_xlat3.xyz = u_xlat1.xyz * float3(0.305306017, 0.305306017, 0.305306017) + float3(0.682171106, 0.682171106, 0.682171106);
    u_xlat3.xyz = u_xlat1.xyz * u_xlat3.xyz + float3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat16_6.x = half(u_xlat2.y * u_xlat2.y);
    u_xlat16_6.x = half(u_xlat2.x * u_xlat2.x + (-float(u_xlat16_6.x)));
    u_xlat16_2 = half4(u_xlat2.yzzx * u_xlat2.xyzz);
    u_xlat16_7.x = dot(Globals.unity_SHBr, u_xlat16_2);
    u_xlat16_7.y = dot(Globals.unity_SHBg, u_xlat16_2);
    u_xlat16_7.z = dot(Globals.unity_SHBb, u_xlat16_2);
    u_xlat16_6.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_6.xxx + u_xlat16_7.xyz);
    output.TEXCOORD5.xyz = half3(u_xlat1.xyz * u_xlat3.xyz + float3(u_xlat16_6.xyz));
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat5;
float u_xlat19;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD4.w = 0.0;
    u_xlat2.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat19 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat19 = inversesqrt(u_xlat19);
    u_xlat2.xyz = vec3(u_xlat19) * u_xlat2.xyz;
    vs_TEXCOORD4.xyz = u_xlat2.xyz;
    u_xlat3 = (-u_xlat1.yyyy) + unity_4LightPosY0;
    u_xlat4 = u_xlat2.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat5 = (-u_xlat1.xxxx) + unity_4LightPosX0;
    u_xlat4 = u_xlat5 * u_xlat2.xxxx + u_xlat4;
    u_xlat3 = u_xlat5 * u_xlat5 + u_xlat3;
    u_xlat5 = (-u_xlat1.zzzz) + unity_4LightPosZ0;
    vs_TEXCOORD8.xyz = u_xlat1.xyz;
    u_xlat1 = u_xlat5 * u_xlat2.zzzz + u_xlat4;
    u_xlat3 = u_xlat5 * u_xlat5 + u_xlat3;
    u_xlat3 = max(u_xlat3, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = inversesqrt(u_xlat3);
    u_xlat3 = u_xlat3 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat3 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat3;
    u_xlat1 = u_xlat1 * u_xlat4;
    u_xlat1 = max(u_xlat1, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat3 * u_xlat1;
    u_xlat3.xyz = u_xlat1.yyy * unity_LightColor[1].xyz;
    u_xlat3.xyz = unity_LightColor[0].xyz * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat1.xyz = unity_LightColor[2].xyz * u_xlat1.zzz + u_xlat3.xyz;
    u_xlat1.xyz = unity_LightColor[3].xyz * u_xlat1.www + u_xlat1.xyz;
    u_xlat3.xyz = u_xlat1.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat3.xyz = u_xlat1.xyz * u_xlat3.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat19 = u_xlat2.y * u_xlat2.y;
    u_xlat19 = u_xlat2.x * u_xlat2.x + (-u_xlat19);
    u_xlat2 = u_xlat2.yzzx * u_xlat2.xyzz;
    u_xlat4.x = dot(unity_SHBr, u_xlat2);
    u_xlat4.y = dot(unity_SHBg, u_xlat2);
    u_xlat4.z = dot(unity_SHBb, u_xlat2);
    u_xlat2.xyz = unity_SHC.xyz * vec3(u_xlat19) + u_xlat4.xyz;
    vs_TEXCOORD5.xyz = u_xlat1.xyz * u_xlat3.xyz + u_xlat2.xyz;
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
lowp vec4 u_xlat10_5;
vec4 u_xlat6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
lowp vec4 u_xlat10_7;
vec3 u_xlat8;
lowp vec4 u_xlat10_8;
vec3 u_xlat9;
lowp vec4 u_xlat10_9;
vec3 u_xlat10;
bvec3 u_xlatb10;
vec3 u_xlat11;
bvec3 u_xlatb12;
vec3 u_xlat15;
float u_xlat16;
float u_xlat17;
float u_xlat19;
float u_xlat28;
float u_xlat29;
float u_xlat30;
float u_xlat39;
float u_xlat40;
float u_xlat41;
bool u_xlatb41;
float u_xlat42;
float u_xlat44;
bool u_xlatb44;
float u_xlat45;
bool u_xlatb45;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat39 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat39) * u_xlat1.xyz;
    u_xlat40 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat2.xyz = vec3(u_xlat40) * vs_TEXCOORD4.xyz;
    u_xlat40 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat3.xyz = vec3(u_xlat40) * vs_TEXCOORD1.xyz;
    u_xlat4.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_4 = texture(_ShadowMapTexture, u_xlat4.xy);
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat42 = (-_OcclusionStrength) + 1.0;
    u_xlat42 = u_xlat10_5.y * _OcclusionStrength + u_xlat42;
    u_xlat17 = (-_Glossiness) + 1.0;
    u_xlat30 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat30 = u_xlat30 + u_xlat30;
    u_xlat5.xyz = u_xlat2.xyz * (-vec3(u_xlat30)) + u_xlat3.xyz;
    u_xlat4.xzw = u_xlat10_4.xxx * _LightColor0.xyz;
    u_xlatb44 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb44){
        u_xlatb44 = unity_ProbeVolumeParams.y==1.0;
        u_xlat6.xyz = vs_TEXCOORD8.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat6.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD8.xxx + u_xlat6.xyz;
        u_xlat6.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD8.zzz + u_xlat6.xyz;
        u_xlat6.xyz = u_xlat6.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat6.xyz = (bool(u_xlatb44)) ? u_xlat6.xyz : vs_TEXCOORD8.xyz;
        u_xlat6.xyz = u_xlat6.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat6.yzw = u_xlat6.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat44 = u_xlat6.y * 0.25;
        u_xlat19 = unity_ProbeVolumeParams.z * 0.5;
        u_xlat7.x = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat44 = max(u_xlat44, u_xlat19);
        u_xlat6.x = min(u_xlat7.x, u_xlat44);
        u_xlat10_7 = texture(unity_ProbeVolumeSH, u_xlat6.xzw);
        u_xlat8.xyz = u_xlat6.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_8 = texture(unity_ProbeVolumeSH, u_xlat8.xyz);
        u_xlat6.xyz = u_xlat6.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_6 = texture(unity_ProbeVolumeSH, u_xlat6.xyz);
        u_xlat2.w = 1.0;
        u_xlat7.x = dot(u_xlat10_7, u_xlat2);
        u_xlat7.y = dot(u_xlat10_8, u_xlat2);
        u_xlat7.z = dot(u_xlat10_6, u_xlat2);
    } else {
        u_xlat2.w = 1.0;
        u_xlat7.x = dot(unity_SHAr, u_xlat2);
        u_xlat7.y = dot(unity_SHAg, u_xlat2);
        u_xlat7.z = dot(unity_SHAb, u_xlat2);
    //ENDIF
    }
    u_xlat6.xyz = u_xlat7.xyz + vs_TEXCOORD5.xyz;
    u_xlat6.xyz = max(u_xlat6.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat6.xyz = log2(u_xlat6.xyz);
    u_xlat6.xyz = u_xlat6.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat6.xyz = exp2(u_xlat6.xyz);
    u_xlat6.xyz = u_xlat6.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat6.xyz = max(u_xlat6.xyz, vec3(0.0, 0.0, 0.0));
    u_xlatb41 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb41){
        u_xlat41 = dot(u_xlat5.xyz, u_xlat5.xyz);
        u_xlat41 = inversesqrt(u_xlat41);
        u_xlat7.xyz = vec3(u_xlat41) * u_xlat5.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat7.xyz;
        u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat9.xyz = u_xlat9.xyz / u_xlat7.xyz;
        u_xlatb10.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat7.xyzx).xyz;
        u_xlat8.x = (u_xlatb10.x) ? u_xlat8.x : u_xlat9.x;
        u_xlat8.y = (u_xlatb10.y) ? u_xlat8.y : u_xlat9.y;
        u_xlat8.z = (u_xlatb10.z) ? u_xlat8.z : u_xlat9.z;
        u_xlat41 = min(u_xlat8.y, u_xlat8.x);
        u_xlat41 = min(u_xlat8.z, u_xlat41);
        u_xlat8.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat7.xyz = u_xlat7.xyz * vec3(u_xlat41) + u_xlat8.xyz;
    } else {
        u_xlat7.xyz = u_xlat5.xyz;
    //ENDIF
    }
    u_xlat41 = (-u_xlat17) * 0.699999988 + 1.70000005;
    u_xlat41 = u_xlat41 * u_xlat17;
    u_xlat41 = u_xlat41 * 6.0;
    u_xlat10_7 = textureLod(unity_SpecCube0, u_xlat7.xyz, u_xlat41);
    u_xlatb44 = unity_SpecCube0_HDR.w==1.0;
    u_xlat44 = (u_xlatb44) ? u_xlat10_7.w : 1.0;
    u_xlat44 = u_xlat44 * unity_SpecCube0_HDR.x;
    u_xlat8.xyz = u_xlat10_7.xyz * vec3(u_xlat44);
    u_xlatb45 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb45){
        u_xlatb45 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb45){
            u_xlat45 = dot(u_xlat5.xyz, u_xlat5.xyz);
            u_xlat45 = inversesqrt(u_xlat45);
            u_xlat9.xyz = u_xlat5.xyz * vec3(u_xlat45);
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
            u_xlat11.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
            u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
            u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
            u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
            u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
            u_xlat45 = min(u_xlat10.y, u_xlat10.x);
            u_xlat45 = min(u_xlat10.z, u_xlat45);
            u_xlat10.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat5.xyz = u_xlat9.xyz * vec3(u_xlat45) + u_xlat10.xyz;
        //ENDIF
        }
        u_xlat10_9 = textureLod(unity_SpecCube1, u_xlat5.xyz, u_xlat41);
        u_xlatb41 = unity_SpecCube1_HDR.w==1.0;
        u_xlat41 = (u_xlatb41) ? u_xlat10_9.w : 1.0;
        u_xlat41 = u_xlat41 * unity_SpecCube1_HDR.x;
        u_xlat5.xyz = u_xlat10_9.xyz * vec3(u_xlat41);
        u_xlat7.xyz = vec3(u_xlat44) * u_xlat10_7.xyz + (-u_xlat5.xyz);
        u_xlat8.xyz = unity_SpecCube0_BoxMin.www * u_xlat7.xyz + u_xlat5.xyz;
    //ENDIF
    }
    u_xlat5.xyz = vec3(u_xlat42) * u_xlat8.xyz;
    u_xlat7.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat40) + _WorldSpaceLightPos0.xyz;
    u_xlat40 = dot(u_xlat7.xyz, u_xlat7.xyz);
    u_xlat40 = max(u_xlat40, 0.00100000005);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat7.xyz = vec3(u_xlat40) * u_xlat7.xyz;
    u_xlat40 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat41 = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat41 = clamp(u_xlat41, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat7.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat15.x = dot(_WorldSpaceLightPos0.xyz, u_xlat7.xyz);
    u_xlat15.x = clamp(u_xlat15.x, 0.0, 1.0);
    u_xlat28 = u_xlat15.x * u_xlat15.x;
    u_xlat28 = dot(vec2(u_xlat28), vec2(u_xlat17));
    u_xlat28 = u_xlat28 + -0.5;
    u_xlat3.x = (-u_xlat41) + 1.0;
    u_xlat16 = u_xlat3.x * u_xlat3.x;
    u_xlat16 = u_xlat16 * u_xlat16;
    u_xlat3.x = u_xlat3.x * u_xlat16;
    u_xlat3.x = u_xlat28 * u_xlat3.x + 1.0;
    u_xlat16 = -abs(u_xlat40) + 1.0;
    u_xlat29 = u_xlat16 * u_xlat16;
    u_xlat29 = u_xlat29 * u_xlat29;
    u_xlat16 = u_xlat16 * u_xlat29;
    u_xlat28 = u_xlat28 * u_xlat16 + 1.0;
    u_xlat28 = u_xlat28 * u_xlat3.x;
    u_xlat28 = u_xlat41 * u_xlat28;
    u_xlat3.x = u_xlat17 * u_xlat17;
    u_xlat29 = (-u_xlat17) * u_xlat17 + 1.0;
    u_xlat44 = abs(u_xlat40) * u_xlat29 + u_xlat3.x;
    u_xlat29 = u_xlat41 * u_xlat29 + u_xlat3.x;
    u_xlat40 = abs(u_xlat40) * u_xlat29;
    u_xlat40 = u_xlat41 * u_xlat44 + u_xlat40;
    u_xlat40 = u_xlat40 + 9.99999975e-06;
    u_xlat40 = 0.5 / u_xlat40;
    u_xlat29 = u_xlat3.x * u_xlat3.x;
    u_xlat44 = u_xlat2.x * u_xlat29 + (-u_xlat2.x);
    u_xlat2.x = u_xlat44 * u_xlat2.x + 1.0;
    u_xlat29 = u_xlat29 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat29 / u_xlat2.x;
    u_xlat40 = u_xlat40 * u_xlat2.x;
    u_xlat40 = u_xlat40 * 3.14159274;
    u_xlat40 = max(u_xlat40, 9.99999975e-05);
    u_xlat40 = sqrt(u_xlat40);
    u_xlat40 = u_xlat41 * u_xlat40;
    u_xlat2.x = u_xlat3.x * u_xlat17;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat41 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb41 = u_xlat41!=0.0;
    u_xlat41 = u_xlatb41 ? 1.0 : float(0.0);
    u_xlat40 = u_xlat40 * u_xlat41;
    u_xlat39 = (-u_xlat39) + _Glossiness;
    u_xlat39 = u_xlat39 + 1.0;
    u_xlat39 = clamp(u_xlat39, 0.0, 1.0);
    u_xlat7.xyz = vec3(u_xlat28) * u_xlat4.xzw;
    u_xlat3.xzw = u_xlat6.xyz * vec3(u_xlat42) + u_xlat7.xyz;
    u_xlat4.xyz = u_xlat4.xzw * vec3(u_xlat40);
    u_xlat40 = (-u_xlat15.x) + 1.0;
    u_xlat15.x = u_xlat40 * u_xlat40;
    u_xlat15.x = u_xlat15.x * u_xlat15.x;
    u_xlat40 = u_xlat40 * u_xlat15.x;
    u_xlat15.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat15.xyz = u_xlat15.xyz * vec3(u_xlat40) + u_xlat0.xyz;
    u_xlat15.xyz = u_xlat15.xyz * u_xlat4.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xzw + u_xlat15.xyz;
    u_xlat2.xyz = u_xlat5.xyz * u_xlat2.xxx;
    u_xlat3.xzw = (-u_xlat0.xyz) + vec3(u_xlat39);
    u_xlat0.xyz = vec3(u_xlat16) * u_xlat3.xzw + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN DIRLIGHTMAP_COMBINED DYNAMICLIGHTMAP_ON _EMISSION VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  Vector4 unity_WorldTransformParams at 224
  Vector4 unity_DynamicLightmapST at 240
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    float2 TEXCOORD2 [[ attribute(4) ]] ;
    half4 TANGENT0 [[ attribute(5) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float3 TEXCOORD8 [[ user(TEXCOORD8) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float3 u_xlat2;
    half3 u_xlat16_3;
    float u_xlat13;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD8.xyz = u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    u_xlat1.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat1.xyz;
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat1.xyz = float3(u_xlat13) * u_xlat1.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat16_3.xyz = half3(u_xlat1.yzx * u_xlat2.zxy);
    u_xlat16_3.xyz = half3(u_xlat2.yzx * u_xlat1.zxy + (-float3(u_xlat16_3.xyz)));
    output.TEXCOORD4.xyz = half3(u_xlat2.xyz);
    u_xlat1.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat1.xxx * float3(u_xlat16_3.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.w = 0.0;
    u_xlat1.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    output.TEXCOORD5.zw = half2(u_xlat1.xy);
    output.TEXCOORD5.xy = half2(0.0, 0.0);
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
out vec3 vs_TEXCOORD8;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec3 u_xlat2;
vec3 u_xlat3;
float u_xlat13;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD8.xyz = u_xlat1.xyz;
    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;
    u_xlat13 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat13 = inversesqrt(u_xlat13);
    u_xlat1.xyz = vec3(u_xlat13) * u_xlat1.xyz;
    vs_TEXCOORD2.xyz = u_xlat1.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat2.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = inversesqrt(u_xlat13);
    u_xlat2.xyz = vec3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.yzx * u_xlat2.zxy;
    u_xlat1.xyz = u_xlat2.yzx * u_xlat1.zxy + (-u_xlat3.xyz);
    vs_TEXCOORD4.xyz = u_xlat2.xyz;
    u_xlat13 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat13) * u_xlat1.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.w = 0.0;
    vs_TEXCOORD5.zw = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    vs_TEXCOORD5.xy = vec2(0.0, 0.0);
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_BoxMax;
uniform 	vec4 unity_SpecCube0_BoxMin;
uniform 	vec4 unity_SpecCube0_ProbePosition;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 unity_SpecCube1_BoxMax;
uniform 	vec4 unity_SpecCube1_BoxMin;
uniform 	vec4 unity_SpecCube1_ProbePosition;
uniform 	vec4 unity_SpecCube1_HDR;
uniform 	vec4 unity_DynamicLightmap_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  sampler2D unity_DynamicLightmap;
uniform  sampler2D unity_DynamicDirectionality;
uniform  samplerCube unity_SpecCube0;
uniform  samplerCube unity_SpecCube1;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
in  vec3 vs_TEXCOORD8;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
vec4 u_xlat3;
bool u_xlatb3;
vec3 u_xlat4;
mediump float u_xlat16_4;
lowp vec4 u_xlat10_4;
bool u_xlatb4;
vec3 u_xlat5;
lowp vec4 u_xlat10_5;
vec3 u_xlat6;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
mediump vec3 u_xlat16_7;
lowp vec4 u_xlat10_7;
vec3 u_xlat8;
vec3 u_xlat9;
vec3 u_xlat10;
bvec3 u_xlatb10;
vec3 u_xlat11;
bvec3 u_xlatb12;
vec3 u_xlat15;
float u_xlat16;
vec3 u_xlat17;
float u_xlat28;
float u_xlat29;
float u_xlat39;
float u_xlat40;
float u_xlat41;
float u_xlat42;
float u_xlat43;
float u_xlat44;
bool u_xlatb44;
float u_xlat45;
bool u_xlatb45;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat0.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat39 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat39) * u_xlat1.xyz;
    u_xlat40 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat2.xyz = vec3(u_xlat40) * vs_TEXCOORD4.xyz;
    u_xlat40 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat3.xyz = vec3(u_xlat40) * vs_TEXCOORD1.xyz;
    u_xlat4.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_4 = texture(_ShadowMapTexture, u_xlat4.xy);
    u_xlat10_5 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat41 = (-_OcclusionStrength) + 1.0;
    u_xlat41 = u_xlat10_5.y * _OcclusionStrength + u_xlat41;
    u_xlat42 = (-_Glossiness) + 1.0;
    u_xlat17.x = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat17.x = u_xlat17.x + u_xlat17.x;
    u_xlat17.xyz = u_xlat2.xyz * (-u_xlat17.xxx) + u_xlat3.xyz;
    u_xlat5.xyz = u_xlat10_4.xxx * _LightColor0.xyz;
    u_xlat10_6 = texture(unity_DynamicLightmap, vs_TEXCOORD5.zw);
    u_xlat4.x = u_xlat10_6.w * unity_DynamicLightmap_HDR.x;
    u_xlat6.xyz = u_xlat10_6.xyz * u_xlat4.xxx;
    u_xlat6.xyz = log2(u_xlat6.xyz);
    u_xlat6.xyz = u_xlat6.xyz * unity_DynamicLightmap_HDR.yyy;
    u_xlat6.xyz = exp2(u_xlat6.xyz);
    u_xlat10_7 = texture(unity_DynamicDirectionality, vs_TEXCOORD5.zw);
    u_xlat16_7.xyz = u_xlat10_7.xyz + vec3(-0.5, -0.5, -0.5);
    u_xlat4.x = dot(u_xlat2.xyz, u_xlat16_7.xyz);
    u_xlat4.x = u_xlat4.x + 0.5;
    u_xlat6.xyz = u_xlat4.xxx * u_xlat6.xyz;
    u_xlat16_4 = max(u_xlat10_7.w, 9.99999975e-05);
    u_xlat6.xyz = u_xlat6.xyz / vec3(u_xlat16_4);
    u_xlatb4 = 0.0<unity_SpecCube0_ProbePosition.w;
    if(u_xlatb4){
        u_xlat4.x = dot(u_xlat17.xyz, u_xlat17.xyz);
        u_xlat4.x = inversesqrt(u_xlat4.x);
        u_xlat7.xyz = u_xlat4.xxx * u_xlat17.xyz;
        u_xlat8.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMax.xyz;
        u_xlat8.xyz = u_xlat8.xyz / u_xlat7.xyz;
        u_xlat9.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube0_BoxMin.xyz;
        u_xlat9.xyz = u_xlat9.xyz / u_xlat7.xyz;
        u_xlatb10.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat7.xyzx).xyz;
        u_xlat8.x = (u_xlatb10.x) ? u_xlat8.x : u_xlat9.x;
        u_xlat8.y = (u_xlatb10.y) ? u_xlat8.y : u_xlat9.y;
        u_xlat8.z = (u_xlatb10.z) ? u_xlat8.z : u_xlat9.z;
        u_xlat4.x = min(u_xlat8.y, u_xlat8.x);
        u_xlat4.x = min(u_xlat8.z, u_xlat4.x);
        u_xlat8.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube0_ProbePosition.xyz);
        u_xlat7.xyz = u_xlat7.xyz * u_xlat4.xxx + u_xlat8.xyz;
    } else {
        u_xlat7.xyz = u_xlat17.xyz;
    //ENDIF
    }
    u_xlat4.x = (-u_xlat42) * 0.699999988 + 1.70000005;
    u_xlat4.x = u_xlat42 * u_xlat4.x;
    u_xlat4.x = u_xlat4.x * 6.0;
    u_xlat10_7 = textureLod(unity_SpecCube0, u_xlat7.xyz, u_xlat4.x);
    u_xlatb44 = unity_SpecCube0_HDR.w==1.0;
    u_xlat44 = (u_xlatb44) ? u_xlat10_7.w : 1.0;
    u_xlat44 = u_xlat44 * unity_SpecCube0_HDR.x;
    u_xlat8.xyz = u_xlat10_7.xyz * vec3(u_xlat44);
    u_xlatb45 = unity_SpecCube0_BoxMin.w<0.999989986;
    if(u_xlatb45){
        u_xlatb45 = 0.0<unity_SpecCube1_ProbePosition.w;
        if(u_xlatb45){
            u_xlat45 = dot(u_xlat17.xyz, u_xlat17.xyz);
            u_xlat45 = inversesqrt(u_xlat45);
            u_xlat9.xyz = u_xlat17.xyz * vec3(u_xlat45);
            u_xlat10.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMax.xyz;
            u_xlat10.xyz = u_xlat10.xyz / u_xlat9.xyz;
            u_xlat11.xyz = (-vs_TEXCOORD8.xyz) + unity_SpecCube1_BoxMin.xyz;
            u_xlat11.xyz = u_xlat11.xyz / u_xlat9.xyz;
            u_xlatb12.xyz = lessThan(vec4(0.0, 0.0, 0.0, 0.0), u_xlat9.xyzx).xyz;
            u_xlat10.x = (u_xlatb12.x) ? u_xlat10.x : u_xlat11.x;
            u_xlat10.y = (u_xlatb12.y) ? u_xlat10.y : u_xlat11.y;
            u_xlat10.z = (u_xlatb12.z) ? u_xlat10.z : u_xlat11.z;
            u_xlat45 = min(u_xlat10.y, u_xlat10.x);
            u_xlat45 = min(u_xlat10.z, u_xlat45);
            u_xlat10.xyz = vs_TEXCOORD8.xyz + (-unity_SpecCube1_ProbePosition.xyz);
            u_xlat17.xyz = u_xlat9.xyz * vec3(u_xlat45) + u_xlat10.xyz;
        //ENDIF
        }
        u_xlat10_4 = textureLod(unity_SpecCube1, u_xlat17.xyz, u_xlat4.x);
        u_xlatb45 = unity_SpecCube1_HDR.w==1.0;
        u_xlat43 = (u_xlatb45) ? u_xlat10_4.w : 1.0;
        u_xlat43 = u_xlat43 * unity_SpecCube1_HDR.x;
        u_xlat4.xyz = u_xlat10_4.xyz * vec3(u_xlat43);
        u_xlat7.xyz = vec3(u_xlat44) * u_xlat10_7.xyz + (-u_xlat4.xyz);
        u_xlat8.xyz = unity_SpecCube0_BoxMin.www * u_xlat7.xyz + u_xlat4.xyz;
    //ENDIF
    }
    u_xlat4.xyz = vec3(u_xlat41) * u_xlat8.xyz;
    u_xlat7.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat40) + _WorldSpaceLightPos0.xyz;
    u_xlat40 = dot(u_xlat7.xyz, u_xlat7.xyz);
    u_xlat40 = max(u_xlat40, 0.00100000005);
    u_xlat40 = inversesqrt(u_xlat40);
    u_xlat7.xyz = vec3(u_xlat40) * u_xlat7.xyz;
    u_xlat40 = dot(u_xlat2.xyz, (-u_xlat3.xyz));
    u_xlat3.x = dot(u_xlat2.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat3.x = clamp(u_xlat3.x, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat2.xyz, u_xlat7.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat15.x = dot(_WorldSpaceLightPos0.xyz, u_xlat7.xyz);
    u_xlat15.x = clamp(u_xlat15.x, 0.0, 1.0);
    u_xlat28 = u_xlat15.x * u_xlat15.x;
    u_xlat28 = dot(vec2(u_xlat28), vec2(u_xlat42));
    u_xlat28 = u_xlat28 + -0.5;
    u_xlat16 = (-u_xlat3.x) + 1.0;
    u_xlat29 = u_xlat16 * u_xlat16;
    u_xlat29 = u_xlat29 * u_xlat29;
    u_xlat16 = u_xlat16 * u_xlat29;
    u_xlat16 = u_xlat28 * u_xlat16 + 1.0;
    u_xlat29 = -abs(u_xlat40) + 1.0;
    u_xlat43 = u_xlat29 * u_xlat29;
    u_xlat43 = u_xlat43 * u_xlat43;
    u_xlat29 = u_xlat29 * u_xlat43;
    u_xlat28 = u_xlat28 * u_xlat29 + 1.0;
    u_xlat28 = u_xlat28 * u_xlat16;
    u_xlat28 = u_xlat3.x * u_xlat28;
    u_xlat16 = u_xlat42 * u_xlat42;
    u_xlat43 = (-u_xlat42) * u_xlat42 + 1.0;
    u_xlat44 = abs(u_xlat40) * u_xlat43 + u_xlat16;
    u_xlat43 = u_xlat3.x * u_xlat43 + u_xlat16;
    u_xlat40 = abs(u_xlat40) * u_xlat43;
    u_xlat40 = u_xlat3.x * u_xlat44 + u_xlat40;
    u_xlat40 = u_xlat40 + 9.99999975e-06;
    u_xlat40 = 0.5 / u_xlat40;
    u_xlat43 = u_xlat16 * u_xlat16;
    u_xlat44 = u_xlat2.x * u_xlat43 + (-u_xlat2.x);
    u_xlat2.x = u_xlat44 * u_xlat2.x + 1.0;
    u_xlat43 = u_xlat43 * 0.318309873;
    u_xlat2.x = u_xlat2.x * u_xlat2.x + 1.00000001e-07;
    u_xlat2.x = u_xlat43 / u_xlat2.x;
    u_xlat40 = u_xlat40 * u_xlat2.x;
    u_xlat40 = u_xlat40 * 3.14159274;
    u_xlat40 = max(u_xlat40, 9.99999975e-05);
    u_xlat40 = sqrt(u_xlat40);
    u_xlat40 = u_xlat3.x * u_xlat40;
    u_xlat2.x = u_xlat16 * u_xlat42;
    u_xlat2.x = (-u_xlat2.x) * 0.280000001 + 1.0;
    u_xlat3.x = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlatb3 = u_xlat3.x!=0.0;
    u_xlat3.x = u_xlatb3 ? 1.0 : float(0.0);
    u_xlat40 = u_xlat40 * u_xlat3.x;
    u_xlat39 = (-u_xlat39) + _Glossiness;
    u_xlat39 = u_xlat39 + 1.0;
    u_xlat39 = clamp(u_xlat39, 0.0, 1.0);
    u_xlat3.xyw = vec3(u_xlat28) * u_xlat5.xyz;
    u_xlat3.xyw = u_xlat6.xyz * vec3(u_xlat41) + u_xlat3.xyw;
    u_xlat5.xyz = u_xlat5.xyz * vec3(u_xlat40);
    u_xlat40 = (-u_xlat15.x) + 1.0;
    u_xlat15.x = u_xlat40 * u_xlat40;
    u_xlat15.x = u_xlat15.x * u_xlat15.x;
    u_xlat40 = u_xlat40 * u_xlat15.x;
    u_xlat15.xyz = (-u_xlat0.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat15.xyz = u_xlat15.xyz * vec3(u_xlat40) + u_xlat0.xyz;
    u_xlat15.xyz = u_xlat15.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xyw + u_xlat15.xyz;
    u_xlat2.xyz = u_xlat4.xyz * u_xlat2.xxx;
    u_xlat3.xyw = (-u_xlat0.xyz) + vec3(u_xlat39);
    u_xlat0.xyz = vec3(u_xlat29) * u_xlat3.xyw + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

 }
 Pass {
  Name "FORWARD_DELTA"
  Tags { "LIGHTMODE"="ForwardAdd" "SHADOWSUPPORT"="true" "RenderType"="Opaque" "PerformanceChecks"="False" }
  ZWrite Off
  Blend [_SrcBlend] One
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
Keywords set in this variant: POINT 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (336 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Matrix4x4 unity_WorldToLight at 272
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat0.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    output.TEXCOORD5.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1

Constant Buffer "Globals" (20 bytes) on slot 0 {
  VectorHalf4 _LightColor0 at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    half u_xlat16_6;
    half3 u_xlat16_7;
    half u_xlat16_9;
    half u_xlat16_12;
    half u_xlat16_13;
    half u_xlat16_18;
    half u_xlat16_19;
    float u_xlat21;
    half u_xlat16_21;
    bool u_xlatb21;
    u_xlat16_0.x = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD1.xyz);
    u_xlat16_1.x = input.TEXCOORD2.w;
    u_xlat16_1.y = input.TEXCOORD3.w;
    u_xlat16_1.z = input.TEXCOORD4.w;
    u_xlat16_18 = dot(u_xlat16_1.xyz, u_xlat16_1.xyz);
    u_xlat16_18 = rsqrt(u_xlat16_18);
    u_xlat16_2.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_18) + (-u_xlat16_0.xyz));
    u_xlat16_1.xyz = half3(half3(u_xlat16_18) * u_xlat16_1.xyz);
    u_xlat16_18 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlat16_3.x = half(max(float(u_xlat16_18), 0.00100000005));
    u_xlat16_18 = rsqrt(u_xlat16_3.x);
    u_xlat16_2.xyz = half3(half3(u_xlat16_18) * u_xlat16_2.xyz);
    u_xlat16_18 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_18 = rsqrt(u_xlat16_18);
    u_xlat16_4.xyz = half3(half3(u_xlat16_18) * input.TEXCOORD4.xyz);
    u_xlat16_18 = dot(u_xlat16_4.xyz, u_xlat16_2.xyz);
    u_xlat16_18 = clamp(u_xlat16_18, 0.0h, 1.0h);
    u_xlat16_19 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_19 = clamp(u_xlat16_19, 0.0h, 1.0h);
    u_xlat16_1.x = dot(u_xlat16_4.xyz, u_xlat16_1.xyz);
    u_xlat16_1.x = clamp(u_xlat16_1.x, 0.0h, 1.0h);
    u_xlat16_0.x = dot(u_xlat16_4.xyz, (-u_xlat16_0.xyz));
    u_xlat16_6 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_12 = half(u_xlat16_6 * u_xlat16_6);
    u_xlat16_7.x = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_13 = half(u_xlat16_18 * u_xlat16_7.x + (-u_xlat16_18));
    u_xlat16_3.x = half(float(u_xlat16_13) * float(u_xlat16_18) + 1.0);
    u_xlat16_3.x = half(float(u_xlat16_3.x) * float(u_xlat16_3.x) + 1.00000001e-07);
    u_xlat16_9 = half(float(u_xlat16_7.x) * 0.318309873);
    u_xlat16_3.x = half(u_xlat16_9 / u_xlat16_3.x);
    u_xlat16_18 = half((-float(u_xlat16_6)) * float(u_xlat16_6) + 1.0);
    u_xlat16_7.x = half(abs(u_xlat16_0.x) * u_xlat16_18 + u_xlat16_12);
    u_xlat16_12 = half(u_xlat16_1.x * u_xlat16_18 + u_xlat16_12);
    u_xlat16_12 = half(u_xlat16_12 * abs(u_xlat16_0.x));
    u_xlat16_0.x = half(-abs(float(u_xlat16_0.x)) + 1.0);
    u_xlat16_12 = half(u_xlat16_1.x * u_xlat16_7.x + u_xlat16_12);
    u_xlat16_9 = half(float(u_xlat16_12) + 9.99999975e-06);
    u_xlat16_9 = half(0.5 / float(u_xlat16_9));
    u_xlat16_12 = half(u_xlat16_3.x * u_xlat16_9);
    u_xlat16_3.x = half(float(u_xlat16_12) * 3.14159274);
    u_xlat16_3.x = half(max(float(u_xlat16_3.x), 9.99999975e-05));
    u_xlat16_3.x = sqrt(u_xlat16_3.x);
    u_xlat16_12 = half(u_xlat16_1.x * u_xlat16_3.x);
    u_xlat16_3.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_3.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_18 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb21 = u_xlat16_18!=0.0;
    u_xlat21 = u_xlatb21 ? 1.0 : float(0.0);
    u_xlat16_12 = half(float(u_xlat16_12) * u_xlat21);
    u_xlat21 = dot(input.TEXCOORD5.xyz, input.TEXCOORD5.xyz);
    u_xlat16_21 = _LightTexture0.sample(sampler_LightTexture0, float2(u_xlat21)).w;
    u_xlat16_4.xyz = half3(half3(u_xlat16_21) * Globals._LightColor0.xyz);
    u_xlat16_5.xyz = half3(half3(u_xlat16_12) * u_xlat16_4.xyz);
    u_xlat16_12 = half((-float(u_xlat16_19)) + 1.0);
    u_xlat16_18 = half(u_xlat16_19 * u_xlat16_19);
    u_xlat16_6 = dot(half2(u_xlat16_18), half2(u_xlat16_6));
    u_xlat16_6 = half(float(u_xlat16_6) + -0.5);
    u_xlat16_18 = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_18 = half(u_xlat16_18 * u_xlat16_18);
    u_xlat16_12 = half(u_xlat16_12 * u_xlat16_18);
    u_xlat16_7.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * half3(u_xlat16_12) + u_xlat16_2.xyz);
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * u_xlat16_5.xyz);
    u_xlat16_12 = half(u_xlat16_0.x * u_xlat16_0.x);
    u_xlat16_12 = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_12);
    u_xlat16_0.x = half(float(u_xlat16_6) * float(u_xlat16_0.x) + 1.0);
    u_xlat16_12 = half((-float(u_xlat16_1.x)) + 1.0);
    u_xlat16_18 = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_18 = half(u_xlat16_18 * u_xlat16_18);
    u_xlat16_12 = half(u_xlat16_12 * u_xlat16_18);
    u_xlat16_6 = half(float(u_xlat16_6) * float(u_xlat16_12) + 1.0);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_6);
    u_xlat16_0.x = half(u_xlat16_1.x * u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * u_xlat16_4.xyz);
    u_xlat16_18 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_2.xyz = half3(half3(u_xlat16_18) * u_xlat16_3.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_2.xyz * u_xlat16_0.xyz + u_xlat16_7.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    vs_TEXCOORD5.xyz = hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
float u_xlat6;
vec3 u_xlat7;
float u_xlat12;
float u_xlat13;
float u_xlat18;
bool u_xlatb18;
float u_xlat19;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD1.xyz;
    u_xlat1.x = vs_TEXCOORD2.w;
    u_xlat1.y = vs_TEXCOORD3.w;
    u_xlat1.z = vs_TEXCOORD4.w;
    u_xlat18 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat2.xyz = u_xlat1.xyz * vec3(u_xlat18) + (-u_xlat0.xyz);
    u_xlat1.xyz = vec3(u_xlat18) * u_xlat1.xyz;
    u_xlat18 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat18 = max(u_xlat18, 0.00100000005);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat2.xyz = vec3(u_xlat18) * u_xlat2.xyz;
    u_xlat18 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = vec3(u_xlat18) * vs_TEXCOORD4.xyz;
    u_xlat18 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat18 = clamp(u_xlat18, 0.0, 1.0);
    u_xlat19 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat1.x = dot(u_xlat3.xyz, u_xlat1.xyz);
    u_xlat1.x = clamp(u_xlat1.x, 0.0, 1.0);
    u_xlat0.x = dot(u_xlat3.xyz, (-u_xlat0.xyz));
    u_xlat6 = (-_Glossiness) + 1.0;
    u_xlat12 = u_xlat6 * u_xlat6;
    u_xlat7.x = u_xlat12 * u_xlat12;
    u_xlat13 = u_xlat18 * u_xlat7.x + (-u_xlat18);
    u_xlat18 = u_xlat13 * u_xlat18 + 1.0;
    u_xlat18 = u_xlat18 * u_xlat18 + 1.00000001e-07;
    u_xlat7.x = u_xlat7.x * 0.318309873;
    u_xlat18 = u_xlat7.x / u_xlat18;
    u_xlat7.x = (-u_xlat6) * u_xlat6 + 1.0;
    u_xlat13 = abs(u_xlat0.x) * u_xlat7.x + u_xlat12;
    u_xlat12 = u_xlat1.x * u_xlat7.x + u_xlat12;
    u_xlat12 = u_xlat12 * abs(u_xlat0.x);
    u_xlat0.x = -abs(u_xlat0.x) + 1.0;
    u_xlat12 = u_xlat1.x * u_xlat13 + u_xlat12;
    u_xlat12 = u_xlat12 + 9.99999975e-06;
    u_xlat12 = 0.5 / u_xlat12;
    u_xlat12 = u_xlat18 * u_xlat12;
    u_xlat12 = u_xlat12 * 3.14159274;
    u_xlat12 = max(u_xlat12, 9.99999975e-05);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat1.x * u_xlat12;
    u_xlat10_2 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat3.xyz = _Color.xyz * u_xlat10_2.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat2.xyz = u_xlat10_2.xyz * _Color.xyz;
    u_xlat3.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat3.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat18 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlatb18 = u_xlat18!=0.0;
    u_xlat18 = u_xlatb18 ? 1.0 : float(0.0);
    u_xlat12 = u_xlat18 * u_xlat12;
    u_xlat18 = dot(vs_TEXCOORD5.xyz, vs_TEXCOORD5.xyz);
    u_xlat10_4 = texture(_LightTexture0, vec2(u_xlat18));
    u_xlat4.xyz = u_xlat10_4.www * _LightColor0.xyz;
    u_xlat5.xyz = vec3(u_xlat12) * u_xlat4.xyz;
    u_xlat12 = (-u_xlat19) + 1.0;
    u_xlat18 = u_xlat19 * u_xlat19;
    u_xlat6 = dot(vec2(u_xlat18), vec2(u_xlat6));
    u_xlat6 = u_xlat6 + -0.5;
    u_xlat18 = u_xlat12 * u_xlat12;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat12 = u_xlat12 * u_xlat18;
    u_xlat7.xyz = (-u_xlat3.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat7.xyz = u_xlat7.xyz * vec3(u_xlat12) + u_xlat3.xyz;
    u_xlat7.xyz = u_xlat7.xyz * u_xlat5.xyz;
    u_xlat12 = u_xlat0.x * u_xlat0.x;
    u_xlat12 = u_xlat12 * u_xlat12;
    u_xlat0.x = u_xlat0.x * u_xlat12;
    u_xlat0.x = u_xlat6 * u_xlat0.x + 1.0;
    u_xlat12 = (-u_xlat1.x) + 1.0;
    u_xlat18 = u_xlat12 * u_xlat12;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat12 = u_xlat12 * u_xlat18;
    u_xlat6 = u_xlat6 * u_xlat12 + 1.0;
    u_xlat0.x = u_xlat0.x * u_xlat6;
    u_xlat0.x = u_xlat1.x * u_xlat0.x;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat2.xyz = vec3(u_xlat18) * u_xlat2.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat7.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat0.xyw = (-u_xlat0.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0

Constant Buffer "Globals" (20 bytes) on slot 0 {
  VectorHalf4 _LightColor0 at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half u_xlat16_5;
    half3 u_xlat16_6;
    half u_xlat16_9;
    half u_xlat16_10;
    half u_xlat16_11;
    half u_xlat16_15;
    half u_xlat16_16;
    float u_xlat19;
    bool u_xlatb19;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_15 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_15 = rsqrt(u_xlat16_15);
    u_xlat16_1.x = input.TEXCOORD2.w;
    u_xlat16_1.y = input.TEXCOORD3.w;
    u_xlat16_1.z = input.TEXCOORD4.w;
    u_xlat16_2.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_15) + u_xlat16_1.xyz);
    u_xlat16_3.xyz = half3(half3(u_xlat16_15) * input.TEXCOORD1.xyz);
    u_xlat16_15 = dot(u_xlat16_0.xyz, (-u_xlat16_3.xyz));
    u_xlat16_16 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlat16_4.x = half(max(float(u_xlat16_16), 0.00100000005));
    u_xlat16_16 = rsqrt(u_xlat16_4.x);
    u_xlat16_2.xyz = half3(half3(u_xlat16_16) * u_xlat16_2.xyz);
    u_xlat16_16 = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_16 = clamp(u_xlat16_16, 0.0h, 1.0h);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_1.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_5 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_5 = clamp(u_xlat16_5, 0.0h, 1.0h);
    u_xlat16_10 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_1.x = half(u_xlat16_10 * u_xlat16_10);
    u_xlat16_6.x = half(u_xlat16_1.x * u_xlat16_1.x);
    u_xlat16_11 = half(u_xlat16_16 * u_xlat16_6.x + (-u_xlat16_16));
    u_xlat16_4.x = half(float(u_xlat16_11) * float(u_xlat16_16) + 1.0);
    u_xlat16_4.x = half(float(u_xlat16_4.x) * float(u_xlat16_4.x) + 1.00000001e-07);
    u_xlat16_9 = half(float(u_xlat16_6.x) * 0.318309873);
    u_xlat16_4.x = half(u_xlat16_9 / u_xlat16_4.x);
    u_xlat16_6.x = half((-float(u_xlat16_10)) * float(u_xlat16_10) + 1.0);
    u_xlat16_11 = half(abs(u_xlat16_15) * u_xlat16_6.x + u_xlat16_1.x);
    u_xlat16_1.x = half(u_xlat16_0.x * u_xlat16_6.x + u_xlat16_1.x);
    u_xlat16_1.x = half(abs(u_xlat16_15) * u_xlat16_1.x);
    u_xlat16_15 = half(-abs(float(u_xlat16_15)) + 1.0);
    u_xlat16_1.x = half(u_xlat16_0.x * u_xlat16_11 + u_xlat16_1.x);
    u_xlat16_9 = half(float(u_xlat16_1.x) + 9.99999975e-06);
    u_xlat16_9 = half(0.5 / float(u_xlat16_9));
    u_xlat16_1.x = half(u_xlat16_4.x * u_xlat16_9);
    u_xlat16_4.x = half(float(u_xlat16_1.x) * 3.14159274);
    u_xlat16_4.x = half(max(float(u_xlat16_4.x), 9.99999975e-05));
    u_xlat16_4.x = sqrt(u_xlat16_4.x);
    u_xlat16_1.x = half(u_xlat16_0.x * u_xlat16_4.x);
    u_xlat16_4.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_6.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_4.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * Globals._Color.xyz);
    u_xlat16_6.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_6.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = dot(u_xlat16_6.xyz, u_xlat16_6.xyz);
    u_xlatb19 = u_xlat16_2.x!=0.0;
    u_xlat19 = u_xlatb19 ? 1.0 : float(0.0);
    u_xlat16_1.x = half(float(u_xlat16_1.x) * u_xlat19);
    u_xlat16_2.xyz = half3(u_xlat16_1.xxx * Globals._LightColor0.xyz);
    u_xlat16_1.x = half((-float(u_xlat16_5)) + 1.0);
    u_xlat16_5 = half(u_xlat16_5 * u_xlat16_5);
    u_xlat16_5 = dot(half2(u_xlat16_5), half2(u_xlat16_10));
    u_xlat16_5 = half(float(u_xlat16_5) + -0.5);
    u_xlat16_10 = half(u_xlat16_1.x * u_xlat16_1.x);
    u_xlat16_10 = half(u_xlat16_10 * u_xlat16_10);
    u_xlat16_10 = half(u_xlat16_1.x * u_xlat16_10);
    u_xlat16_3.xyz = half3((-float3(u_xlat16_6.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_1.xyz = half3(u_xlat16_3.xyz * half3(u_xlat16_10) + u_xlat16_6.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xyz);
    u_xlat16_10 = half(u_xlat16_15 * u_xlat16_15);
    u_xlat16_10 = half(u_xlat16_10 * u_xlat16_10);
    u_xlat16_10 = half(u_xlat16_15 * u_xlat16_10);
    u_xlat16_10 = half(float(u_xlat16_5) * float(u_xlat16_10) + 1.0);
    u_xlat16_15 = half((-float(u_xlat16_0.x)) + 1.0);
    u_xlat16_16 = half(u_xlat16_15 * u_xlat16_15);
    u_xlat16_16 = half(u_xlat16_16 * u_xlat16_16);
    u_xlat16_15 = half(u_xlat16_15 * u_xlat16_16);
    u_xlat16_5 = half(float(u_xlat16_5) * float(u_xlat16_15) + 1.0);
    u_xlat16_5 = half(u_xlat16_10 * u_xlat16_5);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_5);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_15 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_2.xyz = half3(half3(u_xlat16_15) * u_xlat16_4.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_2.xyz * u_xlat16_0.xyz + u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
vec4 u_xlat0;
bool u_xlatb0;
float u_xlat3;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat3 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat3 = inversesqrt(u_xlat3);
    vs_TEXCOORD4.xyz = vec3(u_xlat3) * u_xlat0.xyz;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
vec3 u_xlat4;
float u_xlat5;
vec3 u_xlat6;
float u_xlat10;
float u_xlat11;
float u_xlat15;
float u_xlat16;
float u_xlat17;
bool u_xlatb17;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat15 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat15 = inversesqrt(u_xlat15);
    u_xlat1.x = vs_TEXCOORD2.w;
    u_xlat1.y = vs_TEXCOORD3.w;
    u_xlat1.z = vs_TEXCOORD4.w;
    u_xlat2.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat15) + u_xlat1.xyz;
    u_xlat3.xyz = vec3(u_xlat15) * vs_TEXCOORD1.xyz;
    u_xlat15 = dot(u_xlat0.xyz, (-u_xlat3.xyz));
    u_xlat16 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat16 = max(u_xlat16, 0.00100000005);
    u_xlat16 = inversesqrt(u_xlat16);
    u_xlat2.xyz = vec3(u_xlat16) * u_xlat2.xyz;
    u_xlat16 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat16 = clamp(u_xlat16, 0.0, 1.0);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat5 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat5 = clamp(u_xlat5, 0.0, 1.0);
    u_xlat10 = (-_Glossiness) + 1.0;
    u_xlat1.x = u_xlat10 * u_xlat10;
    u_xlat6.x = u_xlat1.x * u_xlat1.x;
    u_xlat11 = u_xlat16 * u_xlat6.x + (-u_xlat16);
    u_xlat11 = u_xlat11 * u_xlat16 + 1.0;
    u_xlat11 = u_xlat11 * u_xlat11 + 1.00000001e-07;
    u_xlat6.x = u_xlat6.x * 0.318309873;
    u_xlat6.x = u_xlat6.x / u_xlat11;
    u_xlat11 = (-u_xlat10) * u_xlat10 + 1.0;
    u_xlat16 = abs(u_xlat15) * u_xlat11 + u_xlat1.x;
    u_xlat1.x = u_xlat0.x * u_xlat11 + u_xlat1.x;
    u_xlat1.x = abs(u_xlat15) * u_xlat1.x;
    u_xlat15 = -abs(u_xlat15) + 1.0;
    u_xlat1.x = u_xlat0.x * u_xlat16 + u_xlat1.x;
    u_xlat1.x = u_xlat1.x + 9.99999975e-06;
    u_xlat1.x = 0.5 / u_xlat1.x;
    u_xlat1.x = u_xlat6.x * u_xlat1.x;
    u_xlat1.x = u_xlat1.x * 3.14159274;
    u_xlat1.x = max(u_xlat1.x, 9.99999975e-05);
    u_xlat1.x = sqrt(u_xlat1.x);
    u_xlat1.x = u_xlat0.x * u_xlat1.x;
    u_xlat10_2 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat6.xyz = _Color.xyz * u_xlat10_2.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat2.xyz = u_xlat10_2.xyz * _Color.xyz;
    u_xlat6.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat6.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat17 = dot(u_xlat6.xyz, u_xlat6.xyz);
    u_xlatb17 = u_xlat17!=0.0;
    u_xlat17 = u_xlatb17 ? 1.0 : float(0.0);
    u_xlat1.x = u_xlat1.x * u_xlat17;
    u_xlat3.xyz = u_xlat1.xxx * _LightColor0.xyz;
    u_xlat1.x = (-u_xlat5) + 1.0;
    u_xlat5 = u_xlat5 * u_xlat5;
    u_xlat5 = dot(vec2(u_xlat5), vec2(u_xlat10));
    u_xlat5 = u_xlat5 + -0.5;
    u_xlat10 = u_xlat1.x * u_xlat1.x;
    u_xlat10 = u_xlat10 * u_xlat10;
    u_xlat10 = u_xlat1.x * u_xlat10;
    u_xlat4.xyz = (-u_xlat6.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat1.xyz = u_xlat4.xyz * vec3(u_xlat10) + u_xlat6.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat3.xyz;
    u_xlat10 = u_xlat15 * u_xlat15;
    u_xlat10 = u_xlat10 * u_xlat10;
    u_xlat10 = u_xlat15 * u_xlat10;
    u_xlat10 = u_xlat5 * u_xlat10 + 1.0;
    u_xlat15 = (-u_xlat0.x) + 1.0;
    u_xlat16 = u_xlat15 * u_xlat15;
    u_xlat16 = u_xlat16 * u_xlat16;
    u_xlat15 = u_xlat15 * u_xlat16;
    u_xlat5 = u_xlat5 * u_xlat15 + 1.0;
    u_xlat5 = u_xlat10 * u_xlat5;
    u_xlat0.x = u_xlat0.x * u_xlat5;
    u_xlat0.xyz = u_xlat0.xxx * _LightColor0.xyz;
    u_xlat15 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat2.xyz = vec3(u_xlat15) * u_xlat2.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (336 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Matrix4x4 unity_WorldToLight at 272
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat0.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToLight[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToLight[2] * u_xlat0.zzzz + u_xlat1;
    output.TEXCOORD5 = Globals.hlslcc_mtx4x4unity_WorldToLight[3] * u_xlat0.wwww + u_xlat1;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "_LightTextureB0" to slot 2

Constant Buffer "Globals" (20 bytes) on slot 0 {
  VectorHalf4 _LightColor0 at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (2) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float2 u_xlat0;
    half3 u_xlat16_0;
    half u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half u_xlat16_7;
    bool u_xlatb7;
    half u_xlat16_10;
    half3 u_xlat16_11;
    half u_xlat16_17;
    half u_xlat16_18;
    float u_xlat21;
    bool u_xlatb21;
    half u_xlat16_23;
    half u_xlat16_24;
    u_xlat0.xy = input.TEXCOORD5.xy / input.TEXCOORD5.ww;
    u_xlat0.xy = u_xlat0.xy + float2(0.5, 0.5);
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, u_xlat0.xy).w;
    u_xlatb7 = 0.0<input.TEXCOORD5.z;
    u_xlat16_1 = (u_xlatb7) ? 1.0 : 0.0;
    u_xlat16_1 = half(u_xlat16_0.x * u_xlat16_1);
    u_xlat0.x = dot(input.TEXCOORD5.xyz, input.TEXCOORD5.xyz);
    u_xlat16_0.x = _LightTextureB0.sample(sampler_LightTextureB0, u_xlat0.xx).w;
    u_xlat16_1 = half(u_xlat16_0.x * u_xlat16_1);
    u_xlat16_2.xyz = half3(half3(u_xlat16_1) * Globals._LightColor0.xyz);
    u_xlat16_23 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_23 = rsqrt(u_xlat16_23);
    u_xlat16_3.xyz = half3(half3(u_xlat16_23) * input.TEXCOORD1.xyz);
    u_xlat16_4.x = input.TEXCOORD2.w;
    u_xlat16_4.y = input.TEXCOORD3.w;
    u_xlat16_4.z = input.TEXCOORD4.w;
    u_xlat16_23 = dot(u_xlat16_4.xyz, u_xlat16_4.xyz);
    u_xlat16_23 = rsqrt(u_xlat16_23);
    u_xlat16_5.xyz = half3(u_xlat16_4.xyz * half3(u_xlat16_23) + (-u_xlat16_3.xyz));
    u_xlat16_4.xyz = half3(half3(u_xlat16_23) * u_xlat16_4.xyz);
    u_xlat16_23 = dot(u_xlat16_5.xyz, u_xlat16_5.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_23), 0.00100000005));
    u_xlat16_23 = rsqrt(u_xlat16_0.x);
    u_xlat16_5.xyz = half3(half3(u_xlat16_23) * u_xlat16_5.xyz);
    u_xlat16_23 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_23 = rsqrt(u_xlat16_23);
    u_xlat16_6.xyz = half3(half3(u_xlat16_23) * input.TEXCOORD4.xyz);
    u_xlat16_23 = dot(u_xlat16_6.xyz, u_xlat16_5.xyz);
    u_xlat16_23 = clamp(u_xlat16_23, 0.0h, 1.0h);
    u_xlat16_24 = dot(u_xlat16_4.xyz, u_xlat16_5.xyz);
    u_xlat16_24 = clamp(u_xlat16_24, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_6.xyz, u_xlat16_4.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_3.x = dot(u_xlat16_6.xyz, (-u_xlat16_3.xyz));
    u_xlat16_10 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_17 = half(u_xlat16_10 * u_xlat16_10);
    u_xlat16_11.x = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_18 = half(u_xlat16_23 * u_xlat16_11.x + (-u_xlat16_23));
    u_xlat16_0.x = half(float(u_xlat16_18) * float(u_xlat16_23) + 1.0);
    u_xlat16_0.x = half(float(u_xlat16_0.x) * float(u_xlat16_0.x) + 1.00000001e-07);
    u_xlat16_7 = half(float(u_xlat16_11.x) * 0.318309873);
    u_xlat16_0.x = half(u_xlat16_7 / u_xlat16_0.x);
    u_xlat16_23 = half((-float(u_xlat16_10)) * float(u_xlat16_10) + 1.0);
    u_xlat16_11.x = half(abs(u_xlat16_3.x) * u_xlat16_23 + u_xlat16_17);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_23 + u_xlat16_17);
    u_xlat16_23 = half(u_xlat16_23 * abs(u_xlat16_3.x));
    u_xlat16_3.x = half(-abs(float(u_xlat16_3.x)) + 1.0);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_11.x + u_xlat16_23);
    u_xlat16_7 = half(float(u_xlat16_23) + 9.99999975e-06);
    u_xlat16_7 = half(0.5 / float(u_xlat16_7));
    u_xlat16_23 = half(u_xlat16_0.x * u_xlat16_7);
    u_xlat16_0.x = half(float(u_xlat16_23) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_0.x);
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_11.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_0.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_11.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_11.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_17 = dot(u_xlat16_11.xyz, u_xlat16_11.xyz);
    u_xlatb21 = u_xlat16_17!=0.0;
    u_xlat21 = u_xlatb21 ? 1.0 : float(0.0);
    u_xlat16_23 = half(u_xlat21 * float(u_xlat16_23));
    u_xlat16_5.xyz = half3(u_xlat16_2.xyz * half3(u_xlat16_23));
    u_xlat16_23 = half((-float(u_xlat16_24)) + 1.0);
    u_xlat16_17 = half(u_xlat16_24 * u_xlat16_24);
    u_xlat16_10 = dot(half2(u_xlat16_17), half2(u_xlat16_10));
    u_xlat16_10 = half(float(u_xlat16_10) + -0.5);
    u_xlat16_17 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_17 = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_17);
    u_xlat16_6.xyz = half3((-float3(u_xlat16_11.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_11.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_23) + u_xlat16_11.xyz);
    u_xlat16_11.xyz = half3(u_xlat16_11.xyz * u_xlat16_5.xyz);
    u_xlat16_23 = half(u_xlat16_3.x * u_xlat16_3.x);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_23 = half(u_xlat16_3.x * u_xlat16_23);
    u_xlat16_23 = half(float(u_xlat16_10) * float(u_xlat16_23) + 1.0);
    u_xlat16_3.x = half((-float(u_xlat16_4.x)) + 1.0);
    u_xlat16_17 = half(u_xlat16_3.x * u_xlat16_3.x);
    u_xlat16_17 = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_3.x = half(u_xlat16_3.x * u_xlat16_17);
    u_xlat16_3.x = half(float(u_xlat16_10) * float(u_xlat16_3.x) + 1.0);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_3.x);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_23);
    u_xlat16_2.xyz = half3(half3(u_xlat16_23) * u_xlat16_2.xyz);
    u_xlat16_23 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_0.xyz * half3(u_xlat16_23));
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_2.xyz + u_xlat16_11.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat1 = hlslcc_mtx4x4unity_WorldToLight[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_WorldToLight[2] * u_xlat0.zzzz + u_xlat1;
    vs_TEXCOORD5 = hlslcc_mtx4x4unity_WorldToLight[3] * u_xlat0.wwww + u_xlat1;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D _LightTextureB0;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
bool u_xlatb0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
vec3 u_xlat5;
float u_xlat6;
float u_xlat7;
vec3 u_xlat8;
float u_xlat13;
bool u_xlatb13;
float u_xlat14;
float u_xlat18;
float u_xlat19;
void main()
{
    u_xlat0.xy = vs_TEXCOORD5.xy / vs_TEXCOORD5.ww;
    u_xlat0.xy = u_xlat0.xy + vec2(0.5, 0.5);
    u_xlat10_0 = texture(_LightTexture0, u_xlat0.xy);
    u_xlatb0 = 0.0<vs_TEXCOORD5.z;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat0.x = u_xlat10_0.w * u_xlat0.x;
    u_xlat6 = dot(vs_TEXCOORD5.xyz, vs_TEXCOORD5.xyz);
    u_xlat10_1 = texture(_LightTextureB0, vec2(u_xlat6));
    u_xlat0.x = u_xlat0.x * u_xlat10_1.w;
    u_xlat0.xyz = u_xlat0.xxx * _LightColor0.xyz;
    u_xlat18 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat1.xyz = vec3(u_xlat18) * vs_TEXCOORD1.xyz;
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat18 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = u_xlat2.xyz * vec3(u_xlat18) + (-u_xlat1.xyz);
    u_xlat2.xyz = vec3(u_xlat18) * u_xlat2.xyz;
    u_xlat18 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat18 = max(u_xlat18, 0.00100000005);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = vec3(u_xlat18) * u_xlat3.xyz;
    u_xlat18 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat4.xyz = vec3(u_xlat18) * vs_TEXCOORD4.xyz;
    u_xlat18 = dot(u_xlat4.xyz, u_xlat3.xyz);
    u_xlat18 = clamp(u_xlat18, 0.0, 1.0);
    u_xlat19 = dot(u_xlat2.xyz, u_xlat3.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat4.xyz, u_xlat2.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat1.x = dot(u_xlat4.xyz, (-u_xlat1.xyz));
    u_xlat7 = (-_Glossiness) + 1.0;
    u_xlat13 = u_xlat7 * u_xlat7;
    u_xlat8.x = u_xlat13 * u_xlat13;
    u_xlat14 = u_xlat18 * u_xlat8.x + (-u_xlat18);
    u_xlat18 = u_xlat14 * u_xlat18 + 1.0;
    u_xlat18 = u_xlat18 * u_xlat18 + 1.00000001e-07;
    u_xlat8.x = u_xlat8.x * 0.318309873;
    u_xlat18 = u_xlat8.x / u_xlat18;
    u_xlat8.x = (-u_xlat7) * u_xlat7 + 1.0;
    u_xlat14 = abs(u_xlat1.x) * u_xlat8.x + u_xlat13;
    u_xlat13 = u_xlat2.x * u_xlat8.x + u_xlat13;
    u_xlat13 = u_xlat13 * abs(u_xlat1.x);
    u_xlat1.x = -abs(u_xlat1.x) + 1.0;
    u_xlat13 = u_xlat2.x * u_xlat14 + u_xlat13;
    u_xlat13 = u_xlat13 + 9.99999975e-06;
    u_xlat13 = 0.5 / u_xlat13;
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat18 = u_xlat18 * 3.14159274;
    u_xlat18 = max(u_xlat18, 9.99999975e-05);
    u_xlat18 = sqrt(u_xlat18);
    u_xlat18 = u_xlat2.x * u_xlat18;
    u_xlat10_3 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat8.xyz = _Color.xyz * u_xlat10_3.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat3.xyz = u_xlat10_3.xyz * _Color.xyz;
    u_xlat8.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat8.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat13 = dot(u_xlat8.xyz, u_xlat8.xyz);
    u_xlatb13 = u_xlat13!=0.0;
    u_xlat13 = u_xlatb13 ? 1.0 : float(0.0);
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat4.xyz = u_xlat0.xyz * vec3(u_xlat18);
    u_xlat18 = (-u_xlat19) + 1.0;
    u_xlat13 = u_xlat19 * u_xlat19;
    u_xlat7 = dot(vec2(u_xlat13), vec2(u_xlat7));
    u_xlat7 = u_xlat7 + -0.5;
    u_xlat13 = u_xlat18 * u_xlat18;
    u_xlat13 = u_xlat13 * u_xlat13;
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat5.xyz = (-u_xlat8.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat8.xyz = u_xlat5.xyz * vec3(u_xlat18) + u_xlat8.xyz;
    u_xlat8.xyz = u_xlat8.xyz * u_xlat4.xyz;
    u_xlat18 = u_xlat1.x * u_xlat1.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat18 = u_xlat1.x * u_xlat18;
    u_xlat18 = u_xlat7 * u_xlat18 + 1.0;
    u_xlat1.x = (-u_xlat2.x) + 1.0;
    u_xlat13 = u_xlat1.x * u_xlat1.x;
    u_xlat13 = u_xlat13 * u_xlat13;
    u_xlat1.x = u_xlat1.x * u_xlat13;
    u_xlat1.x = u_xlat7 * u_xlat1.x + 1.0;
    u_xlat18 = u_xlat18 * u_xlat1.x;
    u_xlat18 = u_xlat2.x * u_xlat18;
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat18) * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat0.xyz + u_xlat8.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: POINT_COOKIE 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (336 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Matrix4x4 unity_WorldToLight at 272
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat0.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    output.TEXCOORD5.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTextureB0" to slot 1
Set CUBE Texture "_LightTexture0" to slot 2

Constant Buffer "Globals" (20 bytes) on slot 0 {
  VectorHalf4 _LightColor0 at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (1) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (1) ]] ,
    texturecube<half, access::sample > _LightTexture0 [[ texture (2) ]] ,
    sampler sampler_LightTexture0 [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half u_xlat16_5;
    half3 u_xlat16_6;
    half u_xlat16_7;
    half3 u_xlat16_8;
    half u_xlat16_10;
    half u_xlat16_14;
    half u_xlat16_15;
    half u_xlat16_21;
    half u_xlat16_22;
    float u_xlat24;
    half u_xlat16_24;
    bool u_xlatb24;
    u_xlat16_0.x = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD1.xyz);
    u_xlat16_1.x = input.TEXCOORD2.w;
    u_xlat16_1.y = input.TEXCOORD3.w;
    u_xlat16_1.z = input.TEXCOORD4.w;
    u_xlat16_21 = dot(u_xlat16_1.xyz, u_xlat16_1.xyz);
    u_xlat16_21 = rsqrt(u_xlat16_21);
    u_xlat16_2.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_21) + (-u_xlat16_0.xyz));
    u_xlat16_1.xyz = half3(half3(u_xlat16_21) * u_xlat16_1.xyz);
    u_xlat16_21 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlat16_3.x = half(max(float(u_xlat16_21), 0.00100000005));
    u_xlat16_21 = rsqrt(u_xlat16_3.x);
    u_xlat16_2.xyz = half3(half3(u_xlat16_21) * u_xlat16_2.xyz);
    u_xlat16_21 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_21 = rsqrt(u_xlat16_21);
    u_xlat16_4.xyz = half3(half3(u_xlat16_21) * input.TEXCOORD4.xyz);
    u_xlat16_21 = dot(u_xlat16_4.xyz, u_xlat16_2.xyz);
    u_xlat16_21 = clamp(u_xlat16_21, 0.0h, 1.0h);
    u_xlat16_22 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_22 = clamp(u_xlat16_22, 0.0h, 1.0h);
    u_xlat16_1.x = dot(u_xlat16_4.xyz, u_xlat16_1.xyz);
    u_xlat16_1.x = clamp(u_xlat16_1.x, 0.0h, 1.0h);
    u_xlat16_0.x = dot(u_xlat16_4.xyz, (-u_xlat16_0.xyz));
    u_xlat16_7 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_14 = half(u_xlat16_7 * u_xlat16_7);
    u_xlat16_8.x = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_15 = half(u_xlat16_21 * u_xlat16_8.x + (-u_xlat16_21));
    u_xlat16_3.x = half(float(u_xlat16_15) * float(u_xlat16_21) + 1.0);
    u_xlat16_3.x = half(float(u_xlat16_3.x) * float(u_xlat16_3.x) + 1.00000001e-07);
    u_xlat16_10 = half(float(u_xlat16_8.x) * 0.318309873);
    u_xlat16_3.x = half(u_xlat16_10 / u_xlat16_3.x);
    u_xlat16_21 = half((-float(u_xlat16_7)) * float(u_xlat16_7) + 1.0);
    u_xlat16_8.x = half(abs(u_xlat16_0.x) * u_xlat16_21 + u_xlat16_14);
    u_xlat16_14 = half(u_xlat16_1.x * u_xlat16_21 + u_xlat16_14);
    u_xlat16_14 = half(u_xlat16_14 * abs(u_xlat16_0.x));
    u_xlat16_0.x = half(-abs(float(u_xlat16_0.x)) + 1.0);
    u_xlat16_14 = half(u_xlat16_1.x * u_xlat16_8.x + u_xlat16_14);
    u_xlat16_10 = half(float(u_xlat16_14) + 9.99999975e-06);
    u_xlat16_10 = half(0.5 / float(u_xlat16_10));
    u_xlat16_14 = half(u_xlat16_3.x * u_xlat16_10);
    u_xlat16_3.x = half(float(u_xlat16_14) * 3.14159274);
    u_xlat16_3.x = half(max(float(u_xlat16_3.x), 9.99999975e-05));
    u_xlat16_3.x = sqrt(u_xlat16_3.x);
    u_xlat16_14 = half(u_xlat16_1.x * u_xlat16_3.x);
    u_xlat16_3.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_3.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_21 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlatb24 = u_xlat16_21!=0.0;
    u_xlat24 = u_xlatb24 ? 1.0 : float(0.0);
    u_xlat16_14 = half(float(u_xlat16_14) * u_xlat24);
    u_xlat24 = dot(input.TEXCOORD5.xyz, input.TEXCOORD5.xyz);
    u_xlat16_24 = _LightTextureB0.sample(sampler_LightTextureB0, float2(u_xlat24)).w;
    u_xlat16_5 = _LightTexture0.sample(sampler_LightTexture0, input.TEXCOORD5.xyz).w;
    u_xlat16_24 = half(u_xlat16_24 * u_xlat16_5);
    u_xlat16_4.xyz = half3(half3(u_xlat16_24) * Globals._LightColor0.xyz);
    u_xlat16_6.xyz = half3(half3(u_xlat16_14) * u_xlat16_4.xyz);
    u_xlat16_14 = half((-float(u_xlat16_22)) + 1.0);
    u_xlat16_21 = half(u_xlat16_22 * u_xlat16_22);
    u_xlat16_7 = dot(half2(u_xlat16_21), half2(u_xlat16_7));
    u_xlat16_7 = half(float(u_xlat16_7) + -0.5);
    u_xlat16_21 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_21 = half(u_xlat16_21 * u_xlat16_21);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_21);
    u_xlat16_8.xyz = half3((-float3(u_xlat16_2.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_14) + u_xlat16_2.xyz);
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * u_xlat16_6.xyz);
    u_xlat16_14 = half(u_xlat16_0.x * u_xlat16_0.x);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_14);
    u_xlat16_0.x = half(float(u_xlat16_7) * float(u_xlat16_0.x) + 1.0);
    u_xlat16_14 = half((-float(u_xlat16_1.x)) + 1.0);
    u_xlat16_21 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_21 = half(u_xlat16_21 * u_xlat16_21);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_21);
    u_xlat16_7 = half(float(u_xlat16_7) * float(u_xlat16_14) + 1.0);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_7);
    u_xlat16_0.x = half(u_xlat16_1.x * u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * u_xlat16_4.xyz);
    u_xlat16_21 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_2.xyz = half3(half3(u_xlat16_21) * u_xlat16_3.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_2.xyz * u_xlat16_0.xyz + u_xlat16_8.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    vs_TEXCOORD5.xyz = hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTextureB0;
uniform  samplerCube _LightTexture0;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
lowp vec4 u_xlat10_5;
float u_xlat6;
vec3 u_xlat7;
float u_xlat12;
float u_xlat13;
float u_xlat18;
mediump float u_xlat16_18;
bool u_xlatb18;
float u_xlat19;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD1.xyz;
    u_xlat1.x = vs_TEXCOORD2.w;
    u_xlat1.y = vs_TEXCOORD3.w;
    u_xlat1.z = vs_TEXCOORD4.w;
    u_xlat18 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat2.xyz = u_xlat1.xyz * vec3(u_xlat18) + (-u_xlat0.xyz);
    u_xlat1.xyz = vec3(u_xlat18) * u_xlat1.xyz;
    u_xlat18 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat18 = max(u_xlat18, 0.00100000005);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat2.xyz = vec3(u_xlat18) * u_xlat2.xyz;
    u_xlat18 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = vec3(u_xlat18) * vs_TEXCOORD4.xyz;
    u_xlat18 = dot(u_xlat3.xyz, u_xlat2.xyz);
    u_xlat18 = clamp(u_xlat18, 0.0, 1.0);
    u_xlat19 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat1.x = dot(u_xlat3.xyz, u_xlat1.xyz);
    u_xlat1.x = clamp(u_xlat1.x, 0.0, 1.0);
    u_xlat0.x = dot(u_xlat3.xyz, (-u_xlat0.xyz));
    u_xlat6 = (-_Glossiness) + 1.0;
    u_xlat12 = u_xlat6 * u_xlat6;
    u_xlat7.x = u_xlat12 * u_xlat12;
    u_xlat13 = u_xlat18 * u_xlat7.x + (-u_xlat18);
    u_xlat18 = u_xlat13 * u_xlat18 + 1.0;
    u_xlat18 = u_xlat18 * u_xlat18 + 1.00000001e-07;
    u_xlat7.x = u_xlat7.x * 0.318309873;
    u_xlat18 = u_xlat7.x / u_xlat18;
    u_xlat7.x = (-u_xlat6) * u_xlat6 + 1.0;
    u_xlat13 = abs(u_xlat0.x) * u_xlat7.x + u_xlat12;
    u_xlat12 = u_xlat1.x * u_xlat7.x + u_xlat12;
    u_xlat12 = u_xlat12 * abs(u_xlat0.x);
    u_xlat0.x = -abs(u_xlat0.x) + 1.0;
    u_xlat12 = u_xlat1.x * u_xlat13 + u_xlat12;
    u_xlat12 = u_xlat12 + 9.99999975e-06;
    u_xlat12 = 0.5 / u_xlat12;
    u_xlat12 = u_xlat18 * u_xlat12;
    u_xlat12 = u_xlat12 * 3.14159274;
    u_xlat12 = max(u_xlat12, 9.99999975e-05);
    u_xlat12 = sqrt(u_xlat12);
    u_xlat12 = u_xlat1.x * u_xlat12;
    u_xlat10_2 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat3.xyz = _Color.xyz * u_xlat10_2.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat2.xyz = u_xlat10_2.xyz * _Color.xyz;
    u_xlat3.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat3.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat18 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlatb18 = u_xlat18!=0.0;
    u_xlat18 = u_xlatb18 ? 1.0 : float(0.0);
    u_xlat12 = u_xlat18 * u_xlat12;
    u_xlat18 = dot(vs_TEXCOORD5.xyz, vs_TEXCOORD5.xyz);
    u_xlat10_4 = texture(_LightTextureB0, vec2(u_xlat18));
    u_xlat10_5 = texture(_LightTexture0, vs_TEXCOORD5.xyz);
    u_xlat16_18 = u_xlat10_4.w * u_xlat10_5.w;
    u_xlat4.xyz = vec3(u_xlat16_18) * _LightColor0.xyz;
    u_xlat5.xyz = vec3(u_xlat12) * u_xlat4.xyz;
    u_xlat12 = (-u_xlat19) + 1.0;
    u_xlat18 = u_xlat19 * u_xlat19;
    u_xlat6 = dot(vec2(u_xlat18), vec2(u_xlat6));
    u_xlat6 = u_xlat6 + -0.5;
    u_xlat18 = u_xlat12 * u_xlat12;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat12 = u_xlat12 * u_xlat18;
    u_xlat7.xyz = (-u_xlat3.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat7.xyz = u_xlat7.xyz * vec3(u_xlat12) + u_xlat3.xyz;
    u_xlat7.xyz = u_xlat7.xyz * u_xlat5.xyz;
    u_xlat12 = u_xlat0.x * u_xlat0.x;
    u_xlat12 = u_xlat12 * u_xlat12;
    u_xlat0.x = u_xlat0.x * u_xlat12;
    u_xlat0.x = u_xlat6 * u_xlat0.x + 1.0;
    u_xlat12 = (-u_xlat1.x) + 1.0;
    u_xlat18 = u_xlat12 * u_xlat12;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat12 = u_xlat12 * u_xlat18;
    u_xlat6 = u_xlat6 * u_xlat12 + 1.0;
    u_xlat0.x = u_xlat0.x * u_xlat6;
    u_xlat0.x = u_xlat1.x * u_xlat0.x;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat4.xyz;
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat2.xyz = vec3(u_xlat18) * u_xlat2.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat7.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (336 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Matrix4x4 unity_WorldToLight at 272
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float2 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat0.xyw = (-u_xlat0.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1.xy = u_xlat0.yy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat0.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xy * u_xlat0.xx + u_xlat1.xy;
    u_xlat0.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xy * u_xlat0.zz + u_xlat0.xy;
    output.TEXCOORD5.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[3].xy * u_xlat0.ww + u_xlat0.xy;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1

Constant Buffer "Globals" (20 bytes) on slot 0 {
  VectorHalf4 _LightColor0 at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float2 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    half u_xlat16_6;
    half3 u_xlat16_7;
    half u_xlat16_10;
    half u_xlat16_12;
    half u_xlat16_13;
    half u_xlat16_18;
    half u_xlat16_19;
    float u_xlat22;
    half u_xlat16_22;
    bool u_xlatb22;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_18 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_18 = rsqrt(u_xlat16_18);
    u_xlat16_1.x = input.TEXCOORD2.w;
    u_xlat16_1.y = input.TEXCOORD3.w;
    u_xlat16_1.z = input.TEXCOORD4.w;
    u_xlat16_2.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_18) + u_xlat16_1.xyz);
    u_xlat16_3.xyz = half3(half3(u_xlat16_18) * input.TEXCOORD1.xyz);
    u_xlat16_18 = dot(u_xlat16_0.xyz, (-u_xlat16_3.xyz));
    u_xlat16_19 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlat16_4.x = half(max(float(u_xlat16_19), 0.00100000005));
    u_xlat16_19 = rsqrt(u_xlat16_4.x);
    u_xlat16_2.xyz = half3(half3(u_xlat16_19) * u_xlat16_2.xyz);
    u_xlat16_19 = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_19 = clamp(u_xlat16_19, 0.0h, 1.0h);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_1.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_6 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_6 = clamp(u_xlat16_6, 0.0h, 1.0h);
    u_xlat16_12 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_1.x = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_7.x = half(u_xlat16_1.x * u_xlat16_1.x);
    u_xlat16_13 = half(u_xlat16_19 * u_xlat16_7.x + (-u_xlat16_19));
    u_xlat16_4.x = half(float(u_xlat16_13) * float(u_xlat16_19) + 1.0);
    u_xlat16_4.x = half(float(u_xlat16_4.x) * float(u_xlat16_4.x) + 1.00000001e-07);
    u_xlat16_10 = half(float(u_xlat16_7.x) * 0.318309873);
    u_xlat16_4.x = half(u_xlat16_10 / u_xlat16_4.x);
    u_xlat16_7.x = half((-float(u_xlat16_12)) * float(u_xlat16_12) + 1.0);
    u_xlat16_13 = half(abs(u_xlat16_18) * u_xlat16_7.x + u_xlat16_1.x);
    u_xlat16_1.x = half(u_xlat16_0.x * u_xlat16_7.x + u_xlat16_1.x);
    u_xlat16_1.x = half(abs(u_xlat16_18) * u_xlat16_1.x);
    u_xlat16_18 = half(-abs(float(u_xlat16_18)) + 1.0);
    u_xlat16_1.x = half(u_xlat16_0.x * u_xlat16_13 + u_xlat16_1.x);
    u_xlat16_10 = half(float(u_xlat16_1.x) + 9.99999975e-06);
    u_xlat16_10 = half(0.5 / float(u_xlat16_10));
    u_xlat16_1.x = half(u_xlat16_4.x * u_xlat16_10);
    u_xlat16_4.x = half(float(u_xlat16_1.x) * 3.14159274);
    u_xlat16_4.x = half(max(float(u_xlat16_4.x), 9.99999975e-05));
    u_xlat16_4.x = sqrt(u_xlat16_4.x);
    u_xlat16_1.x = half(u_xlat16_0.x * u_xlat16_4.x);
    u_xlat16_4.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_7.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_4.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * Globals._Color.xyz);
    u_xlat16_7.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_7.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = dot(u_xlat16_7.xyz, u_xlat16_7.xyz);
    u_xlatb22 = u_xlat16_2.x!=0.0;
    u_xlat22 = u_xlatb22 ? 1.0 : float(0.0);
    u_xlat16_1.x = half(float(u_xlat16_1.x) * u_xlat22);
    u_xlat16_22 = _LightTexture0.sample(sampler_LightTexture0, input.TEXCOORD5.xy).w;
    u_xlat16_2.xyz = half3(half3(u_xlat16_22) * Globals._LightColor0.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_1.xxx * u_xlat16_2.xyz);
    u_xlat16_1.x = half((-float(u_xlat16_6)) + 1.0);
    u_xlat16_6 = half(u_xlat16_6 * u_xlat16_6);
    u_xlat16_6 = dot(half2(u_xlat16_6), half2(u_xlat16_12));
    u_xlat16_6 = half(float(u_xlat16_6) + -0.5);
    u_xlat16_12 = half(u_xlat16_1.x * u_xlat16_1.x);
    u_xlat16_12 = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_12 = half(u_xlat16_1.x * u_xlat16_12);
    u_xlat16_5.xyz = half3((-float3(u_xlat16_7.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_1.xyz = half3(u_xlat16_5.xyz * half3(u_xlat16_12) + u_xlat16_7.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_1.xyz * u_xlat16_3.xyz);
    u_xlat16_12 = half(u_xlat16_18 * u_xlat16_18);
    u_xlat16_12 = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_12 = half(u_xlat16_18 * u_xlat16_12);
    u_xlat16_12 = half(float(u_xlat16_6) * float(u_xlat16_12) + 1.0);
    u_xlat16_18 = half((-float(u_xlat16_0.x)) + 1.0);
    u_xlat16_19 = half(u_xlat16_18 * u_xlat16_18);
    u_xlat16_19 = half(u_xlat16_19 * u_xlat16_19);
    u_xlat16_18 = half(u_xlat16_18 * u_xlat16_19);
    u_xlat16_6 = half(float(u_xlat16_6) * float(u_xlat16_18) + 1.0);
    u_xlat16_6 = half(u_xlat16_12 * u_xlat16_6);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_6);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * u_xlat16_2.xyz);
    u_xlat16_18 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_2.xyz = half3(half3(u_xlat16_18) * u_xlat16_4.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_2.xyz * u_xlat16_0.xyz + u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec2 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec2 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1.xy = u_xlat0.yy * hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat0.xy = hlslcc_mtx4x4unity_WorldToLight[0].xy * u_xlat0.xx + u_xlat1.xy;
    u_xlat0.xy = hlslcc_mtx4x4unity_WorldToLight[2].xy * u_xlat0.zz + u_xlat0.xy;
    vs_TEXCOORD5.xy = hlslcc_mtx4x4unity_WorldToLight[3].xy * u_xlat0.ww + u_xlat0.xy;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec2 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
vec3 u_xlat5;
float u_xlat6;
vec3 u_xlat7;
float u_xlat12;
float u_xlat13;
float u_xlat18;
float u_xlat19;
float u_xlat20;
bool u_xlatb20;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat18 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat1.x = vs_TEXCOORD2.w;
    u_xlat1.y = vs_TEXCOORD3.w;
    u_xlat1.z = vs_TEXCOORD4.w;
    u_xlat2.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat18) + u_xlat1.xyz;
    u_xlat3.xyz = vec3(u_xlat18) * vs_TEXCOORD1.xyz;
    u_xlat18 = dot(u_xlat0.xyz, (-u_xlat3.xyz));
    u_xlat19 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat19 = max(u_xlat19, 0.00100000005);
    u_xlat19 = inversesqrt(u_xlat19);
    u_xlat2.xyz = vec3(u_xlat19) * u_xlat2.xyz;
    u_xlat19 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat6 = clamp(u_xlat6, 0.0, 1.0);
    u_xlat12 = (-_Glossiness) + 1.0;
    u_xlat1.x = u_xlat12 * u_xlat12;
    u_xlat7.x = u_xlat1.x * u_xlat1.x;
    u_xlat13 = u_xlat19 * u_xlat7.x + (-u_xlat19);
    u_xlat13 = u_xlat13 * u_xlat19 + 1.0;
    u_xlat13 = u_xlat13 * u_xlat13 + 1.00000001e-07;
    u_xlat7.x = u_xlat7.x * 0.318309873;
    u_xlat7.x = u_xlat7.x / u_xlat13;
    u_xlat13 = (-u_xlat12) * u_xlat12 + 1.0;
    u_xlat19 = abs(u_xlat18) * u_xlat13 + u_xlat1.x;
    u_xlat1.x = u_xlat0.x * u_xlat13 + u_xlat1.x;
    u_xlat1.x = abs(u_xlat18) * u_xlat1.x;
    u_xlat18 = -abs(u_xlat18) + 1.0;
    u_xlat1.x = u_xlat0.x * u_xlat19 + u_xlat1.x;
    u_xlat1.x = u_xlat1.x + 9.99999975e-06;
    u_xlat1.x = 0.5 / u_xlat1.x;
    u_xlat1.x = u_xlat7.x * u_xlat1.x;
    u_xlat1.x = u_xlat1.x * 3.14159274;
    u_xlat1.x = max(u_xlat1.x, 9.99999975e-05);
    u_xlat1.x = sqrt(u_xlat1.x);
    u_xlat1.x = u_xlat0.x * u_xlat1.x;
    u_xlat10_2 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat7.xyz = _Color.xyz * u_xlat10_2.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat2.xyz = u_xlat10_2.xyz * _Color.xyz;
    u_xlat7.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat7.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat20 = dot(u_xlat7.xyz, u_xlat7.xyz);
    u_xlatb20 = u_xlat20!=0.0;
    u_xlat20 = u_xlatb20 ? 1.0 : float(0.0);
    u_xlat1.x = u_xlat1.x * u_xlat20;
    u_xlat10_3 = texture(_LightTexture0, vs_TEXCOORD5.xy);
    u_xlat3.xyz = u_xlat10_3.www * _LightColor0.xyz;
    u_xlat4.xyz = u_xlat1.xxx * u_xlat3.xyz;
    u_xlat1.x = (-u_xlat6) + 1.0;
    u_xlat6 = u_xlat6 * u_xlat6;
    u_xlat6 = dot(vec2(u_xlat6), vec2(u_xlat12));
    u_xlat6 = u_xlat6 + -0.5;
    u_xlat12 = u_xlat1.x * u_xlat1.x;
    u_xlat12 = u_xlat12 * u_xlat12;
    u_xlat12 = u_xlat1.x * u_xlat12;
    u_xlat5.xyz = (-u_xlat7.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat1.xyz = u_xlat5.xyz * vec3(u_xlat12) + u_xlat7.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat4.xyz;
    u_xlat12 = u_xlat18 * u_xlat18;
    u_xlat12 = u_xlat12 * u_xlat12;
    u_xlat12 = u_xlat18 * u_xlat12;
    u_xlat12 = u_xlat6 * u_xlat12 + 1.0;
    u_xlat18 = (-u_xlat0.x) + 1.0;
    u_xlat19 = u_xlat18 * u_xlat18;
    u_xlat19 = u_xlat19 * u_xlat19;
    u_xlat18 = u_xlat18 * u_xlat19;
    u_xlat6 = u_xlat6 * u_xlat18 + 1.0;
    u_xlat6 = u_xlat12 * u_xlat6;
    u_xlat0.x = u_xlat0.x * u_xlat6;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat3.xyz;
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat2.xyz = vec3(u_xlat18) * u_xlat2.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: SPOT SHADOWS_DEPTH 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (592 bytes) on slot 0 {
  Matrix4x4 unity_WorldToShadow[4] at 32
  Matrix4x4 glstate_matrix_mvp at 288
  Matrix4x4 unity_ObjectToWorld at 352
  Matrix4x4 unity_WorldToObject at 416
  Matrix4x4 unity_WorldToLight at 528
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 480
  Vector4 _DetailAlbedoMap_ST at 496
  ScalarHalf _UVSec at 512
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat0.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToLight[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToLight[2] * u_xlat0.zzzz + u_xlat1;
    output.TEXCOORD5 = Globals.hlslcc_mtx4x4unity_WorldToLight[3] * u_xlat0.wwww + u_xlat1;
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_WorldToShadow[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToShadow[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToShadow[2] * u_xlat0.zzzz + u_xlat1;
    output.TEXCOORD6 = Globals.hlslcc_mtx4x4unity_WorldToShadow[3] * u_xlat0.wwww + u_xlat1;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "_LightTextureB0" to slot 2
Set 2D Texture "_ShadowMapTexture" to slot 3

Constant Buffer "Globals" (28 bytes) on slot 0 {
  VectorHalf4 _LightShadowData at 0
  VectorHalf4 _LightColor0 at 8
  VectorHalf4 _Color at 16
  ScalarHalf _Metallic at 24
  ScalarHalf _Glossiness at 26
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightShadowData;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

constexpr sampler _mtl_xl_shadow_sampler(address::clamp_to_edge, filter::linear, compare_func::greater_equal);
fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (2) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (2) ]] ,
    depth2d<float, access::sample > _ShadowMapTexture [[ texture (3) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float3 u_xlat0;
    half3 u_xlat16_0;
    half u_xlat10_0;
    half u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half u_xlat16_7;
    bool u_xlatb7;
    half u_xlat16_10;
    half3 u_xlat16_11;
    half u_xlat16_17;
    half u_xlat16_18;
    float u_xlat21;
    bool u_xlatb21;
    half u_xlat16_23;
    half u_xlat16_24;
    u_xlat0.xy = input.TEXCOORD5.xy / input.TEXCOORD5.ww;
    u_xlat0.xy = u_xlat0.xy + float2(0.5, 0.5);
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, u_xlat0.xy).w;
    u_xlatb7 = 0.0<input.TEXCOORD5.z;
    u_xlat16_1 = (u_xlatb7) ? 1.0 : 0.0;
    u_xlat16_1 = half(u_xlat16_0.x * u_xlat16_1);
    u_xlat0.x = dot(input.TEXCOORD5.xyz, input.TEXCOORD5.xyz);
    u_xlat16_0.x = _LightTextureB0.sample(sampler_LightTextureB0, u_xlat0.xx).w;
    u_xlat16_1 = half(u_xlat16_0.x * u_xlat16_1);
    u_xlat0.xyz = input.TEXCOORD6.xyz / input.TEXCOORD6.www;
    u_xlat10_0 = half(_ShadowMapTexture.sample_compare(_mtl_xl_shadow_sampler, u_xlat0.xy, saturate(u_xlat0.z), level(0.0)));
    u_xlat16_2.x = half((-float(Globals._LightShadowData.x)) + 1.0);
    u_xlat16_2.x = half(float(u_xlat10_0) * float(u_xlat16_2.x) + float(Globals._LightShadowData.x));
    u_xlat16_1 = half(u_xlat16_1 * u_xlat16_2.x);
    u_xlat16_2.xyz = half3(half3(u_xlat16_1) * Globals._LightColor0.xyz);
    u_xlat16_23 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_23 = rsqrt(u_xlat16_23);
    u_xlat16_3.xyz = half3(half3(u_xlat16_23) * input.TEXCOORD1.xyz);
    u_xlat16_4.x = input.TEXCOORD2.w;
    u_xlat16_4.y = input.TEXCOORD3.w;
    u_xlat16_4.z = input.TEXCOORD4.w;
    u_xlat16_23 = dot(u_xlat16_4.xyz, u_xlat16_4.xyz);
    u_xlat16_23 = rsqrt(u_xlat16_23);
    u_xlat16_5.xyz = half3(u_xlat16_4.xyz * half3(u_xlat16_23) + (-u_xlat16_3.xyz));
    u_xlat16_4.xyz = half3(half3(u_xlat16_23) * u_xlat16_4.xyz);
    u_xlat16_23 = dot(u_xlat16_5.xyz, u_xlat16_5.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_23), 0.00100000005));
    u_xlat16_23 = rsqrt(u_xlat16_0.x);
    u_xlat16_5.xyz = half3(half3(u_xlat16_23) * u_xlat16_5.xyz);
    u_xlat16_23 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_23 = rsqrt(u_xlat16_23);
    u_xlat16_6.xyz = half3(half3(u_xlat16_23) * input.TEXCOORD4.xyz);
    u_xlat16_23 = dot(u_xlat16_6.xyz, u_xlat16_5.xyz);
    u_xlat16_23 = clamp(u_xlat16_23, 0.0h, 1.0h);
    u_xlat16_24 = dot(u_xlat16_4.xyz, u_xlat16_5.xyz);
    u_xlat16_24 = clamp(u_xlat16_24, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_6.xyz, u_xlat16_4.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_3.x = dot(u_xlat16_6.xyz, (-u_xlat16_3.xyz));
    u_xlat16_10 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_17 = half(u_xlat16_10 * u_xlat16_10);
    u_xlat16_11.x = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_18 = half(u_xlat16_23 * u_xlat16_11.x + (-u_xlat16_23));
    u_xlat16_0.x = half(float(u_xlat16_18) * float(u_xlat16_23) + 1.0);
    u_xlat16_0.x = half(float(u_xlat16_0.x) * float(u_xlat16_0.x) + 1.00000001e-07);
    u_xlat16_7 = half(float(u_xlat16_11.x) * 0.318309873);
    u_xlat16_0.x = half(u_xlat16_7 / u_xlat16_0.x);
    u_xlat16_23 = half((-float(u_xlat16_10)) * float(u_xlat16_10) + 1.0);
    u_xlat16_11.x = half(abs(u_xlat16_3.x) * u_xlat16_23 + u_xlat16_17);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_23 + u_xlat16_17);
    u_xlat16_23 = half(u_xlat16_23 * abs(u_xlat16_3.x));
    u_xlat16_3.x = half(-abs(float(u_xlat16_3.x)) + 1.0);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_11.x + u_xlat16_23);
    u_xlat16_7 = half(float(u_xlat16_23) + 9.99999975e-06);
    u_xlat16_7 = half(0.5 / float(u_xlat16_7));
    u_xlat16_23 = half(u_xlat16_0.x * u_xlat16_7);
    u_xlat16_0.x = half(float(u_xlat16_23) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_0.x);
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_11.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_0.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_11.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_11.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_17 = dot(u_xlat16_11.xyz, u_xlat16_11.xyz);
    u_xlatb21 = u_xlat16_17!=0.0;
    u_xlat21 = u_xlatb21 ? 1.0 : float(0.0);
    u_xlat16_23 = half(u_xlat21 * float(u_xlat16_23));
    u_xlat16_5.xyz = half3(u_xlat16_2.xyz * half3(u_xlat16_23));
    u_xlat16_23 = half((-float(u_xlat16_24)) + 1.0);
    u_xlat16_17 = half(u_xlat16_24 * u_xlat16_24);
    u_xlat16_10 = dot(half2(u_xlat16_17), half2(u_xlat16_10));
    u_xlat16_10 = half(float(u_xlat16_10) + -0.5);
    u_xlat16_17 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_17 = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_17);
    u_xlat16_6.xyz = half3((-float3(u_xlat16_11.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_11.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_23) + u_xlat16_11.xyz);
    u_xlat16_11.xyz = half3(u_xlat16_11.xyz * u_xlat16_5.xyz);
    u_xlat16_23 = half(u_xlat16_3.x * u_xlat16_3.x);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_23 = half(u_xlat16_3.x * u_xlat16_23);
    u_xlat16_23 = half(float(u_xlat16_10) * float(u_xlat16_23) + 1.0);
    u_xlat16_3.x = half((-float(u_xlat16_4.x)) + 1.0);
    u_xlat16_17 = half(u_xlat16_3.x * u_xlat16_3.x);
    u_xlat16_17 = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_3.x = half(u_xlat16_3.x * u_xlat16_17);
    u_xlat16_3.x = half(float(u_xlat16_10) * float(u_xlat16_3.x) + 1.0);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_3.x);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_23);
    u_xlat16_2.xyz = half3(half3(u_xlat16_23) * u_xlat16_2.xyz);
    u_xlat16_23 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_0.xyz * half3(u_xlat16_23));
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_2.xyz + u_xlat16_11.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToShadow[16];
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat1 = hlslcc_mtx4x4unity_WorldToLight[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_WorldToLight[2] * u_xlat0.zzzz + u_xlat1;
    vs_TEXCOORD5 = hlslcc_mtx4x4unity_WorldToLight[3] * u_xlat0.wwww + u_xlat1;
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_WorldToShadow[1];
    u_xlat1 = hlslcc_mtx4x4unity_WorldToShadow[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_WorldToShadow[2] * u_xlat0.zzzz + u_xlat1;
    vs_TEXCOORD6 = hlslcc_mtx4x4unity_WorldToShadow[3] * u_xlat0.wwww + u_xlat1;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightShadowData;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D _LightTextureB0;
uniform  sampler2DShadow hlslcc_zcmp_ShadowMapTexture;
uniform  sampler2D _ShadowMapTexture;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
lowp vec4 u_xlat10_0;
bool u_xlatb0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
vec3 u_xlat5;
vec3 u_xlat6;
lowp float u_xlat10_6;
float u_xlat7;
vec3 u_xlat8;
float u_xlat12;
float u_xlat13;
bool u_xlatb13;
float u_xlat14;
float u_xlat18;
float u_xlat19;
void main()
{
    u_xlat0.xy = vs_TEXCOORD5.xy / vs_TEXCOORD5.ww;
    u_xlat0.xy = u_xlat0.xy + vec2(0.5, 0.5);
    u_xlat10_0 = texture(_LightTexture0, u_xlat0.xy);
    u_xlatb0 = 0.0<vs_TEXCOORD5.z;
    u_xlat0.x = u_xlatb0 ? 1.0 : float(0.0);
    u_xlat0.x = u_xlat10_0.w * u_xlat0.x;
    u_xlat6.x = dot(vs_TEXCOORD5.xyz, vs_TEXCOORD5.xyz);
    u_xlat10_1 = texture(_LightTextureB0, u_xlat6.xx);
    u_xlat0.x = u_xlat0.x * u_xlat10_1.w;
    u_xlat6.xyz = vs_TEXCOORD6.xyz / vs_TEXCOORD6.www;
    vec3 txVec0 = vec3(u_xlat6.xy,u_xlat6.z);
    u_xlat10_6 = textureLod(hlslcc_zcmp_ShadowMapTexture, txVec0, 0.0);
    u_xlat12 = (-_LightShadowData.x) + 1.0;
    u_xlat6.x = u_xlat10_6 * u_xlat12 + _LightShadowData.x;
    u_xlat0.x = u_xlat6.x * u_xlat0.x;
    u_xlat0.xyz = u_xlat0.xxx * _LightColor0.xyz;
    u_xlat18 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat1.xyz = vec3(u_xlat18) * vs_TEXCOORD1.xyz;
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat18 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = u_xlat2.xyz * vec3(u_xlat18) + (-u_xlat1.xyz);
    u_xlat2.xyz = vec3(u_xlat18) * u_xlat2.xyz;
    u_xlat18 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat18 = max(u_xlat18, 0.00100000005);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = vec3(u_xlat18) * u_xlat3.xyz;
    u_xlat18 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat4.xyz = vec3(u_xlat18) * vs_TEXCOORD4.xyz;
    u_xlat18 = dot(u_xlat4.xyz, u_xlat3.xyz);
    u_xlat18 = clamp(u_xlat18, 0.0, 1.0);
    u_xlat19 = dot(u_xlat2.xyz, u_xlat3.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat4.xyz, u_xlat2.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat1.x = dot(u_xlat4.xyz, (-u_xlat1.xyz));
    u_xlat7 = (-_Glossiness) + 1.0;
    u_xlat13 = u_xlat7 * u_xlat7;
    u_xlat8.x = u_xlat13 * u_xlat13;
    u_xlat14 = u_xlat18 * u_xlat8.x + (-u_xlat18);
    u_xlat18 = u_xlat14 * u_xlat18 + 1.0;
    u_xlat18 = u_xlat18 * u_xlat18 + 1.00000001e-07;
    u_xlat8.x = u_xlat8.x * 0.318309873;
    u_xlat18 = u_xlat8.x / u_xlat18;
    u_xlat8.x = (-u_xlat7) * u_xlat7 + 1.0;
    u_xlat14 = abs(u_xlat1.x) * u_xlat8.x + u_xlat13;
    u_xlat13 = u_xlat2.x * u_xlat8.x + u_xlat13;
    u_xlat13 = u_xlat13 * abs(u_xlat1.x);
    u_xlat1.x = -abs(u_xlat1.x) + 1.0;
    u_xlat13 = u_xlat2.x * u_xlat14 + u_xlat13;
    u_xlat13 = u_xlat13 + 9.99999975e-06;
    u_xlat13 = 0.5 / u_xlat13;
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat18 = u_xlat18 * 3.14159274;
    u_xlat18 = max(u_xlat18, 9.99999975e-05);
    u_xlat18 = sqrt(u_xlat18);
    u_xlat18 = u_xlat2.x * u_xlat18;
    u_xlat10_3 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat8.xyz = _Color.xyz * u_xlat10_3.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat3.xyz = u_xlat10_3.xyz * _Color.xyz;
    u_xlat8.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat8.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat13 = dot(u_xlat8.xyz, u_xlat8.xyz);
    u_xlatb13 = u_xlat13!=0.0;
    u_xlat13 = u_xlatb13 ? 1.0 : float(0.0);
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat4.xyz = u_xlat0.xyz * vec3(u_xlat18);
    u_xlat18 = (-u_xlat19) + 1.0;
    u_xlat13 = u_xlat19 * u_xlat19;
    u_xlat7 = dot(vec2(u_xlat13), vec2(u_xlat7));
    u_xlat7 = u_xlat7 + -0.5;
    u_xlat13 = u_xlat18 * u_xlat18;
    u_xlat13 = u_xlat13 * u_xlat13;
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat5.xyz = (-u_xlat8.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat8.xyz = u_xlat5.xyz * vec3(u_xlat18) + u_xlat8.xyz;
    u_xlat8.xyz = u_xlat8.xyz * u_xlat4.xyz;
    u_xlat18 = u_xlat1.x * u_xlat1.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat18 = u_xlat1.x * u_xlat18;
    u_xlat18 = u_xlat7 * u_xlat18 + 1.0;
    u_xlat1.x = (-u_xlat2.x) + 1.0;
    u_xlat13 = u_xlat1.x * u_xlat1.x;
    u_xlat13 = u_xlat13 * u_xlat13;
    u_xlat1.x = u_xlat1.x * u_xlat13;
    u_xlat1.x = u_xlat7 * u_xlat1.x + 1.0;
    u_xlat18 = u_xlat18 * u_xlat1.x;
    u_xlat18 = u_xlat2.x * u_xlat18;
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat18) * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat0.xyz + u_xlat8.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 _WorldSpaceLightPos0 at 32
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float3 u_xlat2;
    float u_xlat11;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.xyw = (-u_xlat1.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat11 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat11 = rsqrt(u_xlat11);
    u_xlat1.xyz = float3(u_xlat11) * u_xlat2.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD5.zw = u_xlat0.zw;
    output.TEXCOORD5.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1

Constant Buffer "Globals" (20 bytes) on slot 0 {
  VectorHalf4 _LightColor0 at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    float2 u_xlat5;
    half3 u_xlat16_6;
    half u_xlat16_7;
    half3 u_xlat16_8;
    half u_xlat16_11;
    half u_xlat16_14;
    half u_xlat16_15;
    half u_xlat16_21;
    half u_xlat16_22;
    float u_xlat25;
    half u_xlat16_25;
    bool u_xlatb25;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_21 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_21 = rsqrt(u_xlat16_21);
    u_xlat16_1.x = input.TEXCOORD2.w;
    u_xlat16_1.y = input.TEXCOORD3.w;
    u_xlat16_1.z = input.TEXCOORD4.w;
    u_xlat16_2.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_21) + u_xlat16_1.xyz);
    u_xlat16_3.xyz = half3(half3(u_xlat16_21) * input.TEXCOORD1.xyz);
    u_xlat16_21 = dot(u_xlat16_0.xyz, (-u_xlat16_3.xyz));
    u_xlat16_22 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlat16_4.x = half(max(float(u_xlat16_22), 0.00100000005));
    u_xlat16_22 = rsqrt(u_xlat16_4.x);
    u_xlat16_2.xyz = half3(half3(u_xlat16_22) * u_xlat16_2.xyz);
    u_xlat16_22 = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_22 = clamp(u_xlat16_22, 0.0h, 1.0h);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_1.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_7 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_7 = clamp(u_xlat16_7, 0.0h, 1.0h);
    u_xlat16_14 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_1.x = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_8.x = half(u_xlat16_1.x * u_xlat16_1.x);
    u_xlat16_15 = half(u_xlat16_22 * u_xlat16_8.x + (-u_xlat16_22));
    u_xlat16_4.x = half(float(u_xlat16_15) * float(u_xlat16_22) + 1.0);
    u_xlat16_4.x = half(float(u_xlat16_4.x) * float(u_xlat16_4.x) + 1.00000001e-07);
    u_xlat16_11 = half(float(u_xlat16_8.x) * 0.318309873);
    u_xlat16_4.x = half(u_xlat16_11 / u_xlat16_4.x);
    u_xlat16_8.x = half((-float(u_xlat16_14)) * float(u_xlat16_14) + 1.0);
    u_xlat16_15 = half(abs(u_xlat16_21) * u_xlat16_8.x + u_xlat16_1.x);
    u_xlat16_1.x = half(u_xlat16_0.x * u_xlat16_8.x + u_xlat16_1.x);
    u_xlat16_1.x = half(abs(u_xlat16_21) * u_xlat16_1.x);
    u_xlat16_21 = half(-abs(float(u_xlat16_21)) + 1.0);
    u_xlat16_1.x = half(u_xlat16_0.x * u_xlat16_15 + u_xlat16_1.x);
    u_xlat16_11 = half(float(u_xlat16_1.x) + 9.99999975e-06);
    u_xlat16_11 = half(0.5 / float(u_xlat16_11));
    u_xlat16_1.x = half(u_xlat16_4.x * u_xlat16_11);
    u_xlat16_4.x = half(float(u_xlat16_1.x) * 3.14159274);
    u_xlat16_4.x = half(max(float(u_xlat16_4.x), 9.99999975e-05));
    u_xlat16_4.x = sqrt(u_xlat16_4.x);
    u_xlat16_1.x = half(u_xlat16_0.x * u_xlat16_4.x);
    u_xlat16_4.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_8.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_4.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * Globals._Color.xyz);
    u_xlat16_8.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_8.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlatb25 = u_xlat16_2.x!=0.0;
    u_xlat25 = u_xlatb25 ? 1.0 : float(0.0);
    u_xlat16_1.x = half(float(u_xlat16_1.x) * u_xlat25);
    u_xlat5.xy = input.TEXCOORD5.xy / input.TEXCOORD5.ww;
    u_xlat16_25 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat5.xy).x;
    u_xlat16_2.xyz = half3(half3(u_xlat16_25) * Globals._LightColor0.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_1.xxx * u_xlat16_2.xyz);
    u_xlat16_1.x = half((-float(u_xlat16_7)) + 1.0);
    u_xlat16_7 = half(u_xlat16_7 * u_xlat16_7);
    u_xlat16_7 = dot(half2(u_xlat16_7), half2(u_xlat16_14));
    u_xlat16_7 = half(float(u_xlat16_7) + -0.5);
    u_xlat16_14 = half(u_xlat16_1.x * u_xlat16_1.x);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_14 = half(u_xlat16_1.x * u_xlat16_14);
    u_xlat16_6.xyz = half3((-float3(u_xlat16_8.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_1.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_14) + u_xlat16_8.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_1.xyz * u_xlat16_3.xyz);
    u_xlat16_14 = half(u_xlat16_21 * u_xlat16_21);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_14 = half(u_xlat16_21 * u_xlat16_14);
    u_xlat16_14 = half(float(u_xlat16_7) * float(u_xlat16_14) + 1.0);
    u_xlat16_21 = half((-float(u_xlat16_0.x)) + 1.0);
    u_xlat16_22 = half(u_xlat16_21 * u_xlat16_21);
    u_xlat16_22 = half(u_xlat16_22 * u_xlat16_22);
    u_xlat16_21 = half(u_xlat16_21 * u_xlat16_22);
    u_xlat16_7 = half(float(u_xlat16_7) * float(u_xlat16_21) + 1.0);
    u_xlat16_7 = half(u_xlat16_14 * u_xlat16_7);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_7);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * u_xlat16_2.xyz);
    u_xlat16_21 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_2.xyz = half3(half3(u_xlat16_21) * u_xlat16_4.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_2.xyz * u_xlat16_0.xyz + u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
float u_xlat7;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = inversesqrt(u_xlat7);
    vs_TEXCOORD4.xyz = vec3(u_xlat7) * u_xlat1.xyz;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD5.zw = u_xlat0.zw;
    vs_TEXCOORD5.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
vec3 u_xlat5;
float u_xlat6;
vec3 u_xlat7;
float u_xlat12;
float u_xlat13;
float u_xlat18;
float u_xlat19;
float u_xlat20;
bool u_xlatb20;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat18 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat1.x = vs_TEXCOORD2.w;
    u_xlat1.y = vs_TEXCOORD3.w;
    u_xlat1.z = vs_TEXCOORD4.w;
    u_xlat2.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat18) + u_xlat1.xyz;
    u_xlat3.xyz = vec3(u_xlat18) * vs_TEXCOORD1.xyz;
    u_xlat18 = dot(u_xlat0.xyz, (-u_xlat3.xyz));
    u_xlat19 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat19 = max(u_xlat19, 0.00100000005);
    u_xlat19 = inversesqrt(u_xlat19);
    u_xlat2.xyz = vec3(u_xlat19) * u_xlat2.xyz;
    u_xlat19 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat6 = clamp(u_xlat6, 0.0, 1.0);
    u_xlat12 = (-_Glossiness) + 1.0;
    u_xlat1.x = u_xlat12 * u_xlat12;
    u_xlat7.x = u_xlat1.x * u_xlat1.x;
    u_xlat13 = u_xlat19 * u_xlat7.x + (-u_xlat19);
    u_xlat13 = u_xlat13 * u_xlat19 + 1.0;
    u_xlat13 = u_xlat13 * u_xlat13 + 1.00000001e-07;
    u_xlat7.x = u_xlat7.x * 0.318309873;
    u_xlat7.x = u_xlat7.x / u_xlat13;
    u_xlat13 = (-u_xlat12) * u_xlat12 + 1.0;
    u_xlat19 = abs(u_xlat18) * u_xlat13 + u_xlat1.x;
    u_xlat1.x = u_xlat0.x * u_xlat13 + u_xlat1.x;
    u_xlat1.x = abs(u_xlat18) * u_xlat1.x;
    u_xlat18 = -abs(u_xlat18) + 1.0;
    u_xlat1.x = u_xlat0.x * u_xlat19 + u_xlat1.x;
    u_xlat1.x = u_xlat1.x + 9.99999975e-06;
    u_xlat1.x = 0.5 / u_xlat1.x;
    u_xlat1.x = u_xlat7.x * u_xlat1.x;
    u_xlat1.x = u_xlat1.x * 3.14159274;
    u_xlat1.x = max(u_xlat1.x, 9.99999975e-05);
    u_xlat1.x = sqrt(u_xlat1.x);
    u_xlat1.x = u_xlat0.x * u_xlat1.x;
    u_xlat10_2 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat7.xyz = _Color.xyz * u_xlat10_2.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat2.xyz = u_xlat10_2.xyz * _Color.xyz;
    u_xlat7.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat7.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat20 = dot(u_xlat7.xyz, u_xlat7.xyz);
    u_xlatb20 = u_xlat20!=0.0;
    u_xlat20 = u_xlatb20 ? 1.0 : float(0.0);
    u_xlat1.x = u_xlat1.x * u_xlat20;
    u_xlat3.xy = vs_TEXCOORD5.xy / vs_TEXCOORD5.ww;
    u_xlat10_3 = texture(_ShadowMapTexture, u_xlat3.xy);
    u_xlat3.xyz = u_xlat10_3.xxx * _LightColor0.xyz;
    u_xlat4.xyz = u_xlat1.xxx * u_xlat3.xyz;
    u_xlat1.x = (-u_xlat6) + 1.0;
    u_xlat6 = u_xlat6 * u_xlat6;
    u_xlat6 = dot(vec2(u_xlat6), vec2(u_xlat12));
    u_xlat6 = u_xlat6 + -0.5;
    u_xlat12 = u_xlat1.x * u_xlat1.x;
    u_xlat12 = u_xlat12 * u_xlat12;
    u_xlat12 = u_xlat1.x * u_xlat12;
    u_xlat5.xyz = (-u_xlat7.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat1.xyz = u_xlat5.xyz * vec3(u_xlat12) + u_xlat7.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat4.xyz;
    u_xlat12 = u_xlat18 * u_xlat18;
    u_xlat12 = u_xlat12 * u_xlat12;
    u_xlat12 = u_xlat18 * u_xlat12;
    u_xlat12 = u_xlat6 * u_xlat12 + 1.0;
    u_xlat18 = (-u_xlat0.x) + 1.0;
    u_xlat19 = u_xlat18 * u_xlat18;
    u_xlat19 = u_xlat19 * u_xlat19;
    u_xlat18 = u_xlat18 * u_xlat19;
    u_xlat6 = u_xlat6 * u_xlat18 + 1.0;
    u_xlat6 = u_xlat12 * u_xlat6;
    u_xlat0.x = u_xlat0.x * u_xlat6;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat3.xyz;
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat2.xyz = vec3(u_xlat18) * u_xlat2.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL_COOKIE SHADOWS_SCREEN 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (352 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Matrix4x4 unity_WorldToLight at 288
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 _WorldSpaceLightPos0 at 32
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float2 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float3 u_xlat2;
    float u_xlat11;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.xyw = (-u_xlat1.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat11 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat11 = rsqrt(u_xlat11);
    u_xlat1.xyz = float3(u_xlat11) * u_xlat2.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat1 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat1;
    u_xlat2.xy = u_xlat1.yy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat1.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xy * u_xlat1.xx + u_xlat2.xy;
    u_xlat1.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xy * u_xlat1.zz + u_xlat1.xy;
    output.TEXCOORD5.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[3].xy * u_xlat1.ww + u_xlat1.xy;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "_ShadowMapTexture" to slot 2

Constant Buffer "Globals" (20 bytes) on slot 0 {
  VectorHalf4 _LightColor0 at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float2 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (2) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    float2 u_xlat5;
    half u_xlat16_5;
    half3 u_xlat16_6;
    half u_xlat16_7;
    half3 u_xlat16_8;
    half u_xlat16_11;
    half u_xlat16_14;
    half u_xlat16_15;
    half u_xlat16_21;
    half u_xlat16_22;
    float u_xlat25;
    half u_xlat16_25;
    bool u_xlatb25;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_21 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_21 = rsqrt(u_xlat16_21);
    u_xlat16_1.x = input.TEXCOORD2.w;
    u_xlat16_1.y = input.TEXCOORD3.w;
    u_xlat16_1.z = input.TEXCOORD4.w;
    u_xlat16_2.xyz = half3((-input.TEXCOORD1.xyz) * half3(u_xlat16_21) + u_xlat16_1.xyz);
    u_xlat16_3.xyz = half3(half3(u_xlat16_21) * input.TEXCOORD1.xyz);
    u_xlat16_21 = dot(u_xlat16_0.xyz, (-u_xlat16_3.xyz));
    u_xlat16_22 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);
    u_xlat16_4.x = half(max(float(u_xlat16_22), 0.00100000005));
    u_xlat16_22 = rsqrt(u_xlat16_4.x);
    u_xlat16_2.xyz = half3(half3(u_xlat16_22) * u_xlat16_2.xyz);
    u_xlat16_22 = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_22 = clamp(u_xlat16_22, 0.0h, 1.0h);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_1.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_7 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_7 = clamp(u_xlat16_7, 0.0h, 1.0h);
    u_xlat16_14 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_1.x = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_8.x = half(u_xlat16_1.x * u_xlat16_1.x);
    u_xlat16_15 = half(u_xlat16_22 * u_xlat16_8.x + (-u_xlat16_22));
    u_xlat16_4.x = half(float(u_xlat16_15) * float(u_xlat16_22) + 1.0);
    u_xlat16_4.x = half(float(u_xlat16_4.x) * float(u_xlat16_4.x) + 1.00000001e-07);
    u_xlat16_11 = half(float(u_xlat16_8.x) * 0.318309873);
    u_xlat16_4.x = half(u_xlat16_11 / u_xlat16_4.x);
    u_xlat16_8.x = half((-float(u_xlat16_14)) * float(u_xlat16_14) + 1.0);
    u_xlat16_15 = half(abs(u_xlat16_21) * u_xlat16_8.x + u_xlat16_1.x);
    u_xlat16_1.x = half(u_xlat16_0.x * u_xlat16_8.x + u_xlat16_1.x);
    u_xlat16_1.x = half(abs(u_xlat16_21) * u_xlat16_1.x);
    u_xlat16_21 = half(-abs(float(u_xlat16_21)) + 1.0);
    u_xlat16_1.x = half(u_xlat16_0.x * u_xlat16_15 + u_xlat16_1.x);
    u_xlat16_11 = half(float(u_xlat16_1.x) + 9.99999975e-06);
    u_xlat16_11 = half(0.5 / float(u_xlat16_11));
    u_xlat16_1.x = half(u_xlat16_4.x * u_xlat16_11);
    u_xlat16_4.x = half(float(u_xlat16_1.x) * 3.14159274);
    u_xlat16_4.x = half(max(float(u_xlat16_4.x), 9.99999975e-05));
    u_xlat16_4.x = sqrt(u_xlat16_4.x);
    u_xlat16_1.x = half(u_xlat16_0.x * u_xlat16_4.x);
    u_xlat16_4.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_8.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_4.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * Globals._Color.xyz);
    u_xlat16_8.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_8.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = dot(u_xlat16_8.xyz, u_xlat16_8.xyz);
    u_xlatb25 = u_xlat16_2.x!=0.0;
    u_xlat25 = u_xlatb25 ? 1.0 : float(0.0);
    u_xlat16_1.x = half(float(u_xlat16_1.x) * u_xlat25);
    u_xlat5.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_25 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat5.xy).x;
    u_xlat16_5 = _LightTexture0.sample(sampler_LightTexture0, input.TEXCOORD5.xy).w;
    u_xlat16_25 = half(u_xlat16_25 * u_xlat16_5);
    u_xlat16_2.xyz = half3(half3(u_xlat16_25) * Globals._LightColor0.xyz);
    u_xlat16_3.xyz = half3(u_xlat16_1.xxx * u_xlat16_2.xyz);
    u_xlat16_1.x = half((-float(u_xlat16_7)) + 1.0);
    u_xlat16_7 = half(u_xlat16_7 * u_xlat16_7);
    u_xlat16_7 = dot(half2(u_xlat16_7), half2(u_xlat16_14));
    u_xlat16_7 = half(float(u_xlat16_7) + -0.5);
    u_xlat16_14 = half(u_xlat16_1.x * u_xlat16_1.x);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_14 = half(u_xlat16_1.x * u_xlat16_14);
    u_xlat16_6.xyz = half3((-float3(u_xlat16_8.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_1.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_14) + u_xlat16_8.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_1.xyz * u_xlat16_3.xyz);
    u_xlat16_14 = half(u_xlat16_21 * u_xlat16_21);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_14 = half(u_xlat16_21 * u_xlat16_14);
    u_xlat16_14 = half(float(u_xlat16_7) * float(u_xlat16_14) + 1.0);
    u_xlat16_21 = half((-float(u_xlat16_0.x)) + 1.0);
    u_xlat16_22 = half(u_xlat16_21 * u_xlat16_21);
    u_xlat16_22 = half(u_xlat16_22 * u_xlat16_22);
    u_xlat16_21 = half(u_xlat16_21 * u_xlat16_22);
    u_xlat16_7 = half(float(u_xlat16_7) * float(u_xlat16_21) + 1.0);
    u_xlat16_7 = half(u_xlat16_14 * u_xlat16_7);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_7);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * u_xlat16_2.xyz);
    u_xlat16_21 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_2.xyz = half3(half3(u_xlat16_21) * u_xlat16_4.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_2.xyz * u_xlat16_0.xyz + u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec2 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec2 u_xlat2;
float u_xlat10;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    vs_TEXCOORD1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = inversesqrt(u_xlat10);
    vs_TEXCOORD4.xyz = vec3(u_xlat10) * u_xlat1.xyz;
    u_xlat1 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat1;
    u_xlat2.xy = u_xlat1.yy * hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat1.xy = hlslcc_mtx4x4unity_WorldToLight[0].xy * u_xlat1.xx + u_xlat2.xy;
    u_xlat1.xy = hlslcc_mtx4x4unity_WorldToLight[2].xy * u_xlat1.zz + u_xlat1.xy;
    vs_TEXCOORD5.xy = hlslcc_mtx4x4unity_WorldToLight[3].xy * u_xlat1.ww + u_xlat1.xy;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D _ShadowMapTexture;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec2 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
float u_xlat6;
vec3 u_xlat7;
float u_xlat12;
float u_xlat13;
float u_xlat18;
float u_xlat19;
float u_xlat20;
mediump float u_xlat16_20;
bool u_xlatb20;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat18 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat1.x = vs_TEXCOORD2.w;
    u_xlat1.y = vs_TEXCOORD3.w;
    u_xlat1.z = vs_TEXCOORD4.w;
    u_xlat2.xyz = (-vs_TEXCOORD1.xyz) * vec3(u_xlat18) + u_xlat1.xyz;
    u_xlat3.xyz = vec3(u_xlat18) * vs_TEXCOORD1.xyz;
    u_xlat18 = dot(u_xlat0.xyz, (-u_xlat3.xyz));
    u_xlat19 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat19 = max(u_xlat19, 0.00100000005);
    u_xlat19 = inversesqrt(u_xlat19);
    u_xlat2.xyz = vec3(u_xlat19) * u_xlat2.xyz;
    u_xlat19 = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat6 = clamp(u_xlat6, 0.0, 1.0);
    u_xlat12 = (-_Glossiness) + 1.0;
    u_xlat1.x = u_xlat12 * u_xlat12;
    u_xlat7.x = u_xlat1.x * u_xlat1.x;
    u_xlat13 = u_xlat19 * u_xlat7.x + (-u_xlat19);
    u_xlat13 = u_xlat13 * u_xlat19 + 1.0;
    u_xlat13 = u_xlat13 * u_xlat13 + 1.00000001e-07;
    u_xlat7.x = u_xlat7.x * 0.318309873;
    u_xlat7.x = u_xlat7.x / u_xlat13;
    u_xlat13 = (-u_xlat12) * u_xlat12 + 1.0;
    u_xlat19 = abs(u_xlat18) * u_xlat13 + u_xlat1.x;
    u_xlat1.x = u_xlat0.x * u_xlat13 + u_xlat1.x;
    u_xlat1.x = abs(u_xlat18) * u_xlat1.x;
    u_xlat18 = -abs(u_xlat18) + 1.0;
    u_xlat1.x = u_xlat0.x * u_xlat19 + u_xlat1.x;
    u_xlat1.x = u_xlat1.x + 9.99999975e-06;
    u_xlat1.x = 0.5 / u_xlat1.x;
    u_xlat1.x = u_xlat7.x * u_xlat1.x;
    u_xlat1.x = u_xlat1.x * 3.14159274;
    u_xlat1.x = max(u_xlat1.x, 9.99999975e-05);
    u_xlat1.x = sqrt(u_xlat1.x);
    u_xlat1.x = u_xlat0.x * u_xlat1.x;
    u_xlat10_2 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat7.xyz = _Color.xyz * u_xlat10_2.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat2.xyz = u_xlat10_2.xyz * _Color.xyz;
    u_xlat7.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat7.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat20 = dot(u_xlat7.xyz, u_xlat7.xyz);
    u_xlatb20 = u_xlat20!=0.0;
    u_xlat20 = u_xlatb20 ? 1.0 : float(0.0);
    u_xlat1.x = u_xlat1.x * u_xlat20;
    u_xlat3.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_3 = texture(_ShadowMapTexture, u_xlat3.xy);
    u_xlat10_4 = texture(_LightTexture0, vs_TEXCOORD5.xy);
    u_xlat16_20 = u_xlat10_3.x * u_xlat10_4.w;
    u_xlat3.xyz = vec3(u_xlat16_20) * _LightColor0.xyz;
    u_xlat4.xyz = u_xlat1.xxx * u_xlat3.xyz;
    u_xlat1.x = (-u_xlat6) + 1.0;
    u_xlat6 = u_xlat6 * u_xlat6;
    u_xlat6 = dot(vec2(u_xlat6), vec2(u_xlat12));
    u_xlat6 = u_xlat6 + -0.5;
    u_xlat12 = u_xlat1.x * u_xlat1.x;
    u_xlat12 = u_xlat12 * u_xlat12;
    u_xlat12 = u_xlat1.x * u_xlat12;
    u_xlat5.xyz = (-u_xlat7.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat1.xyz = u_xlat5.xyz * vec3(u_xlat12) + u_xlat7.xyz;
    u_xlat1.xyz = u_xlat1.xyz * u_xlat4.xyz;
    u_xlat12 = u_xlat18 * u_xlat18;
    u_xlat12 = u_xlat12 * u_xlat12;
    u_xlat12 = u_xlat18 * u_xlat12;
    u_xlat12 = u_xlat6 * u_xlat12 + 1.0;
    u_xlat18 = (-u_xlat0.x) + 1.0;
    u_xlat19 = u_xlat18 * u_xlat18;
    u_xlat19 = u_xlat19 * u_xlat19;
    u_xlat18 = u_xlat18 * u_xlat19;
    u_xlat6 = u_xlat6 * u_xlat18 + 1.0;
    u_xlat6 = u_xlat12 * u_xlat6;
    u_xlat0.x = u_xlat0.x * u_xlat6;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat3.xyz;
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat2.xyz = vec3(u_xlat18) * u_xlat2.xyz;
    SV_Target0.xyz = u_xlat2.xyz * u_xlat0.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: POINT SHADOWS_CUBE 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (352 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Matrix4x4 unity_WorldToLight at 288
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _LightPositionRange at 32
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD6.xyz = u_xlat0.xyz + (-Globals._LightPositionRange.xyz);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    output.TEXCOORD5.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set CUBE Texture "_ShadowMapTexture" to slot 2

Constant Buffer "Globals" (44 bytes) on slot 0 {
  Vector4 _LightPositionRange at 0
  VectorHalf4 _LightShadowData at 16
  VectorHalf4 _LightColor0 at 24
  VectorHalf4 _Color at 32
  ScalarHalf _Metallic at 40
  ScalarHalf _Glossiness at 42
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    half4 _LightShadowData;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texturecube<float, access::sample > _ShadowMapTexture [[ texture (2) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    float u_xlat6;
    half u_xlat16_6;
    half u_xlat16_8;
    half3 u_xlat16_9;
    half u_xlat16_14;
    half u_xlat16_15;
    float u_xlat18;
    bool u_xlatb18;
    half u_xlat16_19;
    half u_xlat16_20;
    u_xlat0 = dot(input.TEXCOORD6.xyz, input.TEXCOORD6.xyz);
    u_xlat0 = sqrt(u_xlat0);
    u_xlat0 = u_xlat0 * Globals._LightPositionRange.w;
    u_xlat0 = u_xlat0 * 0.970000029;
    u_xlat6 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, input.TEXCOORD6.xyz).x;
    u_xlatb0 = u_xlat6<u_xlat0;
    u_xlat16_1.x = (u_xlatb0) ? Globals._LightShadowData.x : 1.0;
    u_xlat0 = dot(input.TEXCOORD5.xyz, input.TEXCOORD5.xyz);
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, float2(u_xlat0)).w;
    u_xlat16_0.x = half(u_xlat16_1.x * u_xlat16_0.x);
    u_xlat16_1.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_19 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_19 = rsqrt(u_xlat16_19);
    u_xlat16_2.xyz = half3(half3(u_xlat16_19) * input.TEXCOORD1.xyz);
    u_xlat16_3.x = input.TEXCOORD2.w;
    u_xlat16_3.y = input.TEXCOORD3.w;
    u_xlat16_3.z = input.TEXCOORD4.w;
    u_xlat16_19 = dot(u_xlat16_3.xyz, u_xlat16_3.xyz);
    u_xlat16_19 = rsqrt(u_xlat16_19);
    u_xlat16_4.xyz = half3(u_xlat16_3.xyz * half3(u_xlat16_19) + (-u_xlat16_2.xyz));
    u_xlat16_3.xyz = half3(half3(u_xlat16_19) * u_xlat16_3.xyz);
    u_xlat16_19 = dot(u_xlat16_4.xyz, u_xlat16_4.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_19), 0.00100000005));
    u_xlat16_19 = rsqrt(u_xlat16_0.x);
    u_xlat16_4.xyz = half3(half3(u_xlat16_19) * u_xlat16_4.xyz);
    u_xlat16_19 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_19 = rsqrt(u_xlat16_19);
    u_xlat16_5.xyz = half3(half3(u_xlat16_19) * input.TEXCOORD4.xyz);
    u_xlat16_19 = dot(u_xlat16_5.xyz, u_xlat16_4.xyz);
    u_xlat16_19 = clamp(u_xlat16_19, 0.0h, 1.0h);
    u_xlat16_20 = dot(u_xlat16_3.xyz, u_xlat16_4.xyz);
    u_xlat16_20 = clamp(u_xlat16_20, 0.0h, 1.0h);
    u_xlat16_3.x = dot(u_xlat16_5.xyz, u_xlat16_3.xyz);
    u_xlat16_3.x = clamp(u_xlat16_3.x, 0.0h, 1.0h);
    u_xlat16_2.x = dot(u_xlat16_5.xyz, (-u_xlat16_2.xyz));
    u_xlat16_8 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_14 = half(u_xlat16_8 * u_xlat16_8);
    u_xlat16_9.x = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_15 = half(u_xlat16_19 * u_xlat16_9.x + (-u_xlat16_19));
    u_xlat16_0.x = half(float(u_xlat16_15) * float(u_xlat16_19) + 1.0);
    u_xlat16_0.x = half(float(u_xlat16_0.x) * float(u_xlat16_0.x) + 1.00000001e-07);
    u_xlat16_6 = half(float(u_xlat16_9.x) * 0.318309873);
    u_xlat16_0.x = half(u_xlat16_6 / u_xlat16_0.x);
    u_xlat16_19 = half((-float(u_xlat16_8)) * float(u_xlat16_8) + 1.0);
    u_xlat16_9.x = half(abs(u_xlat16_2.x) * u_xlat16_19 + u_xlat16_14);
    u_xlat16_19 = half(u_xlat16_3.x * u_xlat16_19 + u_xlat16_14);
    u_xlat16_19 = half(u_xlat16_19 * abs(u_xlat16_2.x));
    u_xlat16_2.x = half(-abs(float(u_xlat16_2.x)) + 1.0);
    u_xlat16_19 = half(u_xlat16_3.x * u_xlat16_9.x + u_xlat16_19);
    u_xlat16_6 = half(float(u_xlat16_19) + 9.99999975e-06);
    u_xlat16_6 = half(0.5 / float(u_xlat16_6));
    u_xlat16_19 = half(u_xlat16_0.x * u_xlat16_6);
    u_xlat16_0.x = half(float(u_xlat16_19) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_19 = half(u_xlat16_3.x * u_xlat16_0.x);
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_9.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_0.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_9.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_9.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_14 = dot(u_xlat16_9.xyz, u_xlat16_9.xyz);
    u_xlatb18 = u_xlat16_14!=0.0;
    u_xlat18 = u_xlatb18 ? 1.0 : float(0.0);
    u_xlat16_19 = half(u_xlat18 * float(u_xlat16_19));
    u_xlat16_4.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_19));
    u_xlat16_19 = half((-float(u_xlat16_20)) + 1.0);
    u_xlat16_14 = half(u_xlat16_20 * u_xlat16_20);
    u_xlat16_8 = dot(half2(u_xlat16_14), half2(u_xlat16_8));
    u_xlat16_8 = half(float(u_xlat16_8) + -0.5);
    u_xlat16_14 = half(u_xlat16_19 * u_xlat16_19);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_19 = half(u_xlat16_19 * u_xlat16_14);
    u_xlat16_5.xyz = half3((-float3(u_xlat16_9.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_9.xyz = half3(u_xlat16_5.xyz * half3(u_xlat16_19) + u_xlat16_9.xyz);
    u_xlat16_9.xyz = half3(u_xlat16_9.xyz * u_xlat16_4.xyz);
    u_xlat16_19 = half(u_xlat16_2.x * u_xlat16_2.x);
    u_xlat16_19 = half(u_xlat16_19 * u_xlat16_19);
    u_xlat16_19 = half(u_xlat16_2.x * u_xlat16_19);
    u_xlat16_19 = half(float(u_xlat16_8) * float(u_xlat16_19) + 1.0);
    u_xlat16_2.x = half((-float(u_xlat16_3.x)) + 1.0);
    u_xlat16_14 = half(u_xlat16_2.x * u_xlat16_2.x);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_2.x = half(u_xlat16_2.x * u_xlat16_14);
    u_xlat16_2.x = half(float(u_xlat16_8) * float(u_xlat16_2.x) + 1.0);
    u_xlat16_19 = half(u_xlat16_19 * u_xlat16_2.x);
    u_xlat16_19 = half(u_xlat16_3.x * u_xlat16_19);
    u_xlat16_1.xyz = half3(half3(u_xlat16_19) * u_xlat16_1.xyz);
    u_xlat16_19 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_2.xyz = half3(u_xlat16_0.xyz * half3(u_xlat16_19));
    output.SV_Target0.xyz = half3(u_xlat16_2.xyz * u_xlat16_1.xyz + u_xlat16_9.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 _LightPositionRange;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD6.xyz = u_xlat0.xyz + (-_LightPositionRange.xyz);
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    vs_TEXCOORD5.xyz = hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 _LightShadowData;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  samplerCube _ShadowMapTexture;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
vec3 u_xlat5;
float u_xlat6;
float u_xlat7;
vec3 u_xlat8;
float u_xlat13;
bool u_xlatb13;
float u_xlat14;
float u_xlat18;
float u_xlat19;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD6.xyz, vs_TEXCOORD6.xyz);
    u_xlat0.x = sqrt(u_xlat0.x);
    u_xlat0.x = u_xlat0.x * _LightPositionRange.w;
    u_xlat0.x = u_xlat0.x * 0.970000029;
    u_xlat10_1 = texture(_ShadowMapTexture, vs_TEXCOORD6.xyz);
    u_xlatb0 = u_xlat10_1.x<u_xlat0.x;
    u_xlat0.x = (u_xlatb0) ? _LightShadowData.x : 1.0;
    u_xlat6 = dot(vs_TEXCOORD5.xyz, vs_TEXCOORD5.xyz);
    u_xlat10_1 = texture(_LightTexture0, vec2(u_xlat6));
    u_xlat0.x = u_xlat0.x * u_xlat10_1.w;
    u_xlat0.xyz = u_xlat0.xxx * _LightColor0.xyz;
    u_xlat18 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat1.xyz = vec3(u_xlat18) * vs_TEXCOORD1.xyz;
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat18 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = u_xlat2.xyz * vec3(u_xlat18) + (-u_xlat1.xyz);
    u_xlat2.xyz = vec3(u_xlat18) * u_xlat2.xyz;
    u_xlat18 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat18 = max(u_xlat18, 0.00100000005);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = vec3(u_xlat18) * u_xlat3.xyz;
    u_xlat18 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat4.xyz = vec3(u_xlat18) * vs_TEXCOORD4.xyz;
    u_xlat18 = dot(u_xlat4.xyz, u_xlat3.xyz);
    u_xlat18 = clamp(u_xlat18, 0.0, 1.0);
    u_xlat19 = dot(u_xlat2.xyz, u_xlat3.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat4.xyz, u_xlat2.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat1.x = dot(u_xlat4.xyz, (-u_xlat1.xyz));
    u_xlat7 = (-_Glossiness) + 1.0;
    u_xlat13 = u_xlat7 * u_xlat7;
    u_xlat8.x = u_xlat13 * u_xlat13;
    u_xlat14 = u_xlat18 * u_xlat8.x + (-u_xlat18);
    u_xlat18 = u_xlat14 * u_xlat18 + 1.0;
    u_xlat18 = u_xlat18 * u_xlat18 + 1.00000001e-07;
    u_xlat8.x = u_xlat8.x * 0.318309873;
    u_xlat18 = u_xlat8.x / u_xlat18;
    u_xlat8.x = (-u_xlat7) * u_xlat7 + 1.0;
    u_xlat14 = abs(u_xlat1.x) * u_xlat8.x + u_xlat13;
    u_xlat13 = u_xlat2.x * u_xlat8.x + u_xlat13;
    u_xlat13 = u_xlat13 * abs(u_xlat1.x);
    u_xlat1.x = -abs(u_xlat1.x) + 1.0;
    u_xlat13 = u_xlat2.x * u_xlat14 + u_xlat13;
    u_xlat13 = u_xlat13 + 9.99999975e-06;
    u_xlat13 = 0.5 / u_xlat13;
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat18 = u_xlat18 * 3.14159274;
    u_xlat18 = max(u_xlat18, 9.99999975e-05);
    u_xlat18 = sqrt(u_xlat18);
    u_xlat18 = u_xlat2.x * u_xlat18;
    u_xlat10_3 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat8.xyz = _Color.xyz * u_xlat10_3.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat3.xyz = u_xlat10_3.xyz * _Color.xyz;
    u_xlat8.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat8.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat13 = dot(u_xlat8.xyz, u_xlat8.xyz);
    u_xlatb13 = u_xlat13!=0.0;
    u_xlat13 = u_xlatb13 ? 1.0 : float(0.0);
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat4.xyz = u_xlat0.xyz * vec3(u_xlat18);
    u_xlat18 = (-u_xlat19) + 1.0;
    u_xlat13 = u_xlat19 * u_xlat19;
    u_xlat7 = dot(vec2(u_xlat13), vec2(u_xlat7));
    u_xlat7 = u_xlat7 + -0.5;
    u_xlat13 = u_xlat18 * u_xlat18;
    u_xlat13 = u_xlat13 * u_xlat13;
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat5.xyz = (-u_xlat8.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat8.xyz = u_xlat5.xyz * vec3(u_xlat18) + u_xlat8.xyz;
    u_xlat8.xyz = u_xlat8.xyz * u_xlat4.xyz;
    u_xlat18 = u_xlat1.x * u_xlat1.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat18 = u_xlat1.x * u_xlat18;
    u_xlat18 = u_xlat7 * u_xlat18 + 1.0;
    u_xlat1.x = (-u_xlat2.x) + 1.0;
    u_xlat13 = u_xlat1.x * u_xlat1.x;
    u_xlat13 = u_xlat13 * u_xlat13;
    u_xlat1.x = u_xlat1.x * u_xlat13;
    u_xlat1.x = u_xlat7 * u_xlat1.x + 1.0;
    u_xlat18 = u_xlat18 * u_xlat1.x;
    u_xlat18 = u_xlat2.x * u_xlat18;
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat18) * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat0.xyz + u_xlat8.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: POINT_COOKIE SHADOWS_CUBE 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (352 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Matrix4x4 unity_WorldToLight at 288
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _LightPositionRange at 32
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD6.xyz = u_xlat0.xyz + (-Globals._LightPositionRange.xyz);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    output.TEXCOORD5.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTextureB0" to slot 1
Set CUBE Texture "_LightTexture0" to slot 2
Set CUBE Texture "_ShadowMapTexture" to slot 3

Constant Buffer "Globals" (44 bytes) on slot 0 {
  Vector4 _LightPositionRange at 0
  VectorHalf4 _LightShadowData at 16
  VectorHalf4 _LightColor0 at 24
  VectorHalf4 _Color at 32
  ScalarHalf _Metallic at 40
  ScalarHalf _Glossiness at 42
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    half4 _LightShadowData;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (1) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (1) ]] ,
    texturecube<half, access::sample > _LightTexture0 [[ texture (2) ]] ,
    sampler sampler_LightTexture0 [[ sampler (2) ]] ,
    texturecube<float, access::sample > _ShadowMapTexture [[ texture (3) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float u_xlat0;
    half3 u_xlat16_0;
    bool u_xlatb0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    float u_xlat6;
    half u_xlat16_6;
    half u_xlat16_8;
    half3 u_xlat16_9;
    half u_xlat16_14;
    half u_xlat16_15;
    float u_xlat18;
    bool u_xlatb18;
    half u_xlat16_19;
    half u_xlat16_20;
    u_xlat0 = dot(input.TEXCOORD6.xyz, input.TEXCOORD6.xyz);
    u_xlat0 = sqrt(u_xlat0);
    u_xlat0 = u_xlat0 * Globals._LightPositionRange.w;
    u_xlat0 = u_xlat0 * 0.970000029;
    u_xlat6 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, input.TEXCOORD6.xyz).x;
    u_xlatb0 = u_xlat6<u_xlat0;
    u_xlat16_1.x = (u_xlatb0) ? Globals._LightShadowData.x : 1.0;
    u_xlat0 = dot(input.TEXCOORD5.xyz, input.TEXCOORD5.xyz);
    u_xlat16_0.x = _LightTextureB0.sample(sampler_LightTextureB0, float2(u_xlat0)).w;
    u_xlat16_6 = _LightTexture0.sample(sampler_LightTexture0, input.TEXCOORD5.xyz).w;
    u_xlat16_0.x = half(u_xlat16_6 * u_xlat16_0.x);
    u_xlat16_0.x = half(u_xlat16_1.x * u_xlat16_0.x);
    u_xlat16_1.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_19 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_19 = rsqrt(u_xlat16_19);
    u_xlat16_2.xyz = half3(half3(u_xlat16_19) * input.TEXCOORD1.xyz);
    u_xlat16_3.x = input.TEXCOORD2.w;
    u_xlat16_3.y = input.TEXCOORD3.w;
    u_xlat16_3.z = input.TEXCOORD4.w;
    u_xlat16_19 = dot(u_xlat16_3.xyz, u_xlat16_3.xyz);
    u_xlat16_19 = rsqrt(u_xlat16_19);
    u_xlat16_4.xyz = half3(u_xlat16_3.xyz * half3(u_xlat16_19) + (-u_xlat16_2.xyz));
    u_xlat16_3.xyz = half3(half3(u_xlat16_19) * u_xlat16_3.xyz);
    u_xlat16_19 = dot(u_xlat16_4.xyz, u_xlat16_4.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_19), 0.00100000005));
    u_xlat16_19 = rsqrt(u_xlat16_0.x);
    u_xlat16_4.xyz = half3(half3(u_xlat16_19) * u_xlat16_4.xyz);
    u_xlat16_19 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_19 = rsqrt(u_xlat16_19);
    u_xlat16_5.xyz = half3(half3(u_xlat16_19) * input.TEXCOORD4.xyz);
    u_xlat16_19 = dot(u_xlat16_5.xyz, u_xlat16_4.xyz);
    u_xlat16_19 = clamp(u_xlat16_19, 0.0h, 1.0h);
    u_xlat16_20 = dot(u_xlat16_3.xyz, u_xlat16_4.xyz);
    u_xlat16_20 = clamp(u_xlat16_20, 0.0h, 1.0h);
    u_xlat16_3.x = dot(u_xlat16_5.xyz, u_xlat16_3.xyz);
    u_xlat16_3.x = clamp(u_xlat16_3.x, 0.0h, 1.0h);
    u_xlat16_2.x = dot(u_xlat16_5.xyz, (-u_xlat16_2.xyz));
    u_xlat16_8 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_14 = half(u_xlat16_8 * u_xlat16_8);
    u_xlat16_9.x = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_15 = half(u_xlat16_19 * u_xlat16_9.x + (-u_xlat16_19));
    u_xlat16_0.x = half(float(u_xlat16_15) * float(u_xlat16_19) + 1.0);
    u_xlat16_0.x = half(float(u_xlat16_0.x) * float(u_xlat16_0.x) + 1.00000001e-07);
    u_xlat16_6 = half(float(u_xlat16_9.x) * 0.318309873);
    u_xlat16_0.x = half(u_xlat16_6 / u_xlat16_0.x);
    u_xlat16_19 = half((-float(u_xlat16_8)) * float(u_xlat16_8) + 1.0);
    u_xlat16_9.x = half(abs(u_xlat16_2.x) * u_xlat16_19 + u_xlat16_14);
    u_xlat16_19 = half(u_xlat16_3.x * u_xlat16_19 + u_xlat16_14);
    u_xlat16_19 = half(u_xlat16_19 * abs(u_xlat16_2.x));
    u_xlat16_2.x = half(-abs(float(u_xlat16_2.x)) + 1.0);
    u_xlat16_19 = half(u_xlat16_3.x * u_xlat16_9.x + u_xlat16_19);
    u_xlat16_6 = half(float(u_xlat16_19) + 9.99999975e-06);
    u_xlat16_6 = half(0.5 / float(u_xlat16_6));
    u_xlat16_19 = half(u_xlat16_0.x * u_xlat16_6);
    u_xlat16_0.x = half(float(u_xlat16_19) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_19 = half(u_xlat16_3.x * u_xlat16_0.x);
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_9.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_0.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_9.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_9.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_14 = dot(u_xlat16_9.xyz, u_xlat16_9.xyz);
    u_xlatb18 = u_xlat16_14!=0.0;
    u_xlat18 = u_xlatb18 ? 1.0 : float(0.0);
    u_xlat16_19 = half(u_xlat18 * float(u_xlat16_19));
    u_xlat16_4.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_19));
    u_xlat16_19 = half((-float(u_xlat16_20)) + 1.0);
    u_xlat16_14 = half(u_xlat16_20 * u_xlat16_20);
    u_xlat16_8 = dot(half2(u_xlat16_14), half2(u_xlat16_8));
    u_xlat16_8 = half(float(u_xlat16_8) + -0.5);
    u_xlat16_14 = half(u_xlat16_19 * u_xlat16_19);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_19 = half(u_xlat16_19 * u_xlat16_14);
    u_xlat16_5.xyz = half3((-float3(u_xlat16_9.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_9.xyz = half3(u_xlat16_5.xyz * half3(u_xlat16_19) + u_xlat16_9.xyz);
    u_xlat16_9.xyz = half3(u_xlat16_9.xyz * u_xlat16_4.xyz);
    u_xlat16_19 = half(u_xlat16_2.x * u_xlat16_2.x);
    u_xlat16_19 = half(u_xlat16_19 * u_xlat16_19);
    u_xlat16_19 = half(u_xlat16_2.x * u_xlat16_19);
    u_xlat16_19 = half(float(u_xlat16_8) * float(u_xlat16_19) + 1.0);
    u_xlat16_2.x = half((-float(u_xlat16_3.x)) + 1.0);
    u_xlat16_14 = half(u_xlat16_2.x * u_xlat16_2.x);
    u_xlat16_14 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_2.x = half(u_xlat16_2.x * u_xlat16_14);
    u_xlat16_2.x = half(float(u_xlat16_8) * float(u_xlat16_2.x) + 1.0);
    u_xlat16_19 = half(u_xlat16_19 * u_xlat16_2.x);
    u_xlat16_19 = half(u_xlat16_3.x * u_xlat16_19);
    u_xlat16_1.xyz = half3(half3(u_xlat16_19) * u_xlat16_1.xyz);
    u_xlat16_19 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_2.xyz = half3(u_xlat16_0.xyz * half3(u_xlat16_19));
    output.SV_Target0.xyz = half3(u_xlat16_2.xyz * u_xlat16_1.xyz + u_xlat16_9.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 _LightPositionRange;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD6.xyz = u_xlat0.xyz + (-_LightPositionRange.xyz);
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    vs_TEXCOORD5.xyz = hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 _LightShadowData;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTextureB0;
uniform  samplerCube _LightTexture0;
uniform  samplerCube _ShadowMapTexture;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
vec3 u_xlat5;
float u_xlat6;
mediump float u_xlat16_6;
float u_xlat7;
vec3 u_xlat8;
float u_xlat13;
bool u_xlatb13;
float u_xlat14;
float u_xlat18;
float u_xlat19;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD6.xyz, vs_TEXCOORD6.xyz);
    u_xlat0.x = sqrt(u_xlat0.x);
    u_xlat0.x = u_xlat0.x * _LightPositionRange.w;
    u_xlat0.x = u_xlat0.x * 0.970000029;
    u_xlat10_1 = texture(_ShadowMapTexture, vs_TEXCOORD6.xyz);
    u_xlatb0 = u_xlat10_1.x<u_xlat0.x;
    u_xlat0.x = (u_xlatb0) ? _LightShadowData.x : 1.0;
    u_xlat6 = dot(vs_TEXCOORD5.xyz, vs_TEXCOORD5.xyz);
    u_xlat10_1 = texture(_LightTextureB0, vec2(u_xlat6));
    u_xlat10_2 = texture(_LightTexture0, vs_TEXCOORD5.xyz);
    u_xlat16_6 = u_xlat10_1.w * u_xlat10_2.w;
    u_xlat0.x = u_xlat0.x * u_xlat16_6;
    u_xlat0.xyz = u_xlat0.xxx * _LightColor0.xyz;
    u_xlat18 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat1.xyz = vec3(u_xlat18) * vs_TEXCOORD1.xyz;
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat18 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = u_xlat2.xyz * vec3(u_xlat18) + (-u_xlat1.xyz);
    u_xlat2.xyz = vec3(u_xlat18) * u_xlat2.xyz;
    u_xlat18 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat18 = max(u_xlat18, 0.00100000005);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = vec3(u_xlat18) * u_xlat3.xyz;
    u_xlat18 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat4.xyz = vec3(u_xlat18) * vs_TEXCOORD4.xyz;
    u_xlat18 = dot(u_xlat4.xyz, u_xlat3.xyz);
    u_xlat18 = clamp(u_xlat18, 0.0, 1.0);
    u_xlat19 = dot(u_xlat2.xyz, u_xlat3.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat4.xyz, u_xlat2.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat1.x = dot(u_xlat4.xyz, (-u_xlat1.xyz));
    u_xlat7 = (-_Glossiness) + 1.0;
    u_xlat13 = u_xlat7 * u_xlat7;
    u_xlat8.x = u_xlat13 * u_xlat13;
    u_xlat14 = u_xlat18 * u_xlat8.x + (-u_xlat18);
    u_xlat18 = u_xlat14 * u_xlat18 + 1.0;
    u_xlat18 = u_xlat18 * u_xlat18 + 1.00000001e-07;
    u_xlat8.x = u_xlat8.x * 0.318309873;
    u_xlat18 = u_xlat8.x / u_xlat18;
    u_xlat8.x = (-u_xlat7) * u_xlat7 + 1.0;
    u_xlat14 = abs(u_xlat1.x) * u_xlat8.x + u_xlat13;
    u_xlat13 = u_xlat2.x * u_xlat8.x + u_xlat13;
    u_xlat13 = u_xlat13 * abs(u_xlat1.x);
    u_xlat1.x = -abs(u_xlat1.x) + 1.0;
    u_xlat13 = u_xlat2.x * u_xlat14 + u_xlat13;
    u_xlat13 = u_xlat13 + 9.99999975e-06;
    u_xlat13 = 0.5 / u_xlat13;
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat18 = u_xlat18 * 3.14159274;
    u_xlat18 = max(u_xlat18, 9.99999975e-05);
    u_xlat18 = sqrt(u_xlat18);
    u_xlat18 = u_xlat2.x * u_xlat18;
    u_xlat10_3 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat8.xyz = _Color.xyz * u_xlat10_3.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat3.xyz = u_xlat10_3.xyz * _Color.xyz;
    u_xlat8.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat8.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat13 = dot(u_xlat8.xyz, u_xlat8.xyz);
    u_xlatb13 = u_xlat13!=0.0;
    u_xlat13 = u_xlatb13 ? 1.0 : float(0.0);
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat4.xyz = u_xlat0.xyz * vec3(u_xlat18);
    u_xlat18 = (-u_xlat19) + 1.0;
    u_xlat13 = u_xlat19 * u_xlat19;
    u_xlat7 = dot(vec2(u_xlat13), vec2(u_xlat7));
    u_xlat7 = u_xlat7 + -0.5;
    u_xlat13 = u_xlat18 * u_xlat18;
    u_xlat13 = u_xlat13 * u_xlat13;
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat5.xyz = (-u_xlat8.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat8.xyz = u_xlat5.xyz * vec3(u_xlat18) + u_xlat8.xyz;
    u_xlat8.xyz = u_xlat8.xyz * u_xlat4.xyz;
    u_xlat18 = u_xlat1.x * u_xlat1.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat18 = u_xlat1.x * u_xlat18;
    u_xlat18 = u_xlat7 * u_xlat18 + 1.0;
    u_xlat1.x = (-u_xlat2.x) + 1.0;
    u_xlat13 = u_xlat1.x * u_xlat1.x;
    u_xlat13 = u_xlat13 * u_xlat13;
    u_xlat1.x = u_xlat1.x * u_xlat13;
    u_xlat1.x = u_xlat7 * u_xlat1.x + 1.0;
    u_xlat18 = u_xlat18 * u_xlat1.x;
    u_xlat18 = u_xlat2.x * u_xlat18;
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat18) * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat0.xyz + u_xlat8.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: SPOT SHADOWS_DEPTH SHADOWS_SOFT 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (592 bytes) on slot 0 {
  Matrix4x4 unity_WorldToShadow[4] at 32
  Matrix4x4 glstate_matrix_mvp at 288
  Matrix4x4 unity_ObjectToWorld at 352
  Matrix4x4 unity_WorldToObject at 416
  Matrix4x4 unity_WorldToLight at 528
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 480
  Vector4 _DetailAlbedoMap_ST at 496
  ScalarHalf _UVSec at 512
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat0.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToLight[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToLight[2] * u_xlat0.zzzz + u_xlat1;
    output.TEXCOORD5 = Globals.hlslcc_mtx4x4unity_WorldToLight[3] * u_xlat0.wwww + u_xlat1;
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_WorldToShadow[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToShadow[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToShadow[2] * u_xlat0.zzzz + u_xlat1;
    output.TEXCOORD6 = Globals.hlslcc_mtx4x4unity_WorldToShadow[3] * u_xlat0.wwww + u_xlat1;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "_LightTextureB0" to slot 2
Set 2D Texture "_ShadowMapTexture" to slot 3

Constant Buffer "Globals" (96 bytes) on slot 0 {
  VectorHalf4 _LightShadowData at 0
  VectorHalf4 _LightColor0 at 8
  VectorHalf4 _Color at 16
  ScalarHalf _Metallic at 24
  ScalarHalf _Glossiness at 26
  Vector4 _ShadowOffsets[4] at 32
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightShadowData;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    float4 _ShadowOffsets[4];
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

constexpr sampler _mtl_xl_shadow_sampler(address::clamp_to_edge, filter::linear, compare_func::greater_equal);
fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (2) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (2) ]] ,
    depth2d<float, access::sample > _ShadowMapTexture [[ texture (3) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    float3 u_xlat1;
    half3 u_xlat16_1;
    float4 u_xlat2;
    float3 u_xlat3;
    half u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    float2 u_xlat10;
    half u_xlat16_10;
    half u_xlat16_14;
    half3 u_xlat16_15;
    bool u_xlatb19;
    half u_xlat16_23;
    half u_xlat16_24;
    half u_xlat16_27;
    float u_xlat28;
    bool u_xlatb28;
    half u_xlat16_32;
    u_xlat16_0.x = half((-float(Globals._LightShadowData.x)) + 1.0);
    u_xlat1.xyz = input.TEXCOORD6.xyz / input.TEXCOORD6.www;
    u_xlat2.xyz = u_xlat1.xyz + Globals._ShadowOffsets[0].xyz;
    u_xlat2.x = _ShadowMapTexture.sample_compare(_mtl_xl_shadow_sampler, u_xlat2.xy, saturate(u_xlat2.z), level(0.0));
    u_xlat3.xyz = u_xlat1.xyz + Globals._ShadowOffsets[1].xyz;
    u_xlat2.y = _ShadowMapTexture.sample_compare(_mtl_xl_shadow_sampler, u_xlat3.xy, saturate(u_xlat3.z), level(0.0));
    u_xlat3.xyz = u_xlat1.xyz + Globals._ShadowOffsets[2].xyz;
    u_xlat1.xyz = u_xlat1.xyz + Globals._ShadowOffsets[3].xyz;
    u_xlat2.w = _ShadowMapTexture.sample_compare(_mtl_xl_shadow_sampler, u_xlat1.xy, saturate(u_xlat1.z), level(0.0));
    u_xlat2.z = _ShadowMapTexture.sample_compare(_mtl_xl_shadow_sampler, u_xlat3.xy, saturate(u_xlat3.z), level(0.0));
    u_xlat16_0 = half4(u_xlat2 * float4(u_xlat16_0.xxxx) + float4(Globals._LightShadowData.xxxx));
    u_xlat16_1.x = half(dot(float4(u_xlat16_0), float4(0.25, 0.25, 0.25, 0.25)));
    u_xlat10.xy = input.TEXCOORD5.xy / input.TEXCOORD5.ww;
    u_xlat10.xy = u_xlat10.xy + float2(0.5, 0.5);
    u_xlat16_10 = _LightTexture0.sample(sampler_LightTexture0, u_xlat10.xy).w;
    u_xlatb19 = 0.0<input.TEXCOORD5.z;
    u_xlat16_4 = (u_xlatb19) ? 1.0 : 0.0;
    u_xlat16_4 = half(u_xlat16_10 * u_xlat16_4);
    u_xlat10.x = dot(input.TEXCOORD5.xyz, input.TEXCOORD5.xyz);
    u_xlat16_10 = _LightTextureB0.sample(sampler_LightTextureB0, u_xlat10.xx).w;
    u_xlat16_4 = half(u_xlat16_10 * u_xlat16_4);
    u_xlat16_4 = half(u_xlat16_1.x * u_xlat16_4);
    u_xlat16_0.xyz = half3(half3(u_xlat16_4) * Globals._LightColor0.xyz);
    u_xlat16_27 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_27 = rsqrt(u_xlat16_27);
    u_xlat16_5.xyz = half3(half3(u_xlat16_27) * input.TEXCOORD1.xyz);
    u_xlat16_6.x = input.TEXCOORD2.w;
    u_xlat16_6.y = input.TEXCOORD3.w;
    u_xlat16_6.z = input.TEXCOORD4.w;
    u_xlat16_27 = dot(u_xlat16_6.xyz, u_xlat16_6.xyz);
    u_xlat16_27 = rsqrt(u_xlat16_27);
    u_xlat16_7.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_27) + (-u_xlat16_5.xyz));
    u_xlat16_6.xyz = half3(half3(u_xlat16_27) * u_xlat16_6.xyz);
    u_xlat16_27 = dot(u_xlat16_7.xyz, u_xlat16_7.xyz);
    u_xlat16_1.x = half(max(float(u_xlat16_27), 0.00100000005));
    u_xlat16_27 = rsqrt(u_xlat16_1.x);
    u_xlat16_7.xyz = half3(half3(u_xlat16_27) * u_xlat16_7.xyz);
    u_xlat16_27 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_27 = rsqrt(u_xlat16_27);
    u_xlat16_8.xyz = half3(half3(u_xlat16_27) * input.TEXCOORD4.xyz);
    u_xlat16_27 = dot(u_xlat16_8.xyz, u_xlat16_7.xyz);
    u_xlat16_27 = clamp(u_xlat16_27, 0.0h, 1.0h);
    u_xlat16_32 = dot(u_xlat16_6.xyz, u_xlat16_7.xyz);
    u_xlat16_32 = clamp(u_xlat16_32, 0.0h, 1.0h);
    u_xlat16_6.x = dot(u_xlat16_8.xyz, u_xlat16_6.xyz);
    u_xlat16_6.x = clamp(u_xlat16_6.x, 0.0h, 1.0h);
    u_xlat16_5.x = dot(u_xlat16_8.xyz, (-u_xlat16_5.xyz));
    u_xlat16_14 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_23 = half(u_xlat16_14 * u_xlat16_14);
    u_xlat16_15.x = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_24 = half(u_xlat16_27 * u_xlat16_15.x + (-u_xlat16_27));
    u_xlat16_1.x = half(float(u_xlat16_24) * float(u_xlat16_27) + 1.0);
    u_xlat16_1.x = half(float(u_xlat16_1.x) * float(u_xlat16_1.x) + 1.00000001e-07);
    u_xlat16_10 = half(float(u_xlat16_15.x) * 0.318309873);
    u_xlat16_1.x = half(u_xlat16_10 / u_xlat16_1.x);
    u_xlat16_27 = half((-float(u_xlat16_14)) * float(u_xlat16_14) + 1.0);
    u_xlat16_15.x = half(abs(u_xlat16_5.x) * u_xlat16_27 + u_xlat16_23);
    u_xlat16_27 = half(u_xlat16_6.x * u_xlat16_27 + u_xlat16_23);
    u_xlat16_27 = half(u_xlat16_27 * abs(u_xlat16_5.x));
    u_xlat16_5.x = half(-abs(float(u_xlat16_5.x)) + 1.0);
    u_xlat16_27 = half(u_xlat16_6.x * u_xlat16_15.x + u_xlat16_27);
    u_xlat16_10 = half(float(u_xlat16_27) + 9.99999975e-06);
    u_xlat16_10 = half(0.5 / float(u_xlat16_10));
    u_xlat16_27 = half(u_xlat16_1.x * u_xlat16_10);
    u_xlat16_1.x = half(float(u_xlat16_27) * 3.14159274);
    u_xlat16_1.x = half(max(float(u_xlat16_1.x), 9.99999975e-05));
    u_xlat16_1.x = sqrt(u_xlat16_1.x);
    u_xlat16_27 = half(u_xlat16_6.x * u_xlat16_1.x);
    u_xlat16_1.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_15.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_1.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_1.xyz = half3(u_xlat16_1.xyz * Globals._Color.xyz);
    u_xlat16_15.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_15.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_23 = dot(u_xlat16_15.xyz, u_xlat16_15.xyz);
    u_xlatb28 = u_xlat16_23!=0.0;
    u_xlat28 = u_xlatb28 ? 1.0 : float(0.0);
    u_xlat16_27 = half(float(u_xlat16_27) * u_xlat28);
    u_xlat16_7.xyz = half3(u_xlat16_0.xyz * half3(u_xlat16_27));
    u_xlat16_27 = half((-float(u_xlat16_32)) + 1.0);
    u_xlat16_23 = half(u_xlat16_32 * u_xlat16_32);
    u_xlat16_14 = dot(half2(u_xlat16_23), half2(u_xlat16_14));
    u_xlat16_14 = half(float(u_xlat16_14) + -0.5);
    u_xlat16_23 = half(u_xlat16_27 * u_xlat16_27);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_27 = half(u_xlat16_27 * u_xlat16_23);
    u_xlat16_8.xyz = half3((-float3(u_xlat16_15.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_15.xyz = half3(u_xlat16_8.xyz * half3(u_xlat16_27) + u_xlat16_15.xyz);
    u_xlat16_15.xyz = half3(u_xlat16_15.xyz * u_xlat16_7.xyz);
    u_xlat16_27 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_27 = half(u_xlat16_27 * u_xlat16_27);
    u_xlat16_27 = half(u_xlat16_5.x * u_xlat16_27);
    u_xlat16_27 = half(float(u_xlat16_14) * float(u_xlat16_27) + 1.0);
    u_xlat16_5.x = half((-float(u_xlat16_6.x)) + 1.0);
    u_xlat16_23 = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_5.x = half(u_xlat16_5.x * u_xlat16_23);
    u_xlat16_5.x = half(float(u_xlat16_14) * float(u_xlat16_5.x) + 1.0);
    u_xlat16_27 = half(u_xlat16_27 * u_xlat16_5.x);
    u_xlat16_27 = half(u_xlat16_6.x * u_xlat16_27);
    u_xlat16_0.xyz = half3(half3(u_xlat16_27) * u_xlat16_0.xyz);
    u_xlat16_27 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_5.xyz = half3(half3(u_xlat16_27) * u_xlat16_1.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_5.xyz * u_xlat16_0.xyz + u_xlat16_15.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToShadow[16];
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat1 = hlslcc_mtx4x4unity_WorldToLight[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_WorldToLight[2] * u_xlat0.zzzz + u_xlat1;
    vs_TEXCOORD5 = hlslcc_mtx4x4unity_WorldToLight[3] * u_xlat0.wwww + u_xlat1;
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_WorldToShadow[1];
    u_xlat1 = hlslcc_mtx4x4unity_WorldToShadow[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_WorldToShadow[2] * u_xlat0.zzzz + u_xlat1;
    vs_TEXCOORD6 = hlslcc_mtx4x4unity_WorldToShadow[3] * u_xlat0.wwww + u_xlat1;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightShadowData;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 _ShadowOffsets[4];
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D _LightTextureB0;
uniform  sampler2DShadow hlslcc_zcmp_ShadowMapTexture;
uniform  sampler2D _ShadowMapTexture;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
vec4 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
vec3 u_xlat5;
vec3 u_xlat6;
bool u_xlatb6;
float u_xlat7;
vec3 u_xlat8;
float u_xlat12;
float u_xlat13;
bool u_xlatb13;
float u_xlat14;
float u_xlat18;
float u_xlat19;
void main()
{
    u_xlat0.x = (-_LightShadowData.x) + 1.0;
    u_xlat6.xyz = vs_TEXCOORD6.xyz / vs_TEXCOORD6.www;
    u_xlat1.xyz = u_xlat6.xyz + _ShadowOffsets[0].xyz;
    vec3 txVec1 = vec3(u_xlat1.xy,u_xlat1.z);
    u_xlat1.x = textureLod(hlslcc_zcmp_ShadowMapTexture, txVec1, 0.0);
    u_xlat2.xyz = u_xlat6.xyz + _ShadowOffsets[1].xyz;
    vec3 txVec2 = vec3(u_xlat2.xy,u_xlat2.z);
    u_xlat1.y = textureLod(hlslcc_zcmp_ShadowMapTexture, txVec2, 0.0);
    u_xlat2.xyz = u_xlat6.xyz + _ShadowOffsets[2].xyz;
    u_xlat6.xyz = u_xlat6.xyz + _ShadowOffsets[3].xyz;
    vec3 txVec3 = vec3(u_xlat6.xy,u_xlat6.z);
    u_xlat1.w = textureLod(hlslcc_zcmp_ShadowMapTexture, txVec3, 0.0);
    vec3 txVec4 = vec3(u_xlat2.xy,u_xlat2.z);
    u_xlat1.z = textureLod(hlslcc_zcmp_ShadowMapTexture, txVec4, 0.0);
    u_xlat0 = u_xlat1 * u_xlat0.xxxx + _LightShadowData.xxxx;
    u_xlat0.x = dot(u_xlat0, vec4(0.25, 0.25, 0.25, 0.25));
    u_xlat6.xy = vs_TEXCOORD5.xy / vs_TEXCOORD5.ww;
    u_xlat6.xy = u_xlat6.xy + vec2(0.5, 0.5);
    u_xlat10_1 = texture(_LightTexture0, u_xlat6.xy);
    u_xlatb6 = 0.0<vs_TEXCOORD5.z;
    u_xlat6.x = u_xlatb6 ? 1.0 : float(0.0);
    u_xlat6.x = u_xlat10_1.w * u_xlat6.x;
    u_xlat12 = dot(vs_TEXCOORD5.xyz, vs_TEXCOORD5.xyz);
    u_xlat10_1 = texture(_LightTextureB0, vec2(u_xlat12));
    u_xlat6.x = u_xlat6.x * u_xlat10_1.w;
    u_xlat0.x = u_xlat0.x * u_xlat6.x;
    u_xlat0.xyz = u_xlat0.xxx * _LightColor0.xyz;
    u_xlat18 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat1.xyz = vec3(u_xlat18) * vs_TEXCOORD1.xyz;
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat18 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = u_xlat2.xyz * vec3(u_xlat18) + (-u_xlat1.xyz);
    u_xlat2.xyz = vec3(u_xlat18) * u_xlat2.xyz;
    u_xlat18 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat18 = max(u_xlat18, 0.00100000005);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = vec3(u_xlat18) * u_xlat3.xyz;
    u_xlat18 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat4.xyz = vec3(u_xlat18) * vs_TEXCOORD4.xyz;
    u_xlat18 = dot(u_xlat4.xyz, u_xlat3.xyz);
    u_xlat18 = clamp(u_xlat18, 0.0, 1.0);
    u_xlat19 = dot(u_xlat2.xyz, u_xlat3.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat4.xyz, u_xlat2.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat1.x = dot(u_xlat4.xyz, (-u_xlat1.xyz));
    u_xlat7 = (-_Glossiness) + 1.0;
    u_xlat13 = u_xlat7 * u_xlat7;
    u_xlat8.x = u_xlat13 * u_xlat13;
    u_xlat14 = u_xlat18 * u_xlat8.x + (-u_xlat18);
    u_xlat18 = u_xlat14 * u_xlat18 + 1.0;
    u_xlat18 = u_xlat18 * u_xlat18 + 1.00000001e-07;
    u_xlat8.x = u_xlat8.x * 0.318309873;
    u_xlat18 = u_xlat8.x / u_xlat18;
    u_xlat8.x = (-u_xlat7) * u_xlat7 + 1.0;
    u_xlat14 = abs(u_xlat1.x) * u_xlat8.x + u_xlat13;
    u_xlat13 = u_xlat2.x * u_xlat8.x + u_xlat13;
    u_xlat13 = u_xlat13 * abs(u_xlat1.x);
    u_xlat1.x = -abs(u_xlat1.x) + 1.0;
    u_xlat13 = u_xlat2.x * u_xlat14 + u_xlat13;
    u_xlat13 = u_xlat13 + 9.99999975e-06;
    u_xlat13 = 0.5 / u_xlat13;
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat18 = u_xlat18 * 3.14159274;
    u_xlat18 = max(u_xlat18, 9.99999975e-05);
    u_xlat18 = sqrt(u_xlat18);
    u_xlat18 = u_xlat2.x * u_xlat18;
    u_xlat10_3 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat8.xyz = _Color.xyz * u_xlat10_3.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat3.xyz = u_xlat10_3.xyz * _Color.xyz;
    u_xlat8.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat8.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat13 = dot(u_xlat8.xyz, u_xlat8.xyz);
    u_xlatb13 = u_xlat13!=0.0;
    u_xlat13 = u_xlatb13 ? 1.0 : float(0.0);
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat4.xyz = u_xlat0.xyz * vec3(u_xlat18);
    u_xlat18 = (-u_xlat19) + 1.0;
    u_xlat13 = u_xlat19 * u_xlat19;
    u_xlat7 = dot(vec2(u_xlat13), vec2(u_xlat7));
    u_xlat7 = u_xlat7 + -0.5;
    u_xlat13 = u_xlat18 * u_xlat18;
    u_xlat13 = u_xlat13 * u_xlat13;
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat5.xyz = (-u_xlat8.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat8.xyz = u_xlat5.xyz * vec3(u_xlat18) + u_xlat8.xyz;
    u_xlat8.xyz = u_xlat8.xyz * u_xlat4.xyz;
    u_xlat18 = u_xlat1.x * u_xlat1.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat18 = u_xlat1.x * u_xlat18;
    u_xlat18 = u_xlat7 * u_xlat18 + 1.0;
    u_xlat1.x = (-u_xlat2.x) + 1.0;
    u_xlat13 = u_xlat1.x * u_xlat1.x;
    u_xlat13 = u_xlat13 * u_xlat13;
    u_xlat1.x = u_xlat1.x * u_xlat13;
    u_xlat1.x = u_xlat7 * u_xlat1.x + 1.0;
    u_xlat18 = u_xlat18 * u_xlat1.x;
    u_xlat18 = u_xlat2.x * u_xlat18;
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat18) * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat0.xyz + u_xlat8.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: POINT SHADOWS_CUBE SHADOWS_SOFT 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (352 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Matrix4x4 unity_WorldToLight at 288
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _LightPositionRange at 32
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD6.xyz = u_xlat0.xyz + (-Globals._LightPositionRange.xyz);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    output.TEXCOORD5.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set CUBE Texture "_ShadowMapTexture" to slot 2

Constant Buffer "Globals" (44 bytes) on slot 0 {
  Vector4 _LightPositionRange at 0
  VectorHalf4 _LightShadowData at 16
  VectorHalf4 _LightColor0 at 24
  VectorHalf4 _Color at 32
  ScalarHalf _Metallic at 40
  ScalarHalf _Glossiness at 42
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    half4 _LightShadowData;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texturecube<float, access::sample > _ShadowMapTexture [[ texture (2) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float4 u_xlat0;
    half3 u_xlat16_0;
    bool4 u_xlatb0;
    float4 u_xlat1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    float3 u_xlat7;
    half u_xlat16_7;
    half u_xlat16_10;
    half3 u_xlat16_11;
    half u_xlat16_17;
    half u_xlat16_18;
    float u_xlat21;
    bool u_xlatb21;
    half u_xlat16_23;
    half u_xlat16_24;
    u_xlat0.x = dot(input.TEXCOORD6.xyz, input.TEXCOORD6.xyz);
    u_xlat0.x = sqrt(u_xlat0.x);
    u_xlat0.x = u_xlat0.x * Globals._LightPositionRange.w;
    u_xlat0.x = u_xlat0.x * 0.970000029;
    u_xlat7.xyz = input.TEXCOORD6.xyz + float3(0.0078125, 0.0078125, 0.0078125);
    u_xlat1.x = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat7.xyz).x;
    u_xlat7.xyz = input.TEXCOORD6.xyz + float3(-0.0078125, -0.0078125, 0.0078125);
    u_xlat1.y = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat7.xyz).x;
    u_xlat7.xyz = input.TEXCOORD6.xyz + float3(-0.0078125, 0.0078125, -0.0078125);
    u_xlat1.z = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat7.xyz).x;
    u_xlat7.xyz = input.TEXCOORD6.xyz + float3(0.0078125, -0.0078125, -0.0078125);
    u_xlat1.w = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat7.xyz).x;
    u_xlatb0 = (u_xlat1<u_xlat0.xxxx);
    u_xlat0.x = (u_xlatb0.x) ? float(Globals._LightShadowData.x) : float(1.0);
    u_xlat0.y = (u_xlatb0.y) ? float(Globals._LightShadowData.x) : float(1.0);
    u_xlat0.z = (u_xlatb0.z) ? float(Globals._LightShadowData.x) : float(1.0);
    u_xlat0.w = (u_xlatb0.w) ? float(Globals._LightShadowData.x) : float(1.0);
    u_xlat16_2.x = half(dot(u_xlat0, float4(0.25, 0.25, 0.25, 0.25)));
    u_xlat0.x = dot(input.TEXCOORD5.xyz, input.TEXCOORD5.xyz);
    u_xlat16_0.x = _LightTexture0.sample(sampler_LightTexture0, u_xlat0.xx).w;
    u_xlat16_0.x = half(u_xlat16_2.x * u_xlat16_0.x);
    u_xlat16_2.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_23 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_23 = rsqrt(u_xlat16_23);
    u_xlat16_3.xyz = half3(half3(u_xlat16_23) * input.TEXCOORD1.xyz);
    u_xlat16_4.x = input.TEXCOORD2.w;
    u_xlat16_4.y = input.TEXCOORD3.w;
    u_xlat16_4.z = input.TEXCOORD4.w;
    u_xlat16_23 = dot(u_xlat16_4.xyz, u_xlat16_4.xyz);
    u_xlat16_23 = rsqrt(u_xlat16_23);
    u_xlat16_5.xyz = half3(u_xlat16_4.xyz * half3(u_xlat16_23) + (-u_xlat16_3.xyz));
    u_xlat16_4.xyz = half3(half3(u_xlat16_23) * u_xlat16_4.xyz);
    u_xlat16_23 = dot(u_xlat16_5.xyz, u_xlat16_5.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_23), 0.00100000005));
    u_xlat16_23 = rsqrt(u_xlat16_0.x);
    u_xlat16_5.xyz = half3(half3(u_xlat16_23) * u_xlat16_5.xyz);
    u_xlat16_23 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_23 = rsqrt(u_xlat16_23);
    u_xlat16_6.xyz = half3(half3(u_xlat16_23) * input.TEXCOORD4.xyz);
    u_xlat16_23 = dot(u_xlat16_6.xyz, u_xlat16_5.xyz);
    u_xlat16_23 = clamp(u_xlat16_23, 0.0h, 1.0h);
    u_xlat16_24 = dot(u_xlat16_4.xyz, u_xlat16_5.xyz);
    u_xlat16_24 = clamp(u_xlat16_24, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_6.xyz, u_xlat16_4.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_3.x = dot(u_xlat16_6.xyz, (-u_xlat16_3.xyz));
    u_xlat16_10 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_17 = half(u_xlat16_10 * u_xlat16_10);
    u_xlat16_11.x = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_18 = half(u_xlat16_23 * u_xlat16_11.x + (-u_xlat16_23));
    u_xlat16_0.x = half(float(u_xlat16_18) * float(u_xlat16_23) + 1.0);
    u_xlat16_0.x = half(float(u_xlat16_0.x) * float(u_xlat16_0.x) + 1.00000001e-07);
    u_xlat16_7 = half(float(u_xlat16_11.x) * 0.318309873);
    u_xlat16_0.x = half(u_xlat16_7 / u_xlat16_0.x);
    u_xlat16_23 = half((-float(u_xlat16_10)) * float(u_xlat16_10) + 1.0);
    u_xlat16_11.x = half(abs(u_xlat16_3.x) * u_xlat16_23 + u_xlat16_17);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_23 + u_xlat16_17);
    u_xlat16_23 = half(u_xlat16_23 * abs(u_xlat16_3.x));
    u_xlat16_3.x = half(-abs(float(u_xlat16_3.x)) + 1.0);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_11.x + u_xlat16_23);
    u_xlat16_7 = half(float(u_xlat16_23) + 9.99999975e-06);
    u_xlat16_7 = half(0.5 / float(u_xlat16_7));
    u_xlat16_23 = half(u_xlat16_0.x * u_xlat16_7);
    u_xlat16_0.x = half(float(u_xlat16_23) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_0.x);
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_11.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_0.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_11.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_11.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_17 = dot(u_xlat16_11.xyz, u_xlat16_11.xyz);
    u_xlatb21 = u_xlat16_17!=0.0;
    u_xlat21 = u_xlatb21 ? 1.0 : float(0.0);
    u_xlat16_23 = half(u_xlat21 * float(u_xlat16_23));
    u_xlat16_5.xyz = half3(u_xlat16_2.xyz * half3(u_xlat16_23));
    u_xlat16_23 = half((-float(u_xlat16_24)) + 1.0);
    u_xlat16_17 = half(u_xlat16_24 * u_xlat16_24);
    u_xlat16_10 = dot(half2(u_xlat16_17), half2(u_xlat16_10));
    u_xlat16_10 = half(float(u_xlat16_10) + -0.5);
    u_xlat16_17 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_17 = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_17);
    u_xlat16_6.xyz = half3((-float3(u_xlat16_11.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_11.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_23) + u_xlat16_11.xyz);
    u_xlat16_11.xyz = half3(u_xlat16_11.xyz * u_xlat16_5.xyz);
    u_xlat16_23 = half(u_xlat16_3.x * u_xlat16_3.x);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_23 = half(u_xlat16_3.x * u_xlat16_23);
    u_xlat16_23 = half(float(u_xlat16_10) * float(u_xlat16_23) + 1.0);
    u_xlat16_3.x = half((-float(u_xlat16_4.x)) + 1.0);
    u_xlat16_17 = half(u_xlat16_3.x * u_xlat16_3.x);
    u_xlat16_17 = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_3.x = half(u_xlat16_3.x * u_xlat16_17);
    u_xlat16_3.x = half(float(u_xlat16_10) * float(u_xlat16_3.x) + 1.0);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_3.x);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_23);
    u_xlat16_2.xyz = half3(half3(u_xlat16_23) * u_xlat16_2.xyz);
    u_xlat16_23 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_0.xyz * half3(u_xlat16_23));
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_2.xyz + u_xlat16_11.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 _LightPositionRange;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD6.xyz = u_xlat0.xyz + (-_LightPositionRange.xyz);
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    vs_TEXCOORD5.xyz = hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 _LightShadowData;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  samplerCube _ShadowMapTexture;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
bvec4 u_xlatb0;
vec4 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
vec3 u_xlat5;
vec3 u_xlat6;
float u_xlat7;
vec3 u_xlat8;
float u_xlat13;
bool u_xlatb13;
float u_xlat14;
float u_xlat18;
float u_xlat19;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD6.xyz, vs_TEXCOORD6.xyz);
    u_xlat0.x = sqrt(u_xlat0.x);
    u_xlat0.x = u_xlat0.x * _LightPositionRange.w;
    u_xlat0.x = u_xlat0.x * 0.970000029;
    u_xlat6.xyz = vs_TEXCOORD6.xyz + vec3(0.0078125, 0.0078125, 0.0078125);
    u_xlat1 = texture(_ShadowMapTexture, u_xlat6.xyz);
    u_xlat6.xyz = vs_TEXCOORD6.xyz + vec3(-0.0078125, -0.0078125, 0.0078125);
    u_xlat10_2 = texture(_ShadowMapTexture, u_xlat6.xyz);
    u_xlat1.y = u_xlat10_2.x;
    u_xlat6.xyz = vs_TEXCOORD6.xyz + vec3(-0.0078125, 0.0078125, -0.0078125);
    u_xlat10_2 = texture(_ShadowMapTexture, u_xlat6.xyz);
    u_xlat1.z = u_xlat10_2.x;
    u_xlat6.xyz = vs_TEXCOORD6.xyz + vec3(0.0078125, -0.0078125, -0.0078125);
    u_xlat10_2 = texture(_ShadowMapTexture, u_xlat6.xyz);
    u_xlat1.w = u_xlat10_2.x;
    u_xlatb0 = lessThan(u_xlat1, u_xlat0.xxxx);
    u_xlat0.x = (u_xlatb0.x) ? _LightShadowData.x : float(1.0);
    u_xlat0.y = (u_xlatb0.y) ? _LightShadowData.x : float(1.0);
    u_xlat0.z = (u_xlatb0.z) ? _LightShadowData.x : float(1.0);
    u_xlat0.w = (u_xlatb0.w) ? _LightShadowData.x : float(1.0);
    u_xlat0.x = dot(u_xlat0, vec4(0.25, 0.25, 0.25, 0.25));
    u_xlat6.x = dot(vs_TEXCOORD5.xyz, vs_TEXCOORD5.xyz);
    u_xlat10_1 = texture(_LightTexture0, u_xlat6.xx);
    u_xlat0.x = u_xlat0.x * u_xlat10_1.w;
    u_xlat0.xyz = u_xlat0.xxx * _LightColor0.xyz;
    u_xlat18 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat1.xyz = vec3(u_xlat18) * vs_TEXCOORD1.xyz;
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat18 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = u_xlat2.xyz * vec3(u_xlat18) + (-u_xlat1.xyz);
    u_xlat2.xyz = vec3(u_xlat18) * u_xlat2.xyz;
    u_xlat18 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat18 = max(u_xlat18, 0.00100000005);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = vec3(u_xlat18) * u_xlat3.xyz;
    u_xlat18 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat4.xyz = vec3(u_xlat18) * vs_TEXCOORD4.xyz;
    u_xlat18 = dot(u_xlat4.xyz, u_xlat3.xyz);
    u_xlat18 = clamp(u_xlat18, 0.0, 1.0);
    u_xlat19 = dot(u_xlat2.xyz, u_xlat3.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat4.xyz, u_xlat2.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat1.x = dot(u_xlat4.xyz, (-u_xlat1.xyz));
    u_xlat7 = (-_Glossiness) + 1.0;
    u_xlat13 = u_xlat7 * u_xlat7;
    u_xlat8.x = u_xlat13 * u_xlat13;
    u_xlat14 = u_xlat18 * u_xlat8.x + (-u_xlat18);
    u_xlat18 = u_xlat14 * u_xlat18 + 1.0;
    u_xlat18 = u_xlat18 * u_xlat18 + 1.00000001e-07;
    u_xlat8.x = u_xlat8.x * 0.318309873;
    u_xlat18 = u_xlat8.x / u_xlat18;
    u_xlat8.x = (-u_xlat7) * u_xlat7 + 1.0;
    u_xlat14 = abs(u_xlat1.x) * u_xlat8.x + u_xlat13;
    u_xlat13 = u_xlat2.x * u_xlat8.x + u_xlat13;
    u_xlat13 = u_xlat13 * abs(u_xlat1.x);
    u_xlat1.x = -abs(u_xlat1.x) + 1.0;
    u_xlat13 = u_xlat2.x * u_xlat14 + u_xlat13;
    u_xlat13 = u_xlat13 + 9.99999975e-06;
    u_xlat13 = 0.5 / u_xlat13;
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat18 = u_xlat18 * 3.14159274;
    u_xlat18 = max(u_xlat18, 9.99999975e-05);
    u_xlat18 = sqrt(u_xlat18);
    u_xlat18 = u_xlat2.x * u_xlat18;
    u_xlat10_3 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat8.xyz = _Color.xyz * u_xlat10_3.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat3.xyz = u_xlat10_3.xyz * _Color.xyz;
    u_xlat8.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat8.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat13 = dot(u_xlat8.xyz, u_xlat8.xyz);
    u_xlatb13 = u_xlat13!=0.0;
    u_xlat13 = u_xlatb13 ? 1.0 : float(0.0);
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat4.xyz = u_xlat0.xyz * vec3(u_xlat18);
    u_xlat18 = (-u_xlat19) + 1.0;
    u_xlat13 = u_xlat19 * u_xlat19;
    u_xlat7 = dot(vec2(u_xlat13), vec2(u_xlat7));
    u_xlat7 = u_xlat7 + -0.5;
    u_xlat13 = u_xlat18 * u_xlat18;
    u_xlat13 = u_xlat13 * u_xlat13;
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat5.xyz = (-u_xlat8.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat8.xyz = u_xlat5.xyz * vec3(u_xlat18) + u_xlat8.xyz;
    u_xlat8.xyz = u_xlat8.xyz * u_xlat4.xyz;
    u_xlat18 = u_xlat1.x * u_xlat1.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat18 = u_xlat1.x * u_xlat18;
    u_xlat18 = u_xlat7 * u_xlat18 + 1.0;
    u_xlat1.x = (-u_xlat2.x) + 1.0;
    u_xlat13 = u_xlat1.x * u_xlat1.x;
    u_xlat13 = u_xlat13 * u_xlat13;
    u_xlat1.x = u_xlat1.x * u_xlat13;
    u_xlat1.x = u_xlat7 * u_xlat1.x + 1.0;
    u_xlat18 = u_xlat18 * u_xlat1.x;
    u_xlat18 = u_xlat2.x * u_xlat18;
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat18) * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat0.xyz + u_xlat8.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: POINT_COOKIE SHADOWS_CUBE SHADOWS_SOFT 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (352 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Matrix4x4 unity_WorldToLight at 288
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _LightPositionRange at 32
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyw = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD6.xyz = u_xlat0.xyz + (-Globals._LightPositionRange.xyz);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    output.TEXCOORD5.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTextureB0" to slot 1
Set CUBE Texture "_LightTexture0" to slot 2
Set CUBE Texture "_ShadowMapTexture" to slot 3

Constant Buffer "Globals" (44 bytes) on slot 0 {
  Vector4 _LightPositionRange at 0
  VectorHalf4 _LightShadowData at 16
  VectorHalf4 _LightColor0 at 24
  VectorHalf4 _Color at 32
  ScalarHalf _Metallic at 40
  ScalarHalf _Glossiness at 42
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    half4 _LightShadowData;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (1) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (1) ]] ,
    texturecube<half, access::sample > _LightTexture0 [[ texture (2) ]] ,
    sampler sampler_LightTexture0 [[ sampler (2) ]] ,
    texturecube<float, access::sample > _ShadowMapTexture [[ texture (3) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float4 u_xlat0;
    half3 u_xlat16_0;
    bool4 u_xlatb0;
    float4 u_xlat1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    float3 u_xlat7;
    half u_xlat16_7;
    half u_xlat16_10;
    half3 u_xlat16_11;
    half u_xlat16_17;
    half u_xlat16_18;
    float u_xlat21;
    bool u_xlatb21;
    half u_xlat16_23;
    half u_xlat16_24;
    u_xlat0.x = dot(input.TEXCOORD6.xyz, input.TEXCOORD6.xyz);
    u_xlat0.x = sqrt(u_xlat0.x);
    u_xlat0.x = u_xlat0.x * Globals._LightPositionRange.w;
    u_xlat0.x = u_xlat0.x * 0.970000029;
    u_xlat7.xyz = input.TEXCOORD6.xyz + float3(0.0078125, 0.0078125, 0.0078125);
    u_xlat1.x = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat7.xyz).x;
    u_xlat7.xyz = input.TEXCOORD6.xyz + float3(-0.0078125, -0.0078125, 0.0078125);
    u_xlat1.y = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat7.xyz).x;
    u_xlat7.xyz = input.TEXCOORD6.xyz + float3(-0.0078125, 0.0078125, -0.0078125);
    u_xlat1.z = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat7.xyz).x;
    u_xlat7.xyz = input.TEXCOORD6.xyz + float3(0.0078125, -0.0078125, -0.0078125);
    u_xlat1.w = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat7.xyz).x;
    u_xlatb0 = (u_xlat1<u_xlat0.xxxx);
    u_xlat0.x = (u_xlatb0.x) ? float(Globals._LightShadowData.x) : float(1.0);
    u_xlat0.y = (u_xlatb0.y) ? float(Globals._LightShadowData.x) : float(1.0);
    u_xlat0.z = (u_xlatb0.z) ? float(Globals._LightShadowData.x) : float(1.0);
    u_xlat0.w = (u_xlatb0.w) ? float(Globals._LightShadowData.x) : float(1.0);
    u_xlat16_2.x = half(dot(u_xlat0, float4(0.25, 0.25, 0.25, 0.25)));
    u_xlat0.x = dot(input.TEXCOORD5.xyz, input.TEXCOORD5.xyz);
    u_xlat16_0.x = _LightTextureB0.sample(sampler_LightTextureB0, u_xlat0.xx).w;
    u_xlat16_7 = _LightTexture0.sample(sampler_LightTexture0, input.TEXCOORD5.xyz).w;
    u_xlat16_0.x = half(u_xlat16_7 * u_xlat16_0.x);
    u_xlat16_0.x = half(u_xlat16_2.x * u_xlat16_0.x);
    u_xlat16_2.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_23 = dot(input.TEXCOORD1.xyz, input.TEXCOORD1.xyz);
    u_xlat16_23 = rsqrt(u_xlat16_23);
    u_xlat16_3.xyz = half3(half3(u_xlat16_23) * input.TEXCOORD1.xyz);
    u_xlat16_4.x = input.TEXCOORD2.w;
    u_xlat16_4.y = input.TEXCOORD3.w;
    u_xlat16_4.z = input.TEXCOORD4.w;
    u_xlat16_23 = dot(u_xlat16_4.xyz, u_xlat16_4.xyz);
    u_xlat16_23 = rsqrt(u_xlat16_23);
    u_xlat16_5.xyz = half3(u_xlat16_4.xyz * half3(u_xlat16_23) + (-u_xlat16_3.xyz));
    u_xlat16_4.xyz = half3(half3(u_xlat16_23) * u_xlat16_4.xyz);
    u_xlat16_23 = dot(u_xlat16_5.xyz, u_xlat16_5.xyz);
    u_xlat16_0.x = half(max(float(u_xlat16_23), 0.00100000005));
    u_xlat16_23 = rsqrt(u_xlat16_0.x);
    u_xlat16_5.xyz = half3(half3(u_xlat16_23) * u_xlat16_5.xyz);
    u_xlat16_23 = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_23 = rsqrt(u_xlat16_23);
    u_xlat16_6.xyz = half3(half3(u_xlat16_23) * input.TEXCOORD4.xyz);
    u_xlat16_23 = dot(u_xlat16_6.xyz, u_xlat16_5.xyz);
    u_xlat16_23 = clamp(u_xlat16_23, 0.0h, 1.0h);
    u_xlat16_24 = dot(u_xlat16_4.xyz, u_xlat16_5.xyz);
    u_xlat16_24 = clamp(u_xlat16_24, 0.0h, 1.0h);
    u_xlat16_4.x = dot(u_xlat16_6.xyz, u_xlat16_4.xyz);
    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0h, 1.0h);
    u_xlat16_3.x = dot(u_xlat16_6.xyz, (-u_xlat16_3.xyz));
    u_xlat16_10 = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_17 = half(u_xlat16_10 * u_xlat16_10);
    u_xlat16_11.x = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_18 = half(u_xlat16_23 * u_xlat16_11.x + (-u_xlat16_23));
    u_xlat16_0.x = half(float(u_xlat16_18) * float(u_xlat16_23) + 1.0);
    u_xlat16_0.x = half(float(u_xlat16_0.x) * float(u_xlat16_0.x) + 1.00000001e-07);
    u_xlat16_7 = half(float(u_xlat16_11.x) * 0.318309873);
    u_xlat16_0.x = half(u_xlat16_7 / u_xlat16_0.x);
    u_xlat16_23 = half((-float(u_xlat16_10)) * float(u_xlat16_10) + 1.0);
    u_xlat16_11.x = half(abs(u_xlat16_3.x) * u_xlat16_23 + u_xlat16_17);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_23 + u_xlat16_17);
    u_xlat16_23 = half(u_xlat16_23 * abs(u_xlat16_3.x));
    u_xlat16_3.x = half(-abs(float(u_xlat16_3.x)) + 1.0);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_11.x + u_xlat16_23);
    u_xlat16_7 = half(float(u_xlat16_23) + 9.99999975e-06);
    u_xlat16_7 = half(0.5 / float(u_xlat16_7));
    u_xlat16_23 = half(u_xlat16_0.x * u_xlat16_7);
    u_xlat16_0.x = half(float(u_xlat16_23) * 3.14159274);
    u_xlat16_0.x = half(max(float(u_xlat16_0.x), 9.99999975e-05));
    u_xlat16_0.x = sqrt(u_xlat16_0.x);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_0.x);
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_11.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_0.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_11.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_11.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_17 = dot(u_xlat16_11.xyz, u_xlat16_11.xyz);
    u_xlatb21 = u_xlat16_17!=0.0;
    u_xlat21 = u_xlatb21 ? 1.0 : float(0.0);
    u_xlat16_23 = half(u_xlat21 * float(u_xlat16_23));
    u_xlat16_5.xyz = half3(u_xlat16_2.xyz * half3(u_xlat16_23));
    u_xlat16_23 = half((-float(u_xlat16_24)) + 1.0);
    u_xlat16_17 = half(u_xlat16_24 * u_xlat16_24);
    u_xlat16_10 = dot(half2(u_xlat16_17), half2(u_xlat16_10));
    u_xlat16_10 = half(float(u_xlat16_10) + -0.5);
    u_xlat16_17 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_17 = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_17);
    u_xlat16_6.xyz = half3((-float3(u_xlat16_11.xyz)) + float3(1.0, 1.0, 1.0));
    u_xlat16_11.xyz = half3(u_xlat16_6.xyz * half3(u_xlat16_23) + u_xlat16_11.xyz);
    u_xlat16_11.xyz = half3(u_xlat16_11.xyz * u_xlat16_5.xyz);
    u_xlat16_23 = half(u_xlat16_3.x * u_xlat16_3.x);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_23);
    u_xlat16_23 = half(u_xlat16_3.x * u_xlat16_23);
    u_xlat16_23 = half(float(u_xlat16_10) * float(u_xlat16_23) + 1.0);
    u_xlat16_3.x = half((-float(u_xlat16_4.x)) + 1.0);
    u_xlat16_17 = half(u_xlat16_3.x * u_xlat16_3.x);
    u_xlat16_17 = half(u_xlat16_17 * u_xlat16_17);
    u_xlat16_3.x = half(u_xlat16_3.x * u_xlat16_17);
    u_xlat16_3.x = half(float(u_xlat16_10) * float(u_xlat16_3.x) + 1.0);
    u_xlat16_23 = half(u_xlat16_23 * u_xlat16_3.x);
    u_xlat16_23 = half(u_xlat16_4.x * u_xlat16_23);
    u_xlat16_2.xyz = half3(half3(u_xlat16_23) * u_xlat16_2.xyz);
    u_xlat16_23 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_3.xyz = half3(u_xlat16_0.xyz * half3(u_xlat16_23));
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * u_xlat16_2.xyz + u_xlat16_11.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 _LightPositionRange;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD6.xyz = u_xlat0.xyz + (-_LightPositionRange.xyz);
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    vs_TEXCOORD5.xyz = hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 _LightShadowData;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTextureB0;
uniform  samplerCube _LightTexture0;
uniform  samplerCube _ShadowMapTexture;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
bvec4 u_xlatb0;
vec4 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
vec3 u_xlat5;
vec3 u_xlat6;
mediump float u_xlat16_6;
float u_xlat7;
vec3 u_xlat8;
float u_xlat13;
bool u_xlatb13;
float u_xlat14;
float u_xlat18;
float u_xlat19;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD6.xyz, vs_TEXCOORD6.xyz);
    u_xlat0.x = sqrt(u_xlat0.x);
    u_xlat0.x = u_xlat0.x * _LightPositionRange.w;
    u_xlat0.x = u_xlat0.x * 0.970000029;
    u_xlat6.xyz = vs_TEXCOORD6.xyz + vec3(0.0078125, 0.0078125, 0.0078125);
    u_xlat1 = texture(_ShadowMapTexture, u_xlat6.xyz);
    u_xlat6.xyz = vs_TEXCOORD6.xyz + vec3(-0.0078125, -0.0078125, 0.0078125);
    u_xlat10_2 = texture(_ShadowMapTexture, u_xlat6.xyz);
    u_xlat1.y = u_xlat10_2.x;
    u_xlat6.xyz = vs_TEXCOORD6.xyz + vec3(-0.0078125, 0.0078125, -0.0078125);
    u_xlat10_2 = texture(_ShadowMapTexture, u_xlat6.xyz);
    u_xlat1.z = u_xlat10_2.x;
    u_xlat6.xyz = vs_TEXCOORD6.xyz + vec3(0.0078125, -0.0078125, -0.0078125);
    u_xlat10_2 = texture(_ShadowMapTexture, u_xlat6.xyz);
    u_xlat1.w = u_xlat10_2.x;
    u_xlatb0 = lessThan(u_xlat1, u_xlat0.xxxx);
    u_xlat0.x = (u_xlatb0.x) ? _LightShadowData.x : float(1.0);
    u_xlat0.y = (u_xlatb0.y) ? _LightShadowData.x : float(1.0);
    u_xlat0.z = (u_xlatb0.z) ? _LightShadowData.x : float(1.0);
    u_xlat0.w = (u_xlatb0.w) ? _LightShadowData.x : float(1.0);
    u_xlat0.x = dot(u_xlat0, vec4(0.25, 0.25, 0.25, 0.25));
    u_xlat6.x = dot(vs_TEXCOORD5.xyz, vs_TEXCOORD5.xyz);
    u_xlat10_1 = texture(_LightTextureB0, u_xlat6.xx);
    u_xlat10_2 = texture(_LightTexture0, vs_TEXCOORD5.xyz);
    u_xlat16_6 = u_xlat10_1.w * u_xlat10_2.w;
    u_xlat0.x = u_xlat0.x * u_xlat16_6;
    u_xlat0.xyz = u_xlat0.xxx * _LightColor0.xyz;
    u_xlat18 = dot(vs_TEXCOORD1.xyz, vs_TEXCOORD1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat1.xyz = vec3(u_xlat18) * vs_TEXCOORD1.xyz;
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat18 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = u_xlat2.xyz * vec3(u_xlat18) + (-u_xlat1.xyz);
    u_xlat2.xyz = vec3(u_xlat18) * u_xlat2.xyz;
    u_xlat18 = dot(u_xlat3.xyz, u_xlat3.xyz);
    u_xlat18 = max(u_xlat18, 0.00100000005);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat3.xyz = vec3(u_xlat18) * u_xlat3.xyz;
    u_xlat18 = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat4.xyz = vec3(u_xlat18) * vs_TEXCOORD4.xyz;
    u_xlat18 = dot(u_xlat4.xyz, u_xlat3.xyz);
    u_xlat18 = clamp(u_xlat18, 0.0, 1.0);
    u_xlat19 = dot(u_xlat2.xyz, u_xlat3.xyz);
    u_xlat19 = clamp(u_xlat19, 0.0, 1.0);
    u_xlat2.x = dot(u_xlat4.xyz, u_xlat2.xyz);
    u_xlat2.x = clamp(u_xlat2.x, 0.0, 1.0);
    u_xlat1.x = dot(u_xlat4.xyz, (-u_xlat1.xyz));
    u_xlat7 = (-_Glossiness) + 1.0;
    u_xlat13 = u_xlat7 * u_xlat7;
    u_xlat8.x = u_xlat13 * u_xlat13;
    u_xlat14 = u_xlat18 * u_xlat8.x + (-u_xlat18);
    u_xlat18 = u_xlat14 * u_xlat18 + 1.0;
    u_xlat18 = u_xlat18 * u_xlat18 + 1.00000001e-07;
    u_xlat8.x = u_xlat8.x * 0.318309873;
    u_xlat18 = u_xlat8.x / u_xlat18;
    u_xlat8.x = (-u_xlat7) * u_xlat7 + 1.0;
    u_xlat14 = abs(u_xlat1.x) * u_xlat8.x + u_xlat13;
    u_xlat13 = u_xlat2.x * u_xlat8.x + u_xlat13;
    u_xlat13 = u_xlat13 * abs(u_xlat1.x);
    u_xlat1.x = -abs(u_xlat1.x) + 1.0;
    u_xlat13 = u_xlat2.x * u_xlat14 + u_xlat13;
    u_xlat13 = u_xlat13 + 9.99999975e-06;
    u_xlat13 = 0.5 / u_xlat13;
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat18 = u_xlat18 * 3.14159274;
    u_xlat18 = max(u_xlat18, 9.99999975e-05);
    u_xlat18 = sqrt(u_xlat18);
    u_xlat18 = u_xlat2.x * u_xlat18;
    u_xlat10_3 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat8.xyz = _Color.xyz * u_xlat10_3.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat3.xyz = u_xlat10_3.xyz * _Color.xyz;
    u_xlat8.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat8.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat13 = dot(u_xlat8.xyz, u_xlat8.xyz);
    u_xlatb13 = u_xlat13!=0.0;
    u_xlat13 = u_xlatb13 ? 1.0 : float(0.0);
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat4.xyz = u_xlat0.xyz * vec3(u_xlat18);
    u_xlat18 = (-u_xlat19) + 1.0;
    u_xlat13 = u_xlat19 * u_xlat19;
    u_xlat7 = dot(vec2(u_xlat13), vec2(u_xlat7));
    u_xlat7 = u_xlat7 + -0.5;
    u_xlat13 = u_xlat18 * u_xlat18;
    u_xlat13 = u_xlat13 * u_xlat13;
    u_xlat18 = u_xlat18 * u_xlat13;
    u_xlat5.xyz = (-u_xlat8.xyz) + vec3(1.0, 1.0, 1.0);
    u_xlat8.xyz = u_xlat5.xyz * vec3(u_xlat18) + u_xlat8.xyz;
    u_xlat8.xyz = u_xlat8.xyz * u_xlat4.xyz;
    u_xlat18 = u_xlat1.x * u_xlat1.x;
    u_xlat18 = u_xlat18 * u_xlat18;
    u_xlat18 = u_xlat1.x * u_xlat18;
    u_xlat18 = u_xlat7 * u_xlat18 + 1.0;
    u_xlat1.x = (-u_xlat2.x) + 1.0;
    u_xlat13 = u_xlat1.x * u_xlat1.x;
    u_xlat13 = u_xlat13 * u_xlat13;
    u_xlat1.x = u_xlat1.x * u_xlat13;
    u_xlat1.x = u_xlat7 * u_xlat1.x + 1.0;
    u_xlat18 = u_xlat18 * u_xlat1.x;
    u_xlat18 = u_xlat2.x * u_xlat18;
    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;
    u_xlat18 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = vec3(u_xlat18) * u_xlat3.xyz;
    SV_Target0.xyz = u_xlat1.xyz * u_xlat0.xyz + u_xlat8.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

 }
 Pass {
  Name "SHADOWCASTER"
  Tags { "LIGHTMODE"="SHADOWCASTER" "SHADOWSUPPORT"="true" "RenderType"="Opaque" "PerformanceChecks"="False" }
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
Keywords set in this variant: SHADOWS_DEPTH 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"

Constant Buffer "Globals" (288 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Matrix4x4 unity_MatrixVP at 224
  Vector4 _WorldSpaceLightPos0 at 0
  Vector4 unity_LightShadowBias at 16
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    bool u_xlatb2;
    float u_xlat6;
    float u_xlat9;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz;
    u_xlat1.xyz = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat1.xyz = float3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat9 = (-u_xlat9) * u_xlat9 + 1.0;
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * Globals.unity_LightShadowBias.z;
    u_xlat0.xyz = (-u_xlat2.xyz) * float3(u_xlat9) + u_xlat0.xyz;
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat1 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat1 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat1;
    u_xlat1 = u_xlat1 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb2 = Globals.unity_LightShadowBias.z!=0.0;
    u_xlat0 = (bool(u_xlatb2)) ? u_xlat0 : u_xlat1;
    u_xlat1.x = Globals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = Globals.unity_LightShadowBias.y * u_xlat0.x + u_xlat6;
    return output;
}


-- Fragment shader for "metal":
Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
)
{
    Mtl_FragmentOut output;
    output.SV_Target0 = half4(0.0, 0.0, 0.0, 0.0);
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_LightShadowBias;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
vec4 u_xlat0;
vec4 u_xlat1;
vec3 u_xlat2;
bool u_xlatb2;
float u_xlat6;
float u_xlat9;
void main()
{
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + hlslcc_mtx4x4unity_ObjectToWorld[3].xyz;
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat2.xyz = vec3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat9 = (-u_xlat9) * u_xlat9 + 1.0;
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * unity_LightShadowBias.z;
    u_xlat0.xyz = (-u_xlat2.xyz) * vec3(u_xlat9) + u_xlat0.xyz;
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat1 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat1 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat1;
    u_xlat1 = u_xlat1 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb2 = unity_LightShadowBias.z!=0.0;
    u_xlat0 = (bool(u_xlatb2)) ? u_xlat0 : u_xlat1;
    u_xlat1.x = unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = clamp(u_xlat1.x, 0.0, 1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = max((-u_xlat0.w), u_xlat6);
    gl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    gl_Position.z = unity_LightShadowBias.y * u_xlat0.x + u_xlat6;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

layout(location = 0) out vec4 SV_Target0;
void main()
{
    SV_Target0 = vec4(0.0, 0.0, 0.0, 0.0);
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: SHADOWS_CUBE 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"

Constant Buffer "Globals" (144 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 16
  Matrix4x4 unity_ObjectToWorld at 80
  Vector4 _LightPositionRange at 0
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};

struct Mtl_VertexOut
{
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 mtl_Position [[ position ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    output.TEXCOORD0.xyz = u_xlat0.xyz + (-Globals._LightPositionRange.xyz);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    return output;
}


-- Fragment shader for "metal":
Constant Buffer "Globals" (32 bytes) on slot 0 {
  Vector4 _LightPositionRange at 0
  Vector4 unity_LightShadowBias at 16
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    float4 unity_LightShadowBias;
};

struct Mtl_FragmentIn
{
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float4 u_xlat0;
    u_xlat0.x = dot(input.TEXCOORD0.xyz, input.TEXCOORD0.xyz);
    u_xlat0.x = sqrt(u_xlat0.x);
    u_xlat0.x = u_xlat0.x + Globals.unity_LightShadowBias.x;
    u_xlat0 = u_xlat0.xxxx * Globals._LightPositionRange.wwww;
    output.SV_Target0 = half4(u_xlat0);
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
in  vec4 in_POSITION0;
out vec3 vs_TEXCOORD0;
vec4 u_xlat0;
void main()
{
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD0.xyz = u_xlat0.xyz + (-_LightPositionRange.xyz);
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 unity_LightShadowBias;
in  vec3 vs_TEXCOORD0;
layout(location = 0) out vec4 SV_Target0;
float u_xlat0;
void main()
{
    u_xlat0 = dot(vs_TEXCOORD0.xyz, vs_TEXCOORD0.xyz);
    u_xlat0 = sqrt(u_xlat0);
    u_xlat0 = u_xlat0 + unity_LightShadowBias.x;
    SV_Target0 = vec4(u_xlat0) * _LightPositionRange.wwww;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

 }
 Pass {
  Name "DEFERRED"
  Tags { "LIGHTMODE"="Deferred" "RenderType"="Opaque" "PerformanceChecks"="False" }
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
No keywords set in this variant.
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_2 = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_2 = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_2)));
    u_xlat16_0 = half4(u_xlat0.yzzx * u_xlat0.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_2) + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 3D Texture "unity_ProbeVolumeSH" to slot 2

Constant Buffer "Globals" (158 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (2) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    float3 u_xlat3;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    bool u_xlatb3;
    float3 u_xlat4;
    half4 u_xlat10_4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = input.TEXCOORD6.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD6.xxx + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD6.zzz + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : input.TEXCOORD6.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat10_3 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw));
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_4 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz));
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_2 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz));
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(float4(u_xlat10_3), float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(float4(u_xlat10_4), float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(float4(u_xlat10_2), float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz);
    output.SV_Target3.xyz = exp2((-u_xlat16_6.xyz));
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat6 = u_xlat0.y * u_xlat0.y;
    u_xlat6 = u_xlat0.x * u_xlat0.x + (-u_xlat6);
    u_xlat1 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat0.x = dot(unity_SHBr, u_xlat1);
    u_xlat0.y = dot(unity_SHBg, u_xlat1);
    u_xlat0.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat6) + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
lowp vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat7;
float u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD6.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD6.xxx + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD6.zzz + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : vs_TEXCOORD6.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz;
    SV_Target3.xyz = exp2((-u_xlat2.xyz));
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: _EMISSION 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_2 = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_2 = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_2)));
    u_xlat16_0 = half4(u_xlat0.yzzx * u_xlat0.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_2) + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "_EmissionMap" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (168 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
  VectorHalf4 _EmissionColor at 160
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (2) ]] ,
    sampler sampler_EmissionMap [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    float3 u_xlat3;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    bool u_xlatb3;
    float3 u_xlat4;
    half4 u_xlat10_4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = input.TEXCOORD6.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD6.xxx + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD6.zzz + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : input.TEXCOORD6.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat10_3 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw));
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_4 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz));
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_2 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz));
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(float4(u_xlat10_3), float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(float4(u_xlat10_4), float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(float4(u_xlat10_2), float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    u_xlat16_3.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * Globals._EmissionColor.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz + u_xlat16_3.xyz);
    output.SV_Target3.xyz = exp2((-u_xlat16_6.xyz));
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat6 = u_xlat0.y * u_xlat0.y;
    u_xlat6 = u_xlat0.x * u_xlat0.x + (-u_xlat6);
    u_xlat1 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat0.x = dot(unity_SHBr, u_xlat1);
    u_xlat0.y = dot(unity_SHBg, u_xlat1);
    u_xlat0.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat6) + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
lowp vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat7;
float u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD6.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD6.xxx + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD6.zzz + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : vs_TEXCOORD6.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    u_xlat10_3 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    u_xlat3.xyz = u_xlat10_3.xyz * _EmissionColor.xyz;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz + u_xlat3.xyz;
    SV_Target3.xyz = exp2((-u_xlat2.xyz));
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 unity_WorldTransformParams at 240
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    half4 TANGENT0 [[ attribute(4) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_2.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_2.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_2.x)));
    u_xlat16_0 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_2.xxx + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 3D Texture "unity_ProbeVolumeSH" to slot 2

Constant Buffer "Globals" (158 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (2) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    float3 u_xlat3;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    bool u_xlatb3;
    float3 u_xlat4;
    half4 u_xlat10_4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = input.TEXCOORD6.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD6.xxx + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD6.zzz + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : input.TEXCOORD6.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat10_3 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw));
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_4 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz));
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_2 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz));
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(float4(u_xlat10_3), float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(float4(u_xlat10_4), float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(float4(u_xlat10_2), float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz);
    output.SV_Target3.xyz = exp2((-u_xlat16_6.xyz));
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat0.x = u_xlat1.y * u_xlat1.y;
    u_xlat0.x = u_xlat1.x * u_xlat1.x + (-u_xlat0.x);
    u_xlat1 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat2.x = dot(unity_SHBr, u_xlat1);
    u_xlat2.y = dot(unity_SHBg, u_xlat1);
    u_xlat2.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * u_xlat0.xxx + u_xlat2.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
lowp vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat7;
float u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD6.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD6.xxx + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD6.zzz + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : vs_TEXCOORD6.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz;
    SV_Target3.xyz = exp2((-u_xlat2.xyz));
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRLIGHTMAP_COMBINED _EMISSION 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 unity_WorldTransformParams at 240
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    half4 TANGENT0 [[ attribute(4) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_2.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_2.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_2.x)));
    u_xlat16_0 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_2.xxx + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "_EmissionMap" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (168 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
  VectorHalf4 _EmissionColor at 160
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (2) ]] ,
    sampler sampler_EmissionMap [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    float3 u_xlat3;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    bool u_xlatb3;
    float3 u_xlat4;
    half4 u_xlat10_4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = input.TEXCOORD6.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD6.xxx + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD6.zzz + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : input.TEXCOORD6.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat10_3 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw));
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_4 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz));
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_2 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz));
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(float4(u_xlat10_3), float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(float4(u_xlat10_4), float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(float4(u_xlat10_2), float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    u_xlat16_3.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * Globals._EmissionColor.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz + u_xlat16_3.xyz);
    output.SV_Target3.xyz = exp2((-u_xlat16_6.xyz));
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat0.x = u_xlat1.y * u_xlat1.y;
    u_xlat0.x = u_xlat1.x * u_xlat1.x + (-u_xlat0.x);
    u_xlat1 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat2.x = dot(unity_SHBr, u_xlat1);
    u_xlat2.y = dot(unity_SHBg, u_xlat1);
    u_xlat2.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * u_xlat0.xxx + u_xlat2.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
lowp vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat7;
float u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD6.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD6.xxx + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD6.zzz + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : vs_TEXCOORD6.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    u_xlat10_3 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    u_xlat3.xyz = u_xlat10_3.xyz * _EmissionColor.xyz;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz + u_xlat3.xyz;
    SV_Target3.xyz = exp2((-u_xlat2.xyz));
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 16
  Matrix4x4 unity_ObjectToWorld at 80
  Matrix4x4 unity_WorldToObject at 144
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_WorldTransformParams at 208
  Vector4 unity_DynamicLightmapST at 224
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    float2 TEXCOORD2 [[ attribute(4) ]] ;
    half4 TANGENT0 [[ attribute(5) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    float u_xlat9;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat1.xyz = float3(u_xlat9) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.w = 0.0;
    u_xlat0.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    output.TEXCOORD5.zw = half2(u_xlat0.xy);
    output.TEXCOORD5.xy = half2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "unity_DynamicLightmap" to slot 2
Set 2D Texture "unity_DynamicDirectionality" to slot 3

Constant Buffer "Globals" (22 bytes) on slot 0 {
  VectorHalf4 unity_DynamicLightmap_HDR at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
  ScalarHalf _OcclusionStrength at 20
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_DynamicLightmap_HDR;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<float, access::sample > unity_DynamicLightmap [[ texture (2) ]] ,
    sampler samplerunity_DynamicLightmap [[ sampler (2) ]] ,
    texture2d<float, access::sample > unity_DynamicDirectionality [[ texture (3) ]] ,
    sampler samplerunity_DynamicDirectionality [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    half3 u_xlat16_4;
    half3 u_xlat16_6;
    u_xlat16_0.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_1.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_0.x * Globals._OcclusionStrength + u_xlat16_1.x);
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_2.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_3.xyz = half3(u_xlat16_2.xyz * Globals._Color.xyz);
    u_xlat16_6.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_2.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_6.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_0.xyz = half3(u_xlat16_1.xxx * u_xlat16_3.xyz);
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    u_xlat16_1.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_1.x = rsqrt(u_xlat16_1.x);
    u_xlat16_1.xyz = half3(u_xlat16_1.xxx * input.TEXCOORD4.xyz);
    u_xlat16_2.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target2.xyz = u_xlat16_2.xyz;
    output.SV_Target2.w = 1.0;
    u_xlat10_2 = half4(unity_DynamicDirectionality.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_4.xyz = half3(float3(u_xlat10_2.xyz) + float3(-0.5, -0.5, -0.5));
    u_xlat16_2.x = half(max(float(u_xlat10_2.w), 9.99999975e-05));
    u_xlat16_1.x = dot(u_xlat16_1.xyz, u_xlat16_4.xyz);
    u_xlat16_1.x = half(float(u_xlat16_1.x) + 0.5);
    u_xlat10_3 = half4(unity_DynamicLightmap.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_6.x = half(float(u_xlat10_3.w) * float(Globals.unity_DynamicLightmap_HDR.x));
    u_xlat16_6.xyz = half3(float3(u_xlat10_3.xyz) * float3(u_xlat16_6.xxx));
    u_xlat16_6.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz * Globals.unity_DynamicLightmap_HDR.yyy);
    u_xlat16_6.xyz = exp2(u_xlat16_6.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_1.xxx * u_xlat16_6.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_1.xyz / u_xlat16_2.xxx);
    u_xlat16_1.xyz = half3(u_xlat16_0.www * u_xlat16_2.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * u_xlat16_1.xyz);
    output.SV_Target3.xyz = exp2((-u_xlat16_1.xyz));
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.w = 0.0;
    vs_TEXCOORD5.zw = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    vs_TEXCOORD5.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_DynamicLightmap_HDR;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_DynamicLightmap;
uniform  sampler2D unity_DynamicDirectionality;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
vec3 u_xlat2;
mediump vec3 u_xlat16_2;
lowp vec4 u_xlat10_2;
vec3 u_xlat4;
mediump float u_xlat16_10;
void main()
{
    u_xlat10_0 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat0.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_0.y * _OcclusionStrength + u_xlat0.x;
    u_xlat1.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat10_2 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat4.xyz = u_xlat10_2.xyz * _Color.xyz;
    u_xlat2.xyz = _Color.xyz * u_xlat10_2.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.xyz = u_xlat1.xxx * u_xlat4.xyz;
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target2.w = 1.0;
    u_xlat10_2 = texture(unity_DynamicDirectionality, vs_TEXCOORD5.zw);
    u_xlat16_2.xyz = u_xlat10_2.xyz + vec3(-0.5, -0.5, -0.5);
    u_xlat16_10 = max(u_xlat10_2.w, 9.99999975e-05);
    u_xlat1.x = dot(u_xlat1.xyz, u_xlat16_2.xyz);
    u_xlat1.x = u_xlat1.x + 0.5;
    u_xlat10_2 = texture(unity_DynamicLightmap, vs_TEXCOORD5.zw);
    u_xlat4.x = u_xlat10_2.w * unity_DynamicLightmap_HDR.x;
    u_xlat2.xyz = u_xlat10_2.xyz * u_xlat4.xxx;
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * unity_DynamicLightmap_HDR.yyy;
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat1.xyz = u_xlat1.xyz / vec3(u_xlat16_10);
    u_xlat1.xyz = u_xlat0.www * u_xlat1.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    SV_Target3.xyz = exp2((-u_xlat0.xyz));
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRLIGHTMAP_COMBINED DYNAMICLIGHTMAP_ON _EMISSION 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 16
  Matrix4x4 unity_ObjectToWorld at 80
  Matrix4x4 unity_WorldToObject at 144
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_WorldTransformParams at 208
  Vector4 unity_DynamicLightmapST at 224
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    float2 TEXCOORD2 [[ attribute(4) ]] ;
    half4 TANGENT0 [[ attribute(5) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    float u_xlat9;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat1.xyz = float3(u_xlat9) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.w = 0.0;
    u_xlat0.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    output.TEXCOORD5.zw = half2(u_xlat0.xy);
    output.TEXCOORD5.xy = half2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "_EmissionMap" to slot 2
Set 2D Texture "unity_DynamicLightmap" to slot 3
Set 2D Texture "unity_DynamicDirectionality" to slot 4

Constant Buffer "Globals" (32 bytes) on slot 0 {
  VectorHalf4 unity_DynamicLightmap_HDR at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
  ScalarHalf _OcclusionStrength at 20
  VectorHalf4 _EmissionColor at 24
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_DynamicLightmap_HDR;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (2) ]] ,
    sampler sampler_EmissionMap [[ sampler (2) ]] ,
    texture2d<float, access::sample > unity_DynamicLightmap [[ texture (3) ]] ,
    sampler samplerunity_DynamicLightmap [[ sampler (3) ]] ,
    texture2d<float, access::sample > unity_DynamicDirectionality [[ texture (4) ]] ,
    sampler samplerunity_DynamicDirectionality [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    half3 u_xlat16_4;
    half3 u_xlat16_6;
    u_xlat16_0.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_1.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_0.x * Globals._OcclusionStrength + u_xlat16_1.x);
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_2.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_3.xyz = half3(u_xlat16_2.xyz * Globals._Color.xyz);
    u_xlat16_6.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_2.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_6.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_0.xyz = half3(u_xlat16_1.xxx * u_xlat16_3.xyz);
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    u_xlat16_1.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_1.x = rsqrt(u_xlat16_1.x);
    u_xlat16_1.xyz = half3(u_xlat16_1.xxx * input.TEXCOORD4.xyz);
    u_xlat16_2.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target2.xyz = u_xlat16_2.xyz;
    output.SV_Target2.w = 1.0;
    u_xlat10_2 = half4(unity_DynamicDirectionality.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_4.xyz = half3(float3(u_xlat10_2.xyz) + float3(-0.5, -0.5, -0.5));
    u_xlat16_2.x = half(max(float(u_xlat10_2.w), 9.99999975e-05));
    u_xlat16_1.x = dot(u_xlat16_1.xyz, u_xlat16_4.xyz);
    u_xlat16_1.x = half(float(u_xlat16_1.x) + 0.5);
    u_xlat10_3 = half4(unity_DynamicLightmap.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_6.x = half(float(u_xlat10_3.w) * float(Globals.unity_DynamicLightmap_HDR.x));
    u_xlat16_6.xyz = half3(float3(u_xlat10_3.xyz) * float3(u_xlat16_6.xxx));
    u_xlat16_6.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz * Globals.unity_DynamicLightmap_HDR.yyy);
    u_xlat16_6.xyz = exp2(u_xlat16_6.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_1.xxx * u_xlat16_6.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_1.xyz / u_xlat16_2.xxx);
    u_xlat16_1.xyz = half3(u_xlat16_0.www * u_xlat16_2.xyz);
    u_xlat16_2.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * Globals._EmissionColor.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * u_xlat16_1.xyz + u_xlat16_2.xyz);
    output.SV_Target3.xyz = exp2((-u_xlat16_1.xyz));
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.w = 0.0;
    vs_TEXCOORD5.zw = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    vs_TEXCOORD5.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_DynamicLightmap_HDR;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  sampler2D unity_DynamicLightmap;
uniform  sampler2D unity_DynamicDirectionality;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
vec3 u_xlat2;
mediump vec3 u_xlat16_2;
lowp vec4 u_xlat10_2;
vec3 u_xlat4;
mediump float u_xlat16_10;
void main()
{
    u_xlat10_0 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat0.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_0.y * _OcclusionStrength + u_xlat0.x;
    u_xlat1.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat10_2 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat4.xyz = u_xlat10_2.xyz * _Color.xyz;
    u_xlat2.xyz = _Color.xyz * u_xlat10_2.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.xyz = u_xlat1.xxx * u_xlat4.xyz;
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target2.w = 1.0;
    u_xlat10_2 = texture(unity_DynamicDirectionality, vs_TEXCOORD5.zw);
    u_xlat16_2.xyz = u_xlat10_2.xyz + vec3(-0.5, -0.5, -0.5);
    u_xlat16_10 = max(u_xlat10_2.w, 9.99999975e-05);
    u_xlat1.x = dot(u_xlat1.xyz, u_xlat16_2.xyz);
    u_xlat1.x = u_xlat1.x + 0.5;
    u_xlat10_2 = texture(unity_DynamicLightmap, vs_TEXCOORD5.zw);
    u_xlat4.x = u_xlat10_2.w * unity_DynamicLightmap_HDR.x;
    u_xlat2.xyz = u_xlat10_2.xyz * u_xlat4.xxx;
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * unity_DynamicLightmap_HDR.yyy;
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat1.xyz = u_xlat1.xyz / vec3(u_xlat16_10);
    u_xlat1.xyz = u_xlat0.www * u_xlat1.xyz;
    u_xlat10_2 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    u_xlat2.xyz = u_xlat10_2.xyz * _EmissionColor.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz + u_xlat2.xyz;
    SV_Target3.xyz = exp2((-u_xlat0.xyz));
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 unity_WorldTransformParams at 240
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    half4 TANGENT0 [[ attribute(4) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_2.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_2.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_2.x)));
    u_xlat16_0 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_2.xxx + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 3D Texture "unity_ProbeVolumeSH" to slot 2

Constant Buffer "Globals" (158 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (2) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    float3 u_xlat3;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    bool u_xlatb3;
    float3 u_xlat4;
    half4 u_xlat10_4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = input.TEXCOORD6.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD6.xxx + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD6.zzz + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : input.TEXCOORD6.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat10_3 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw));
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_4 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz));
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_2 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz));
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(float4(u_xlat10_3), float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(float4(u_xlat10_4), float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(float4(u_xlat10_2), float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz);
    output.SV_Target3.xyz = exp2((-u_xlat16_6.xyz));
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat0.x = u_xlat1.y * u_xlat1.y;
    u_xlat0.x = u_xlat1.x * u_xlat1.x + (-u_xlat0.x);
    u_xlat1 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat2.x = dot(unity_SHBr, u_xlat1);
    u_xlat2.y = dot(unity_SHBg, u_xlat1);
    u_xlat2.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * u_xlat0.xxx + u_xlat2.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
lowp vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat7;
float u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD6.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD6.xxx + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD6.zzz + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : vs_TEXCOORD6.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz;
    SV_Target3.xyz = exp2((-u_xlat2.xyz));
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRLIGHTMAP_SEPARATE _EMISSION 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 unity_WorldTransformParams at 240
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    half4 TANGENT0 [[ attribute(4) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_2.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_2.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_2.x)));
    u_xlat16_0 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_2.xxx + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "_EmissionMap" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (168 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
  VectorHalf4 _EmissionColor at 160
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (2) ]] ,
    sampler sampler_EmissionMap [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    float3 u_xlat3;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    bool u_xlatb3;
    float3 u_xlat4;
    half4 u_xlat10_4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = input.TEXCOORD6.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD6.xxx + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD6.zzz + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : input.TEXCOORD6.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat10_3 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw));
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_4 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz));
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_2 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz));
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(float4(u_xlat10_3), float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(float4(u_xlat10_4), float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(float4(u_xlat10_2), float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    u_xlat16_3.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * Globals._EmissionColor.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz + u_xlat16_3.xyz);
    output.SV_Target3.xyz = exp2((-u_xlat16_6.xyz));
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat0.x = u_xlat1.y * u_xlat1.y;
    u_xlat0.x = u_xlat1.x * u_xlat1.x + (-u_xlat0.x);
    u_xlat1 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat2.x = dot(unity_SHBr, u_xlat1);
    u_xlat2.y = dot(unity_SHBg, u_xlat1);
    u_xlat2.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * u_xlat0.xxx + u_xlat2.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
lowp vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat7;
float u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD6.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD6.xxx + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD6.zzz + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : vs_TEXCOORD6.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    u_xlat10_3 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    u_xlat3.xyz = u_xlat10_3.xyz * _EmissionColor.xyz;
    u_xlat2.xyz = u_xlat0.xyz * u_xlat2.xyz + u_xlat3.xyz;
    SV_Target3.xyz = exp2((-u_xlat2.xyz));
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: UNITY_HDR_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_2 = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_2 = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_2)));
    u_xlat16_0 = half4(u_xlat0.yzzx * u_xlat0.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_2) + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 3D Texture "unity_ProbeVolumeSH" to slot 2

Constant Buffer "Globals" (158 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (2) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    float3 u_xlat3;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    bool u_xlatb3;
    float3 u_xlat4;
    half4 u_xlat10_4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = input.TEXCOORD6.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD6.xxx + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD6.zzz + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : input.TEXCOORD6.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat10_3 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw));
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_4 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz));
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_2 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz));
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(float4(u_xlat10_3), float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(float4(u_xlat10_4), float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(float4(u_xlat10_2), float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    output.SV_Target3.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat6 = u_xlat0.y * u_xlat0.y;
    u_xlat6 = u_xlat0.x * u_xlat0.x + (-u_xlat6);
    u_xlat1 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat0.x = dot(unity_SHBr, u_xlat1);
    u_xlat0.y = dot(unity_SHBg, u_xlat1);
    u_xlat0.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat6) + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
lowp vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat7;
float u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD6.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD6.xxx + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD6.zzz + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : vs_TEXCOORD6.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    SV_Target3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: _EMISSION UNITY_HDR_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_2 = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_2 = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_2)));
    u_xlat16_0 = half4(u_xlat0.yzzx * u_xlat0.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * half3(u_xlat16_2) + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "_EmissionMap" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (168 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
  VectorHalf4 _EmissionColor at 160
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (2) ]] ,
    sampler sampler_EmissionMap [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    float3 u_xlat3;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    bool u_xlatb3;
    float3 u_xlat4;
    half4 u_xlat10_4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = input.TEXCOORD6.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD6.xxx + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD6.zzz + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : input.TEXCOORD6.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat10_3 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw));
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_4 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz));
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_2 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz));
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(float4(u_xlat10_3), float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(float4(u_xlat10_4), float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(float4(u_xlat10_2), float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    u_xlat16_3.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * Globals._EmissionColor.xyz);
    output.SV_Target3.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz + u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat6 = u_xlat0.y * u_xlat0.y;
    u_xlat6 = u_xlat0.x * u_xlat0.x + (-u_xlat6);
    u_xlat1 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat0.x = dot(unity_SHBr, u_xlat1);
    u_xlat0.y = dot(unity_SHBg, u_xlat1);
    u_xlat0.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * vec3(u_xlat6) + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
lowp vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat7;
float u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD6.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD6.xxx + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD6.zzz + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : vs_TEXCOORD6.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    u_xlat10_3 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    u_xlat3.xyz = u_xlat10_3.xyz * _EmissionColor.xyz;
    SV_Target3.xyz = u_xlat0.xyz * u_xlat2.xyz + u_xlat3.xyz;
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 unity_WorldTransformParams at 240
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    half4 TANGENT0 [[ attribute(4) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_2.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_2.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_2.x)));
    u_xlat16_0 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_2.xxx + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 3D Texture "unity_ProbeVolumeSH" to slot 2

Constant Buffer "Globals" (158 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (2) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    float3 u_xlat3;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    bool u_xlatb3;
    float3 u_xlat4;
    half4 u_xlat10_4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = input.TEXCOORD6.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD6.xxx + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD6.zzz + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : input.TEXCOORD6.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat10_3 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw));
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_4 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz));
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_2 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz));
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(float4(u_xlat10_3), float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(float4(u_xlat10_4), float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(float4(u_xlat10_2), float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    output.SV_Target3.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat0.x = u_xlat1.y * u_xlat1.y;
    u_xlat0.x = u_xlat1.x * u_xlat1.x + (-u_xlat0.x);
    u_xlat1 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat2.x = dot(unity_SHBr, u_xlat1);
    u_xlat2.y = dot(unity_SHBg, u_xlat1);
    u_xlat2.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * u_xlat0.xxx + u_xlat2.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
lowp vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat7;
float u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD6.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD6.xxx + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD6.zzz + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : vs_TEXCOORD6.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    SV_Target3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRLIGHTMAP_COMBINED _EMISSION UNITY_HDR_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 unity_WorldTransformParams at 240
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    half4 TANGENT0 [[ attribute(4) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_2.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_2.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_2.x)));
    u_xlat16_0 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_2.xxx + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "_EmissionMap" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (168 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
  VectorHalf4 _EmissionColor at 160
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (2) ]] ,
    sampler sampler_EmissionMap [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    float3 u_xlat3;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    bool u_xlatb3;
    float3 u_xlat4;
    half4 u_xlat10_4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = input.TEXCOORD6.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD6.xxx + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD6.zzz + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : input.TEXCOORD6.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat10_3 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw));
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_4 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz));
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_2 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz));
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(float4(u_xlat10_3), float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(float4(u_xlat10_4), float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(float4(u_xlat10_2), float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    u_xlat16_3.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * Globals._EmissionColor.xyz);
    output.SV_Target3.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz + u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat0.x = u_xlat1.y * u_xlat1.y;
    u_xlat0.x = u_xlat1.x * u_xlat1.x + (-u_xlat0.x);
    u_xlat1 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat2.x = dot(unity_SHBr, u_xlat1);
    u_xlat2.y = dot(unity_SHBg, u_xlat1);
    u_xlat2.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * u_xlat0.xxx + u_xlat2.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
lowp vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat7;
float u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD6.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD6.xxx + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD6.zzz + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : vs_TEXCOORD6.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    u_xlat10_3 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    u_xlat3.xyz = u_xlat10_3.xyz * _EmissionColor.xyz;
    SV_Target3.xyz = u_xlat0.xyz * u_xlat2.xyz + u_xlat3.xyz;
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 16
  Matrix4x4 unity_ObjectToWorld at 80
  Matrix4x4 unity_WorldToObject at 144
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_WorldTransformParams at 208
  Vector4 unity_DynamicLightmapST at 224
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    float2 TEXCOORD2 [[ attribute(4) ]] ;
    half4 TANGENT0 [[ attribute(5) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    float u_xlat9;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat1.xyz = float3(u_xlat9) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.w = 0.0;
    u_xlat0.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    output.TEXCOORD5.zw = half2(u_xlat0.xy);
    output.TEXCOORD5.xy = half2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "unity_DynamicLightmap" to slot 2
Set 2D Texture "unity_DynamicDirectionality" to slot 3

Constant Buffer "Globals" (22 bytes) on slot 0 {
  VectorHalf4 unity_DynamicLightmap_HDR at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
  ScalarHalf _OcclusionStrength at 20
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_DynamicLightmap_HDR;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<float, access::sample > unity_DynamicLightmap [[ texture (2) ]] ,
    sampler samplerunity_DynamicLightmap [[ sampler (2) ]] ,
    texture2d<float, access::sample > unity_DynamicDirectionality [[ texture (3) ]] ,
    sampler samplerunity_DynamicDirectionality [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    half3 u_xlat16_4;
    half3 u_xlat16_6;
    u_xlat16_0.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_1.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_0.x * Globals._OcclusionStrength + u_xlat16_1.x);
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_2.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_3.xyz = half3(u_xlat16_2.xyz * Globals._Color.xyz);
    u_xlat16_6.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_2.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_6.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_0.xyz = half3(u_xlat16_1.xxx * u_xlat16_3.xyz);
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    u_xlat16_1.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_1.x = rsqrt(u_xlat16_1.x);
    u_xlat16_1.xyz = half3(u_xlat16_1.xxx * input.TEXCOORD4.xyz);
    u_xlat16_2.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target2.xyz = u_xlat16_2.xyz;
    output.SV_Target2.w = 1.0;
    u_xlat10_2 = half4(unity_DynamicDirectionality.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_4.xyz = half3(float3(u_xlat10_2.xyz) + float3(-0.5, -0.5, -0.5));
    u_xlat16_2.x = half(max(float(u_xlat10_2.w), 9.99999975e-05));
    u_xlat16_1.x = dot(u_xlat16_1.xyz, u_xlat16_4.xyz);
    u_xlat16_1.x = half(float(u_xlat16_1.x) + 0.5);
    u_xlat10_3 = half4(unity_DynamicLightmap.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_6.x = half(float(u_xlat10_3.w) * float(Globals.unity_DynamicLightmap_HDR.x));
    u_xlat16_6.xyz = half3(float3(u_xlat10_3.xyz) * float3(u_xlat16_6.xxx));
    u_xlat16_6.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz * Globals.unity_DynamicLightmap_HDR.yyy);
    u_xlat16_6.xyz = exp2(u_xlat16_6.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_1.xxx * u_xlat16_6.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_1.xyz / u_xlat16_2.xxx);
    u_xlat16_1.xyz = half3(u_xlat16_0.www * u_xlat16_2.xyz);
    output.SV_Target3.xyz = half3(u_xlat16_0.xyz * u_xlat16_1.xyz);
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.w = 0.0;
    vs_TEXCOORD5.zw = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    vs_TEXCOORD5.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_DynamicLightmap_HDR;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_DynamicLightmap;
uniform  sampler2D unity_DynamicDirectionality;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
vec3 u_xlat2;
mediump vec3 u_xlat16_2;
lowp vec4 u_xlat10_2;
vec3 u_xlat4;
mediump float u_xlat16_10;
void main()
{
    u_xlat10_0 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat0.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_0.y * _OcclusionStrength + u_xlat0.x;
    u_xlat1.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat10_2 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat4.xyz = u_xlat10_2.xyz * _Color.xyz;
    u_xlat2.xyz = _Color.xyz * u_xlat10_2.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.xyz = u_xlat1.xxx * u_xlat4.xyz;
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target2.w = 1.0;
    u_xlat10_2 = texture(unity_DynamicDirectionality, vs_TEXCOORD5.zw);
    u_xlat16_2.xyz = u_xlat10_2.xyz + vec3(-0.5, -0.5, -0.5);
    u_xlat16_10 = max(u_xlat10_2.w, 9.99999975e-05);
    u_xlat1.x = dot(u_xlat1.xyz, u_xlat16_2.xyz);
    u_xlat1.x = u_xlat1.x + 0.5;
    u_xlat10_2 = texture(unity_DynamicLightmap, vs_TEXCOORD5.zw);
    u_xlat4.x = u_xlat10_2.w * unity_DynamicLightmap_HDR.x;
    u_xlat2.xyz = u_xlat10_2.xyz * u_xlat4.xxx;
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * unity_DynamicLightmap_HDR.yyy;
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat1.xyz = u_xlat1.xyz / vec3(u_xlat16_10);
    u_xlat1.xyz = u_xlat0.www * u_xlat1.xyz;
    SV_Target3.xyz = u_xlat0.xyz * u_xlat1.xyz;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRLIGHTMAP_COMBINED DYNAMICLIGHTMAP_ON _EMISSION UNITY_HDR_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 16
  Matrix4x4 unity_ObjectToWorld at 80
  Matrix4x4 unity_WorldToObject at 144
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_WorldTransformParams at 208
  Vector4 unity_DynamicLightmapST at 224
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    float2 TEXCOORD2 [[ attribute(4) ]] ;
    half4 TANGENT0 [[ attribute(5) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    float u_xlat9;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat0.xyz = float3(u_xlat9) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat1.xyz = float3(u_xlat9) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.w = 0.0;
    u_xlat0.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    output.TEXCOORD5.zw = half2(u_xlat0.xy);
    output.TEXCOORD5.xy = half2(0.0, 0.0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "_EmissionMap" to slot 2
Set 2D Texture "unity_DynamicLightmap" to slot 3
Set 2D Texture "unity_DynamicDirectionality" to slot 4

Constant Buffer "Globals" (32 bytes) on slot 0 {
  VectorHalf4 unity_DynamicLightmap_HDR at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
  ScalarHalf _OcclusionStrength at 20
  VectorHalf4 _EmissionColor at 24
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_DynamicLightmap_HDR;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (2) ]] ,
    sampler sampler_EmissionMap [[ sampler (2) ]] ,
    texture2d<float, access::sample > unity_DynamicLightmap [[ texture (3) ]] ,
    sampler samplerunity_DynamicLightmap [[ sampler (3) ]] ,
    texture2d<float, access::sample > unity_DynamicDirectionality [[ texture (4) ]] ,
    sampler samplerunity_DynamicDirectionality [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    half3 u_xlat16_4;
    half3 u_xlat16_6;
    u_xlat16_0.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_1.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_0.x * Globals._OcclusionStrength + u_xlat16_1.x);
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_2.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_3.xyz = half3(u_xlat16_2.xyz * Globals._Color.xyz);
    u_xlat16_6.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_2.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_6.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_0.xyz = half3(u_xlat16_1.xxx * u_xlat16_3.xyz);
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    u_xlat16_1.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_1.x = rsqrt(u_xlat16_1.x);
    u_xlat16_1.xyz = half3(u_xlat16_1.xxx * input.TEXCOORD4.xyz);
    u_xlat16_2.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target2.xyz = u_xlat16_2.xyz;
    output.SV_Target2.w = 1.0;
    u_xlat10_2 = half4(unity_DynamicDirectionality.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_4.xyz = half3(float3(u_xlat10_2.xyz) + float3(-0.5, -0.5, -0.5));
    u_xlat16_2.x = half(max(float(u_xlat10_2.w), 9.99999975e-05));
    u_xlat16_1.x = dot(u_xlat16_1.xyz, u_xlat16_4.xyz);
    u_xlat16_1.x = half(float(u_xlat16_1.x) + 0.5);
    u_xlat10_3 = half4(unity_DynamicLightmap.sample(samplerunity_DynamicLightmap, float2(input.TEXCOORD5.zw)));
    u_xlat16_6.x = half(float(u_xlat10_3.w) * float(Globals.unity_DynamicLightmap_HDR.x));
    u_xlat16_6.xyz = half3(float3(u_xlat10_3.xyz) * float3(u_xlat16_6.xxx));
    u_xlat16_6.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz * Globals.unity_DynamicLightmap_HDR.yyy);
    u_xlat16_6.xyz = exp2(u_xlat16_6.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_1.xxx * u_xlat16_6.xyz);
    u_xlat16_2.xyz = half3(u_xlat16_1.xyz / u_xlat16_2.xxx);
    u_xlat16_1.xyz = half3(u_xlat16_0.www * u_xlat16_2.xyz);
    u_xlat16_2.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz * Globals._EmissionColor.xyz);
    output.SV_Target3.xyz = half3(u_xlat16_0.xyz * u_xlat16_1.xyz + u_xlat16_2.xyz);
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.w = 0.0;
    vs_TEXCOORD5.zw = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    vs_TEXCOORD5.xy = vec2(0.0, 0.0);
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_DynamicLightmap_HDR;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  sampler2D unity_DynamicLightmap;
uniform  sampler2D unity_DynamicDirectionality;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec3 u_xlat1;
vec3 u_xlat2;
mediump vec3 u_xlat16_2;
lowp vec4 u_xlat10_2;
vec3 u_xlat4;
mediump float u_xlat16_10;
void main()
{
    u_xlat10_0 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat0.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_0.y * _OcclusionStrength + u_xlat0.x;
    u_xlat1.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat10_2 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat4.xyz = u_xlat10_2.xyz * _Color.xyz;
    u_xlat2.xyz = _Color.xyz * u_xlat10_2.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.xyz = u_xlat1.xxx * u_xlat4.xyz;
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target2.w = 1.0;
    u_xlat10_2 = texture(unity_DynamicDirectionality, vs_TEXCOORD5.zw);
    u_xlat16_2.xyz = u_xlat10_2.xyz + vec3(-0.5, -0.5, -0.5);
    u_xlat16_10 = max(u_xlat10_2.w, 9.99999975e-05);
    u_xlat1.x = dot(u_xlat1.xyz, u_xlat16_2.xyz);
    u_xlat1.x = u_xlat1.x + 0.5;
    u_xlat10_2 = texture(unity_DynamicLightmap, vs_TEXCOORD5.zw);
    u_xlat4.x = u_xlat10_2.w * unity_DynamicLightmap_HDR.x;
    u_xlat2.xyz = u_xlat10_2.xyz * u_xlat4.xxx;
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * unity_DynamicLightmap_HDR.yyy;
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    u_xlat1.xyz = u_xlat1.xyz / vec3(u_xlat16_10);
    u_xlat1.xyz = u_xlat0.www * u_xlat1.xyz;
    u_xlat10_2 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    u_xlat2.xyz = u_xlat10_2.xyz * _EmissionColor.xyz;
    SV_Target3.xyz = u_xlat0.xyz * u_xlat1.xyz + u_xlat2.xyz;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 unity_WorldTransformParams at 240
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    half4 TANGENT0 [[ attribute(4) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_2.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_2.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_2.x)));
    u_xlat16_0 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_2.xxx + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 3D Texture "unity_ProbeVolumeSH" to slot 2

Constant Buffer "Globals" (158 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (2) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    float3 u_xlat3;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    bool u_xlatb3;
    float3 u_xlat4;
    half4 u_xlat10_4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = input.TEXCOORD6.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD6.xxx + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD6.zzz + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : input.TEXCOORD6.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat10_3 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw));
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_4 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz));
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_2 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz));
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(float4(u_xlat10_3), float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(float4(u_xlat10_4), float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(float4(u_xlat10_2), float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    output.SV_Target3.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat0.x = u_xlat1.y * u_xlat1.y;
    u_xlat0.x = u_xlat1.x * u_xlat1.x + (-u_xlat0.x);
    u_xlat1 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat2.x = dot(unity_SHBr, u_xlat1);
    u_xlat2.y = dot(unity_SHBg, u_xlat1);
    u_xlat2.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * u_xlat0.xxx + u_xlat2.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
lowp vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat7;
float u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD6.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD6.xxx + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD6.zzz + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : vs_TEXCOORD6.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    SV_Target3.xyz = u_xlat0.xyz * u_xlat2.xyz;
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRLIGHTMAP_SEPARATE _EMISSION UNITY_HDR_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord3"

Constant Buffer "Globals" (290 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHBr at 16
  VectorHalf4 unity_SHBg at 24
  VectorHalf4 unity_SHBb at 32
  VectorHalf4 unity_SHC at 40
  Vector4 unity_WorldTransformParams at 240
  Vector4 _MainTex_ST at 256
  Vector4 _DetailAlbedoMap_ST at 272
  ScalarHalf _UVSec at 288
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_WorldTransformParams;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
    half4 TANGENT0 [[ attribute(4) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    half4 u_xlat16_0;
    bool u_xlatb0;
    float3 u_xlat1;
    half3 u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    output.TEXCOORD6.xyz = u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat0.xyz = float3(input.TANGENT0.yyy) * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * float3(input.TANGENT0.xxx) + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * float3(input.TANGENT0.zzz) + u_xlat0.xyz;
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD2.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    u_xlat16_2.xyz = half3(u_xlat0.yzx * u_xlat1.zxy);
    u_xlat16_2.xyz = half3(u_xlat1.yzx * u_xlat0.zxy + (-float3(u_xlat16_2.xyz)));
    u_xlat0.x = float(input.TANGENT0.w) * Globals.unity_WorldTransformParams.w;
    output.TEXCOORD3.xyz = half3(u_xlat0.xxx * float3(u_xlat16_2.xyz));
    output.TEXCOORD3.w = 0.0;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD4.w = 0.0;
    u_xlat16_2.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_2.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_2.x)));
    u_xlat16_0 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_0);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_0);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_0);
    output.TEXCOORD5.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_2.xxx + u_xlat16_3.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "_EmissionMap" to slot 2
Set 3D Texture "unity_ProbeVolumeSH" to slot 3

Constant Buffer "Globals" (168 bytes) on slot 0 {
  Matrix4x4 unity_ProbeVolumeWorldToObject at 48
  VectorHalf4 unity_SHAr at 0
  VectorHalf4 unity_SHAg at 8
  VectorHalf4 unity_SHAb at 16
  Vector4 unity_ProbeVolumeParams at 32
  Vector3 unity_ProbeVolumeSizeInv at 112
  Vector3 unity_ProbeVolumeMin at 128
  VectorHalf4 _Color at 144
  ScalarHalf _Metallic at 152
  ScalarHalf _Glossiness at 154
  ScalarHalf _OcclusionStrength at 156
  VectorHalf4 _EmissionColor at 160
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half _OcclusionStrength;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
    half4 SV_Target1 [[ color(1) ]];
    half4 SV_Target2 [[ color(2) ]];
    half4 SV_Target3 [[ color(3) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (2) ]] ,
    sampler sampler_EmissionMap [[ sampler (2) ]] ,
    texture3d<float, access::sample > unity_ProbeVolumeSH [[ texture (3) ]] ,
    sampler samplerunity_ProbeVolumeSH [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    float4 u_xlat2;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    float3 u_xlat3;
    half3 u_xlat16_3;
    half4 u_xlat10_3;
    bool u_xlatb3;
    float3 u_xlat4;
    half4 u_xlat10_4;
    float3 u_xlat5;
    half3 u_xlat16_6;
    float3 u_xlat10;
    float u_xlat17;
    u_xlat16_0.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_0.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    output.SV_Target1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_2.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * u_xlat16_2.xxx);
    u_xlat16_2.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_2.x = rsqrt(u_xlat16_2.x);
    u_xlat16_1.xyz = half3(u_xlat16_2.xxx * input.TEXCOORD4.xyz);
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_2.x = half((-float(Globals._OcclusionStrength)) + 1.0);
    u_xlat16_0.w = half(u_xlat16_3.x * Globals._OcclusionStrength + u_xlat16_2.x);
    u_xlatb3 = Globals.unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb3){
        u_xlatb3 = Globals.unity_ProbeVolumeParams.y==1.0;
        u_xlat10.xyz = input.TEXCOORD6.yyy * Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * input.TEXCOORD6.xxx + u_xlat10.xyz;
        u_xlat10.xyz = Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * input.TEXCOORD6.zzz + u_xlat10.xyz;
        u_xlat10.xyz = u_xlat10.xyz + Globals.hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat3.xyz = (bool(u_xlatb3)) ? u_xlat10.xyz : input.TEXCOORD6.xyz;
        u_xlat3.xyz = u_xlat3.xyz + (-Globals.unity_ProbeVolumeMin.xyzx.xyz);
        u_xlat2.yzw = u_xlat3.xyz * Globals.unity_ProbeVolumeSizeInv.xyzx.xyz;
        u_xlat3.x = u_xlat2.y * 0.25;
        u_xlat10.x = Globals.unity_ProbeVolumeParams.z * 0.5;
        u_xlat17 = (-Globals.unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat3.x = max(u_xlat10.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat17, u_xlat3.x);
        u_xlat10_3 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat2.xzw));
        u_xlat4.xyz = u_xlat2.xzw + float3(0.25, 0.0, 0.0);
        u_xlat10_4 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat4.xyz));
        u_xlat5.xyz = u_xlat2.xzw + float3(0.5, 0.0, 0.0);
        u_xlat10_2 = half4(unity_ProbeVolumeSH.sample(samplerunity_ProbeVolumeSH, u_xlat5.xyz));
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = half(dot(float4(u_xlat10_3), float4(u_xlat16_1)));
        u_xlat16_6.y = half(dot(float4(u_xlat10_4), float4(u_xlat16_1)));
        u_xlat16_6.z = half(dot(float4(u_xlat10_2), float4(u_xlat16_1)));
    } else {
        u_xlat16_1.w = 1.0;
        u_xlat16_6.x = dot(Globals.unity_SHAr, u_xlat16_1);
        u_xlat16_6.y = dot(Globals.unity_SHAg, u_xlat16_1);
        u_xlat16_6.z = dot(Globals.unity_SHAb, u_xlat16_1);
    }
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + input.TEXCOORD5.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_3.xyz = log2(u_xlat16_6.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.416666657, 0.416666657, 0.416666657));
    u_xlat16_3.xyz = exp2(u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_3.xyz) * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997));
    u_xlat16_3.xyz = half3(max(float3(u_xlat16_3.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat16_6.xyz = half3(u_xlat16_0.www * u_xlat16_3.xyz);
    u_xlat16_3.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * Globals._EmissionColor.xyz);
    output.SV_Target3.xyz = half3(u_xlat16_0.xyz * u_xlat16_6.xyz + u_xlat16_3.xyz);
    u_xlat16_3.xyz = half3(float3(u_xlat16_1.xyz) * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5));
    output.SV_Target0 = u_xlat16_0;
    output.SV_Target1.w = Globals._Glossiness;
    output.SV_Target2.xyz = u_xlat16_3.xyz;
    output.SV_Target2.w = 1.0;
    output.SV_Target3.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 unity_WorldTransformParams;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec4 in_TANGENT0;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec3 u_xlat2;
float u_xlat9;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    vs_TEXCOORD6.xyz = u_xlat0.xyz;
    u_xlat0.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat0.xyz;
    u_xlat9 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat0.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD2.xyz = u_xlat0.xyz;
    vs_TEXCOORD2.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.xyz = u_xlat0.yzx * u_xlat1.zxy;
    u_xlat0.xyz = u_xlat1.yzx * u_xlat0.zxy + (-u_xlat2.xyz);
    u_xlat9 = in_TANGENT0.w * unity_WorldTransformParams.w;
    vs_TEXCOORD3.xyz = vec3(u_xlat9) * u_xlat0.xyz;
    vs_TEXCOORD3.w = 0.0;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    vs_TEXCOORD4.w = 0.0;
    u_xlat0.x = u_xlat1.y * u_xlat1.y;
    u_xlat0.x = u_xlat1.x * u_xlat1.x + (-u_xlat0.x);
    u_xlat1 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat2.x = dot(unity_SHBr, u_xlat1);
    u_xlat2.y = dot(unity_SHBg, u_xlat1);
    u_xlat2.z = dot(unity_SHBb, u_xlat1);
    vs_TEXCOORD5.xyz = unity_SHC.xyz * u_xlat0.xxx + u_xlat2.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_ProbeVolumeParams;
uniform 	vec4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
uniform 	vec3 unity_ProbeVolumeSizeInv;
uniform 	vec3 unity_ProbeVolumeMin;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	float _OcclusionStrength;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D _EmissionMap;
uniform  sampler3D unity_ProbeVolumeSH;
in  vec4 vs_TEXCOORD0;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
layout(location = 1) out vec4 SV_Target1;
layout(location = 2) out vec4 SV_Target2;
layout(location = 3) out vec4 SV_Target3;
vec4 u_xlat0;
lowp vec4 u_xlat10_0;
vec4 u_xlat1;
vec4 u_xlat2;
lowp vec4 u_xlat10_2;
bool u_xlatb2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat7;
float u_xlat8;
void main()
{
    u_xlat10_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_0.xyz * _Color.xyz;
    u_xlat0.xyz = _Color.xyz * u_xlat10_0.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    SV_Target1.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat0.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat10_2 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.x = (-_OcclusionStrength) + 1.0;
    u_xlat0.w = u_xlat10_2.y * _OcclusionStrength + u_xlat2.x;
    u_xlatb2 = unity_ProbeVolumeParams.x==1.0;
    if(u_xlatb2){
        u_xlatb2 = unity_ProbeVolumeParams.y==1.0;
        u_xlat7.xyz = vs_TEXCOORD6.yyy * hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[1].xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[0].xyz * vs_TEXCOORD6.xxx + u_xlat7.xyz;
        u_xlat7.xyz = hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[2].xyz * vs_TEXCOORD6.zzz + u_xlat7.xyz;
        u_xlat7.xyz = u_xlat7.xyz + hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[3].xyz;
        u_xlat2.xyz = (bool(u_xlatb2)) ? u_xlat7.xyz : vs_TEXCOORD6.xyz;
        u_xlat2.xyz = u_xlat2.xyz + (-unity_ProbeVolumeMin.xyz);
        u_xlat2.yzw = u_xlat2.xyz * unity_ProbeVolumeSizeInv.xyz;
        u_xlat7.x = u_xlat2.y * 0.25;
        u_xlat3.x = unity_ProbeVolumeParams.z * 0.5;
        u_xlat8 = (-unity_ProbeVolumeParams.z) * 0.5 + 0.25;
        u_xlat7.x = max(u_xlat7.x, u_xlat3.x);
        u_xlat2.x = min(u_xlat8, u_xlat7.x);
        u_xlat10_3 = texture(unity_ProbeVolumeSH, u_xlat2.xzw);
        u_xlat4.xyz = u_xlat2.xzw + vec3(0.25, 0.0, 0.0);
        u_xlat10_4 = texture(unity_ProbeVolumeSH, u_xlat4.xyz);
        u_xlat2.xyz = u_xlat2.xzw + vec3(0.5, 0.0, 0.0);
        u_xlat10_2 = texture(unity_ProbeVolumeSH, u_xlat2.xyz);
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(u_xlat10_3, u_xlat1);
        u_xlat3.y = dot(u_xlat10_4, u_xlat1);
        u_xlat3.z = dot(u_xlat10_2, u_xlat1);
    } else {
        u_xlat1.w = 1.0;
        u_xlat3.x = dot(unity_SHAr, u_xlat1);
        u_xlat3.y = dot(unity_SHAg, u_xlat1);
        u_xlat3.z = dot(unity_SHAb, u_xlat1);
    //ENDIF
    }
    u_xlat2.xyz = u_xlat3.xyz + vs_TEXCOORD5.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = u_xlat0.www * u_xlat2.xyz;
    u_xlat10_3 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    u_xlat3.xyz = u_xlat10_3.xyz * _EmissionColor.xyz;
    SV_Target3.xyz = u_xlat0.xyz * u_xlat2.xyz + u_xlat3.xyz;
    SV_Target2.xyz = u_xlat1.xyz * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5);
    SV_Target0 = u_xlat0;
    SV_Target1.w = _Glossiness;
    SV_Target2.w = 1.0;
    SV_Target3.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

 }
 Pass {
  Name "META"
  Tags { "LIGHTMODE"="Meta" "RenderType"="Opaque" "PerformanceChecks"="False" }
  Cull Off
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
No keywords set in this variant.
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"

Constant Buffer "Globals" (136 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 0
  Vector4 unity_LightmapST at 64
  Vector4 unity_DynamicLightmapST at 80
  Vector4 _MainTex_ST at 96
  Vector4 _DetailAlbedoMap_ST at 112
  ScalarHalf _UVSec at 128
  VectorBool4 unity_MetaVertexControl at 132
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    bool4 unity_MetaVertexControl;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float2 TEXCOORD1 [[ attribute(2) ]] ;
    float2 TEXCOORD2 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 mtl_Position [[ position ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool u_xlatb6;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlatb0 = 0.0<input.POSITION0.z;
    u_xlat0.z = u_xlatb0 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xy = input.TEXCOORD1.xy * Globals.unity_LightmapST.xy + Globals.unity_LightmapST.zw;
    u_xlat0.xyz = (Globals.unity_MetaVertexControl.x) ? u_xlat0.xyz : input.POSITION0.xyz;
    u_xlatb6 = 0.0<u_xlat0.z;
    u_xlat1.z = u_xlatb6 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    u_xlat0.xyz = (Globals.unity_MetaVertexControl.y) ? u_xlat1.xyz : u_xlat0.xyz;
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat1 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0

Constant Buffer "Globals" (24 bytes) on slot 0 {
  VectorHalf4 _Color at 0
  ScalarHalf _Metallic at 8
  ScalarHalf _Glossiness at 10
  VectorBool4 unity_MetaFragmentControl at 12
  Float unity_OneOverOutputBoost at 16
  Float unity_MaxOutputValue at 20
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    bool4 unity_MetaFragmentControl;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
};

struct Mtl_FragmentOut
{
    float4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    float3 u_xlat1;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half u_xlat16_6;
    float u_xlat7;
    u_xlat16_0.x = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_0.x);
    u_xlat16_1.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_1.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_1.xyz = half3(u_xlat16_1.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * u_xlat16_2.xyz);
    u_xlat16_0.xyz = half3(float3(u_xlat16_0.xyz) * float3(0.5, 0.5, 0.5));
    u_xlat16_6 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_6) + u_xlat16_0.xyz);
    u_xlat16_1.xyz = log2(u_xlat16_0.xyz);
    u_xlat7 = Globals.unity_OneOverOutputBoost;
    u_xlat7 = clamp(u_xlat7, 0.0f, 1.0f);
    u_xlat1.xyz = float3(u_xlat16_1.xyz) * float3(u_xlat7);
    u_xlat1.xyz = exp2(u_xlat1.xyz);
    u_xlat1.xyz = min(u_xlat1.xyz, float3(Globals.unity_MaxOutputValue));
    u_xlat16_0.xyz = (Globals.unity_MetaFragmentControl.x) ? half3(u_xlat1.xyz) : half3(0.0, 0.0, 0.0);
    u_xlat16_0.w = (Globals.unity_MetaFragmentControl.x) ? 1.0 : 0.0;
    u_xlat16_0 = (Globals.unity_MetaFragmentControl.y) ? half4(0.0, 0.0, 0.0, 0.0235294122) : u_xlat16_0;
    output.SV_Target0 = float4(u_xlat16_0);
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 unity_LightmapST;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	bvec4 unity_MetaVertexControl;
in  vec4 in_POSITION0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
out vec4 vs_TEXCOORD0;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
bool u_xlatb6;
void main()
{
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlatb0 = 0.0<in_POSITION0.z;
    u_xlat0.z = u_xlatb0 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xy = in_TEXCOORD1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    u_xlat0.xyz = (unity_MetaVertexControl.x) ? u_xlat0.xyz : in_POSITION0.xyz;
    u_xlatb6 = 0.0<u_xlat0.z;
    u_xlat1.z = u_xlatb6 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xy = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    u_xlat0.xyz = (unity_MetaVertexControl.y) ? u_xlat1.xyz : u_xlat0.xyz;
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat1 = hlslcc_mtx4x4glstate_matrix_mvp[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	bvec4 unity_MetaFragmentControl;
uniform 	float unity_OneOverOutputBoost;
uniform 	float unity_MaxOutputValue;
uniform  sampler2D _MainTex;
in  vec4 vs_TEXCOORD0;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
float u_xlat6;
void main()
{
    u_xlat0.x = (-_Glossiness) + 1.0;
    u_xlat0.x = u_xlat0.x * u_xlat0.x;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat2.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat2.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat0.xyz = u_xlat0.xyz * vec3(0.5, 0.5, 0.5);
    u_xlat6 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat1.xyz * vec3(u_xlat6) + u_xlat0.xyz;
    u_xlat0.xyz = log2(u_xlat0.xyz);
    u_xlat6 = unity_OneOverOutputBoost;
    u_xlat6 = clamp(u_xlat6, 0.0, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * vec3(u_xlat6);
    u_xlat0.xyz = exp2(u_xlat0.xyz);
    u_xlat0.xyz = min(u_xlat0.xyz, vec3(vec3(unity_MaxOutputValue, unity_MaxOutputValue, unity_MaxOutputValue)));
    u_xlat0.w = 1.0;
    u_xlat0 = (unity_MetaFragmentControl.x) ? u_xlat0 : vec4(0.0, 0.0, 0.0, 0.0);
    SV_Target0 = (unity_MetaFragmentControl.y) ? vec4(0.0, 0.0, 0.0, 0.0235294122) : u_xlat0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: _EMISSION 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"

Constant Buffer "Globals" (136 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 0
  Vector4 unity_LightmapST at 64
  Vector4 unity_DynamicLightmapST at 80
  Vector4 _MainTex_ST at 96
  Vector4 _DetailAlbedoMap_ST at 112
  ScalarHalf _UVSec at 128
  VectorBool4 unity_MetaVertexControl at 132
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    bool4 unity_MetaVertexControl;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float2 TEXCOORD1 [[ attribute(2) ]] ;
    float2 TEXCOORD2 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 mtl_Position [[ position ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool u_xlatb6;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlatb0 = 0.0<input.POSITION0.z;
    u_xlat0.z = u_xlatb0 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xy = input.TEXCOORD1.xy * Globals.unity_LightmapST.xy + Globals.unity_LightmapST.zw;
    u_xlat0.xyz = (Globals.unity_MetaVertexControl.x) ? u_xlat0.xyz : input.POSITION0.xyz;
    u_xlatb6 = 0.0<u_xlat0.z;
    u_xlat1.z = u_xlatb6 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    u_xlat0.xyz = (Globals.unity_MetaVertexControl.y) ? u_xlat1.xyz : u_xlat0.xyz;
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat1 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_EmissionMap" to slot 1

Constant Buffer "Globals" (40 bytes) on slot 0 {
  VectorHalf4 _Color at 0
  ScalarHalf _Metallic at 8
  ScalarHalf _Glossiness at 10
  VectorHalf4 _EmissionColor at 16
  VectorBool4 unity_MetaFragmentControl at 24
  Float unity_OneOverOutputBoost at 28
  Float unity_MaxOutputValue at 32
  Float unity_UseLinearSpace at 36
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half4 _EmissionColor;
    bool4 unity_MetaFragmentControl;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
};

struct Mtl_FragmentOut
{
    float4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (1) ]] ,
    sampler sampler_EmissionMap [[ sampler (1) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    float3 u_xlat1;
    half3 u_xlat16_1;
    float4 u_xlat2;
    half u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half u_xlat16_12;
    float u_xlat13;
    half u_xlat16_13;
    bool u_xlatb13;
    u_xlat16_0.x = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_0.x);
    u_xlat16_1.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_4.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_1.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_1.xyz = half3(u_xlat16_1.xyz * Globals._Color.xyz);
    u_xlat16_4.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_4.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * u_xlat16_4.xyz);
    u_xlat16_0.xyz = half3(float3(u_xlat16_0.xyz) * float3(0.5, 0.5, 0.5));
    u_xlat16_12 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_12) + u_xlat16_0.xyz);
    u_xlat16_1.xyz = log2(u_xlat16_0.xyz);
    u_xlat13 = Globals.unity_OneOverOutputBoost;
    u_xlat13 = clamp(u_xlat13, 0.0f, 1.0f);
    u_xlat1.xyz = float3(u_xlat16_1.xyz) * float3(u_xlat13);
    u_xlat1.xyz = exp2(u_xlat1.xyz);
    u_xlat1.xyz = min(u_xlat1.xyz, float3(Globals.unity_MaxOutputValue));
    u_xlat16_0.xyz = (Globals.unity_MetaFragmentControl.x) ? half3(u_xlat1.xyz) : half3(0.0, 0.0, 0.0);
    u_xlat16_1.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    u_xlat1.xyz = float3(u_xlat16_1.xyz) * float3(Globals._EmissionColor.xyz);
    u_xlat2.xyz = u_xlat1.xyz * float3(0.305306017, 0.305306017, 0.305306017) + float3(0.682171106, 0.682171106, 0.682171106);
    u_xlat2.xyz = u_xlat1.xyz * u_xlat2.xyz + float3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat2.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlatb13 = float(0.0)!=Globals.unity_UseLinearSpace;
    u_xlat16_3.xyz = (bool(u_xlatb13)) ? half3(u_xlat1.xyz) : half3(u_xlat2.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.010309278, 0.010309278, 0.010309278));
    u_xlat16_13 = max(u_xlat16_1.y, u_xlat16_1.x);
    u_xlat16_2 = half(max(float(u_xlat16_1.z), 0.0199999996));
    u_xlat16_13 = max(u_xlat16_13, u_xlat16_2);
    u_xlat13 = float(u_xlat16_13) * 255.0;
    u_xlat13 = ceil(u_xlat13);
    u_xlat2.w = u_xlat13 * 0.00392156886;
    u_xlat2.xyz = float3(u_xlat16_1.xyz) / u_xlat2.www;
    u_xlat16_0.w = (Globals.unity_MetaFragmentControl.x) ? 1.0 : 0.0;
    u_xlat16_0 = (Globals.unity_MetaFragmentControl.y) ? half4(u_xlat2) : u_xlat16_0;
    output.SV_Target0 = float4(u_xlat16_0);
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 unity_LightmapST;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	bvec4 unity_MetaVertexControl;
in  vec4 in_POSITION0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
out vec4 vs_TEXCOORD0;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
bool u_xlatb6;
void main()
{
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlatb0 = 0.0<in_POSITION0.z;
    u_xlat0.z = u_xlatb0 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xy = in_TEXCOORD1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    u_xlat0.xyz = (unity_MetaVertexControl.x) ? u_xlat0.xyz : in_POSITION0.xyz;
    u_xlatb6 = 0.0<u_xlat0.z;
    u_xlat1.z = u_xlatb6 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xy = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    u_xlat0.xyz = (unity_MetaVertexControl.y) ? u_xlat1.xyz : u_xlat0.xyz;
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat1 = hlslcc_mtx4x4glstate_matrix_mvp[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 _EmissionColor;
uniform 	bvec4 unity_MetaFragmentControl;
uniform 	float unity_OneOverOutputBoost;
uniform 	float unity_MaxOutputValue;
uniform 	float unity_UseLinearSpace;
uniform  sampler2D _MainTex;
uniform  sampler2D _EmissionMap;
in  vec4 vs_TEXCOORD0;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec4 u_xlat2;
vec3 u_xlat3;
float u_xlat9;
float u_xlat10;
bool u_xlatb10;
void main()
{
    u_xlat0.x = (-_Glossiness) + 1.0;
    u_xlat0.x = u_xlat0.x * u_xlat0.x;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat3.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat3.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat3.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat3.xyz;
    u_xlat0.xyz = u_xlat0.xyz * vec3(0.5, 0.5, 0.5);
    u_xlat9 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat1.xyz * vec3(u_xlat9) + u_xlat0.xyz;
    u_xlat0.xyz = log2(u_xlat0.xyz);
    u_xlat9 = unity_OneOverOutputBoost;
    u_xlat9 = clamp(u_xlat9, 0.0, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * vec3(u_xlat9);
    u_xlat0.xyz = exp2(u_xlat0.xyz);
    u_xlat0.xyz = min(u_xlat0.xyz, vec3(vec3(unity_MaxOutputValue, unity_MaxOutputValue, unity_MaxOutputValue)));
    u_xlat0.w = 1.0;
    u_xlat0 = (unity_MetaFragmentControl.x) ? u_xlat0 : vec4(0.0, 0.0, 0.0, 0.0);
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_1.xyz * _EmissionColor.xyz;
    u_xlat2.xyz = u_xlat1.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat2.xyz = u_xlat1.xyz * u_xlat2.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat2.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlatb10 = vec4(0.0, 0.0, 0.0, 0.0)!=vec4(unity_UseLinearSpace);
    u_xlat1.xyz = (bool(u_xlatb10)) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlat1.xyz = u_xlat1.xyz * vec3(0.010309278, 0.010309278, 0.010309278);
    u_xlat10 = max(u_xlat1.y, u_xlat1.x);
    u_xlat2.x = max(u_xlat1.z, 0.0199999996);
    u_xlat10 = max(u_xlat10, u_xlat2.x);
    u_xlat10 = u_xlat10 * 255.0;
    u_xlat10 = ceil(u_xlat10);
    u_xlat2.w = u_xlat10 * 0.00392156886;
    u_xlat2.xyz = u_xlat1.xyz / u_xlat2.www;
    SV_Target0 = (unity_MetaFragmentControl.y) ? u_xlat2 : u_xlat0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

 }
}
SubShader { 
 LOD 150
 Tags { "RenderType"="Opaque" "PerformanceChecks"="False" }
 Pass {
  Name "FORWARD"
  Tags { "LIGHTMODE"="ForwardBase" "SHADOWSUPPORT"="true" "RenderType"="Opaque" "PerformanceChecks"="False" }
  ZWrite [_ZWrite]
  Blend [_SrcBlend] [_DstBlend]
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (306 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 80
  Matrix4x4 unity_ObjectToWorld at 144
  Matrix4x4 unity_WorldToObject at 208
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHAr at 16
  VectorHalf4 unity_SHAg at 24
  VectorHalf4 unity_SHAb at 32
  VectorHalf4 unity_SHBr at 40
  VectorHalf4 unity_SHBg at 48
  VectorHalf4 unity_SHBb at 56
  VectorHalf4 unity_SHC at 64
  Vector4 _MainTex_ST at 272
  Vector4 _DetailAlbedoMap_ST at 288
  ScalarHalf _UVSec at 304
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    half3 u_xlat16_1;
    half4 u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD4.w = 0.0;
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat0.xyz);
    u_xlat16_1.x = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_1.x = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_1.x)));
    u_xlat16_2 = half4(u_xlat0.yzzx * u_xlat0.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_2);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_2);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_2);
    u_xlat16_1.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_1.xxx + u_xlat16_3.xyz);
    u_xlat0.w = 1.0;
    u_xlat16_2.x = half(dot(float4(Globals.unity_SHAr), u_xlat0));
    u_xlat16_2.y = half(dot(float4(Globals.unity_SHAg), u_xlat0));
    u_xlat16_2.z = half(dot(float4(Globals.unity_SHAb), u_xlat0));
    u_xlat16_1.xyz = half3(u_xlat16_1.xyz + u_xlat16_2.xyz);
    u_xlat16_1.xyz = half3(max(float3(u_xlat16_1.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat0.xyz = log2(float3(u_xlat16_1.xyz));
    u_xlat0.xyz = u_xlat0.xyz * float3(0.416666657, 0.416666657, 0.416666657);
    u_xlat0.xyz = exp2(u_xlat0.xyz);
    u_xlat0.xyz = u_xlat0.xyz * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat0.xyz = max(u_xlat0.xyz, float3(0.0, 0.0, 0.0));
    output.TEXCOORD5.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "unity_NHxRoughness" to slot 2
Set CUBE Texture "unity_SpecCube0" to slot 3

Constant Buffer "Globals" (36 bytes) on slot 0 {
  VectorHalf4 _WorldSpaceLightPos0 at 0
  VectorHalf4 unity_SpecCube0_HDR at 8
  VectorHalf4 _LightColor0 at 16
  VectorHalf4 _Color at 24
  ScalarHalf _Metallic at 32
  ScalarHalf _Glossiness at 34
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    half4 unity_SpecCube0_HDR;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (2) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (2) ]] ,
    texturecube<float, access::sample > unity_SpecCube0 [[ texture (3) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    half3 u_xlat16_3;
    bool u_xlatb3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    half u_xlat16_28;
    u_xlat16_0.xw = half2((-float2(Globals._Glossiness)) + float2(1.0, 1.0));
    u_xlat16_1.x = half((-float(u_xlat16_0.x)) * 0.699999988 + 1.70000005);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_1.x);
    u_xlat16_0.x = half(float(u_xlat16_0.x) * 6.0);
    u_xlat16_1.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_1.x = rsqrt(u_xlat16_1.x);
    u_xlat16_1.xyz = half3(u_xlat16_1.xxx * input.TEXCOORD4.xyz);
    u_xlat16_28 = dot(input.TEXCOORD1.xyz, u_xlat16_1.xyz);
    u_xlat16_28 = half(u_xlat16_28 + u_xlat16_28);
    u_xlat16_2.xyz = half3(u_xlat16_1.xyz * (-half3(u_xlat16_28)) + input.TEXCOORD1.xyz);
    u_xlat10_2 = half4(unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_2.xyz), level(float(u_xlat16_0.x))));
    u_xlatb3 = Globals.unity_SpecCube0_HDR.w==1.0;
    u_xlat16_0.x = (u_xlatb3) ? half(u_xlat10_2.w) : 1.0;
    u_xlat16_0.x = half(u_xlat16_0.x * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_4.xyz = half3(float3(u_xlat10_2.xyz) * float3(u_xlat16_0.xxx));
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_4.xyz = half3(u_xlat16_3.xxx * u_xlat16_4.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_3.xxx * input.TEXCOORD5.xyz);
    u_xlat16_0.x = dot((-input.TEXCOORD1.xyz), u_xlat16_1.xyz);
    u_xlat16_28 = half(u_xlat16_0.x + u_xlat16_0.x);
    u_xlat16_0.x = u_xlat16_0.x;
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_6.y = half((-float(u_xlat16_0.x)) + 1.0);
    u_xlat16_7.xyz = half3(u_xlat16_1.xyz * (-half3(u_xlat16_28)) + (-input.TEXCOORD1.xyz));
    u_xlat16_0.x = dot(u_xlat16_1.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_1.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_6.x = dot(u_xlat16_7.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_6.xy = half2(u_xlat16_6.xy * u_xlat16_6.xy);
    u_xlat16_0.yz = half2(u_xlat16_6.xy * u_xlat16_6.xy);
    u_xlat16_0.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_28 = half((-u_xlat16_0.x) + Globals._Glossiness);
    u_xlat16_28 = half(float(u_xlat16_28) + 1.0);
    u_xlat16_28 = clamp(u_xlat16_28, 0.0h, 1.0h);
    u_xlat16_3.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_6.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_3.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * Globals._Color.xyz);
    u_xlat16_7.xyz = half3(u_xlat16_0.xxx * u_xlat16_3.xyz);
    u_xlat16_6.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_6.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_8.xyz = half3(half3(u_xlat16_28) + (-u_xlat16_6.xyz));
    u_xlat16_8.xyz = half3(u_xlat16_0.zzz * u_xlat16_8.xyz + u_xlat16_6.xyz);
    u_xlat16_3.x = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_0.yw)).w;
    u_xlat16_3.x = half(float(u_xlat16_3.x) * 16.0);
    u_xlat16_0.xyz = half3(u_xlat16_3.xxx * u_xlat16_6.xyz + u_xlat16_7.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * u_xlat16_8.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_5.xyz * u_xlat16_7.xyz + u_xlat16_4.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_0.xyz * u_xlat16_1.xyz + u_xlat16_4.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
float u_xlat12;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = inversesqrt(u_xlat12);
    vs_TEXCOORD1.xyz = vec3(u_xlat12) * u_xlat0.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD4.w = 0.0;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = inversesqrt(u_xlat12);
    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = u_xlat0.x * u_xlat0.x + (-u_xlat1.x);
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(unity_SHBr, u_xlat2);
    u_xlat3.y = dot(unity_SHBg, u_xlat2);
    u_xlat3.z = dot(unity_SHBb, u_xlat2);
    u_xlat1.xyz = unity_SHC.xyz * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(unity_SHAr, u_xlat0);
    u_xlat2.y = dot(unity_SHAg, u_xlat0);
    u_xlat2.z = dot(unity_SHAb, u_xlat0);
    u_xlat0.xyz = u_xlat1.xyz + u_xlat2.xyz;
    u_xlat0.xyz = max(u_xlat0.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat0.xyz = log2(u_xlat0.xyz);
    u_xlat0.xyz = u_xlat0.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat0.xyz = exp2(u_xlat0.xyz);
    u_xlat0.xyz = u_xlat0.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    vs_TEXCOORD5.xyz = max(u_xlat0.xyz, vec3(0.0, 0.0, 0.0));
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_NHxRoughness;
uniform  samplerCube unity_SpecCube0;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
mediump float u_xlat16_0;
lowp vec4 u_xlat10_0;
bool u_xlatb0;
vec3 u_xlat1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
vec3 u_xlat6;
float u_xlat22;
void main()
{
    u_xlat0.xw = (-vec2(vec2(_Glossiness, _Glossiness))) + vec2(1.0, 1.0);
    u_xlat1.x = (-u_xlat0.x) * 0.699999988 + 1.70000005;
    u_xlat0.x = u_xlat0.x * u_xlat1.x;
    u_xlat0.x = u_xlat0.x * 6.0;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat22 = dot(vs_TEXCOORD1.xyz, u_xlat1.xyz);
    u_xlat22 = u_xlat22 + u_xlat22;
    u_xlat2.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + vs_TEXCOORD1.xyz;
    u_xlat10_2 = textureLod(unity_SpecCube0, u_xlat2.xyz, u_xlat0.x);
    u_xlatb0 = unity_SpecCube0_HDR.w==1.0;
    u_xlat0.x = (u_xlatb0) ? u_xlat10_2.w : 1.0;
    u_xlat0.x = u_xlat0.x * unity_SpecCube0_HDR.x;
    u_xlat2.xyz = u_xlat10_2.xyz * u_xlat0.xxx;
    u_xlat10_3 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat10_3.yyy;
    u_xlat3.xyz = u_xlat10_3.yyy * vs_TEXCOORD5.xyz;
    u_xlat0.x = dot((-vs_TEXCOORD1.xyz), u_xlat1.xyz);
    u_xlat22 = u_xlat0.x + u_xlat0.x;
    u_xlat0.x = u_xlat0.x;
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat4.y = (-u_xlat0.x) + 1.0;
    u_xlat5.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + (-vs_TEXCOORD1.xyz);
    u_xlat0.x = dot(u_xlat1.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat1.xyz = u_xlat0.xxx * _LightColor0.xyz;
    u_xlat4.x = dot(u_xlat5.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat4.xy = u_xlat4.xy * u_xlat4.xy;
    u_xlat0.yz = u_xlat4.xy * u_xlat4.xy;
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat22 = (-u_xlat0.x) + _Glossiness;
    u_xlat22 = u_xlat22 + 1.0;
    u_xlat22 = clamp(u_xlat22, 0.0, 1.0);
    u_xlat10_4 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat5.xyz = _Color.xyz * u_xlat10_4.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat4.xyz = u_xlat10_4.xyz * _Color.xyz;
    u_xlat4.xyz = u_xlat0.xxx * u_xlat4.xyz;
    u_xlat5.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat5.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat6.xyz = vec3(u_xlat22) + (-u_xlat5.xyz);
    u_xlat6.xyz = u_xlat0.zzz * u_xlat6.xyz + u_xlat5.xyz;
    u_xlat10_0 = texture(unity_NHxRoughness, u_xlat0.yw);
    u_xlat16_0 = u_xlat10_0.w * 16.0;
    u_xlat0.xyz = vec3(u_xlat16_0) * u_xlat5.xyz + u_xlat4.xyz;
    u_xlat2.xyz = u_xlat2.xyz * u_xlat6.xyz;
    u_xlat2.xyz = u_xlat3.xyz * u_xlat4.xyz + u_xlat2.xyz;
    SV_Target0.xyz = u_xlat0.xyz * u_xlat1.xyz + u_xlat2.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (322 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 96
  Matrix4x4 unity_ObjectToWorld at 160
  Matrix4x4 unity_WorldToObject at 224
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 unity_SHAr at 32
  VectorHalf4 unity_SHAg at 40
  VectorHalf4 unity_SHAb at 48
  VectorHalf4 unity_SHBr at 56
  VectorHalf4 unity_SHBg at 64
  VectorHalf4 unity_SHBb at 72
  VectorHalf4 unity_SHC at 80
  Vector4 _MainTex_ST at 288
  Vector4 _DetailAlbedoMap_ST at 304
  ScalarHalf _UVSec at 320
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half4 u_xlat16_3;
    half3 u_xlat16_4;
    float u_xlat16;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat16 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat1.xyz = float3(u_xlat16) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD4.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat16 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat1.xyz = float3(u_xlat16) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    u_xlat16_2.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_2.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_2.x)));
    u_xlat16_3 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_4.x = dot(Globals.unity_SHBr, u_xlat16_3);
    u_xlat16_4.y = dot(Globals.unity_SHBg, u_xlat16_3);
    u_xlat16_4.z = dot(Globals.unity_SHBb, u_xlat16_3);
    u_xlat16_2.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_2.xxx + u_xlat16_4.xyz);
    u_xlat1.w = 1.0;
    u_xlat16_3.x = half(dot(float4(Globals.unity_SHAr), u_xlat1));
    u_xlat16_3.y = half(dot(float4(Globals.unity_SHAg), u_xlat1));
    u_xlat16_3.z = half(dot(float4(Globals.unity_SHAb), u_xlat1));
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz + u_xlat16_3.xyz);
    u_xlat16_2.xyz = half3(max(float3(u_xlat16_2.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat1.xyz = log2(float3(u_xlat16_2.xyz));
    u_xlat1.xyz = u_xlat1.xyz * float3(0.416666657, 0.416666657, 0.416666657);
    u_xlat1.xyz = exp2(u_xlat1.xyz);
    u_xlat1.xyz = u_xlat1.xyz * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat1.xyz = max(u_xlat1.xyz, float3(0.0, 0.0, 0.0));
    output.TEXCOORD5.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_OcclusionMap" to slot 2
Set 2D Texture "unity_NHxRoughness" to slot 3
Set CUBE Texture "unity_SpecCube0" to slot 4

Constant Buffer "Globals" (36 bytes) on slot 0 {
  VectorHalf4 _WorldSpaceLightPos0 at 0
  VectorHalf4 unity_SpecCube0_HDR at 8
  VectorHalf4 _LightColor0 at 16
  VectorHalf4 _Color at 24
  ScalarHalf _Metallic at 32
  ScalarHalf _Glossiness at 34
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    half4 unity_SpecCube0_HDR;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (2) ]] ,
    sampler sampler_OcclusionMap [[ sampler (2) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (3) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (3) ]] ,
    texturecube<float, access::sample > unity_SpecCube0 [[ texture (4) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    float2 u_xlat3;
    half3 u_xlat16_3;
    bool u_xlatb3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    half u_xlat16_9;
    half u_xlat16_25;
    u_xlat16_0.xw = half2((-float2(Globals._Glossiness)) + float2(1.0, 1.0));
    u_xlat16_1.x = half((-float(u_xlat16_0.x)) * 0.699999988 + 1.70000005);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_1.x);
    u_xlat16_0.x = half(float(u_xlat16_0.x) * 6.0);
    u_xlat16_1.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_1.x = rsqrt(u_xlat16_1.x);
    u_xlat16_1.xyz = half3(u_xlat16_1.xxx * input.TEXCOORD4.xyz);
    u_xlat16_25 = dot(input.TEXCOORD1.xyz, u_xlat16_1.xyz);
    u_xlat16_25 = half(u_xlat16_25 + u_xlat16_25);
    u_xlat16_2.xyz = half3(u_xlat16_1.xyz * (-half3(u_xlat16_25)) + input.TEXCOORD1.xyz);
    u_xlat10_2 = half4(unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_2.xyz), level(float(u_xlat16_0.x))));
    u_xlatb3 = Globals.unity_SpecCube0_HDR.w==1.0;
    u_xlat16_0.x = (u_xlatb3) ? half(u_xlat10_2.w) : 1.0;
    u_xlat16_0.x = half(u_xlat16_0.x * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_4.xyz = half3(float3(u_xlat10_2.xyz) * float3(u_xlat16_0.xxx));
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_4.xyz = half3(u_xlat16_3.xxx * u_xlat16_4.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_3.xxx * input.TEXCOORD5.xyz);
    u_xlat16_0.x = dot((-input.TEXCOORD1.xyz), u_xlat16_1.xyz);
    u_xlat16_25 = half(u_xlat16_0.x + u_xlat16_0.x);
    u_xlat16_0.x = u_xlat16_0.x;
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_6.y = half((-float(u_xlat16_0.x)) + 1.0);
    u_xlat16_7.xyz = half3(u_xlat16_1.xyz * (-half3(u_xlat16_25)) + (-input.TEXCOORD1.xyz));
    u_xlat16_0.x = dot(u_xlat16_1.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_6.x = dot(u_xlat16_7.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_1.xy = half2(u_xlat16_6.xy * u_xlat16_6.xy);
    u_xlat16_0.yz = half2(u_xlat16_1.xy * u_xlat16_1.xy);
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_9 = half((-u_xlat16_1.x) + Globals._Glossiness);
    u_xlat16_9 = half(float(u_xlat16_9) + 1.0);
    u_xlat16_9 = clamp(u_xlat16_9, 0.0h, 1.0h);
    u_xlat16_3.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_6.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_3.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * Globals._Color.xyz);
    u_xlat16_1.xzw = half3(u_xlat16_1.xxx * u_xlat16_3.xyz);
    u_xlat16_6.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_6.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_7.xyz = half3(half3(u_xlat16_9) + (-u_xlat16_6.xyz));
    u_xlat16_7.xyz = half3(u_xlat16_0.zzz * u_xlat16_7.xyz + u_xlat16_6.xyz);
    u_xlat16_3.x = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_0.yw)).w;
    u_xlat16_3.x = half(float(u_xlat16_3.x) * 16.0);
    u_xlat16_8.xyz = half3(u_xlat16_3.xxx * u_xlat16_6.xyz + u_xlat16_1.xzw);
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * u_xlat16_7.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_5.xyz * u_xlat16_1.xzw + u_xlat16_4.xyz);
    u_xlat3.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_3.x = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat3.xy).x;
    u_xlat16_4.xyz = half3(u_xlat16_3.xxx * Globals._LightColor0.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_0.xxx * u_xlat16_4.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_8.xyz * u_xlat16_4.xyz + u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec3 u_xlat2;
vec4 u_xlat3;
vec3 u_xlat4;
float u_xlat16;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat16 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat16 = inversesqrt(u_xlat16);
    vs_TEXCOORD1.xyz = vec3(u_xlat16) * u_xlat1.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD4.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat16 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat16 = inversesqrt(u_xlat16);
    u_xlat1.xyz = vec3(u_xlat16) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat2.x = u_xlat1.y * u_xlat1.y;
    u_xlat2.x = u_xlat1.x * u_xlat1.x + (-u_xlat2.x);
    u_xlat3 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat4.x = dot(unity_SHBr, u_xlat3);
    u_xlat4.y = dot(unity_SHBg, u_xlat3);
    u_xlat4.z = dot(unity_SHBb, u_xlat3);
    u_xlat2.xyz = unity_SHC.xyz * u_xlat2.xxx + u_xlat4.xyz;
    u_xlat1.w = 1.0;
    u_xlat3.x = dot(unity_SHAr, u_xlat1);
    u_xlat3.y = dot(unity_SHAg, u_xlat1);
    u_xlat3.z = dot(unity_SHAb, u_xlat1);
    u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
    u_xlat1.xyz = max(u_xlat1.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat1.xyz = log2(u_xlat1.xyz);
    u_xlat1.xyz = u_xlat1.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat1.xyz = exp2(u_xlat1.xyz);
    u_xlat1.xyz = u_xlat1.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    vs_TEXCOORD5.xyz = max(u_xlat1.xyz, vec3(0.0, 0.0, 0.0));
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_NHxRoughness;
uniform  samplerCube unity_SpecCube0;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
mediump float u_xlat16_7;
float u_xlat8;
float u_xlat22;
void main()
{
    u_xlat0.xw = (-vec2(vec2(_Glossiness, _Glossiness))) + vec2(1.0, 1.0);
    u_xlat1.x = (-u_xlat0.x) * 0.699999988 + 1.70000005;
    u_xlat0.x = u_xlat0.x * u_xlat1.x;
    u_xlat0.x = u_xlat0.x * 6.0;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat22 = dot(vs_TEXCOORD1.xyz, u_xlat1.xyz);
    u_xlat22 = u_xlat22 + u_xlat22;
    u_xlat2.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + vs_TEXCOORD1.xyz;
    u_xlat10_2 = textureLod(unity_SpecCube0, u_xlat2.xyz, u_xlat0.x);
    u_xlatb0 = unity_SpecCube0_HDR.w==1.0;
    u_xlat0.x = (u_xlatb0) ? u_xlat10_2.w : 1.0;
    u_xlat0.x = u_xlat0.x * unity_SpecCube0_HDR.x;
    u_xlat2.xyz = u_xlat10_2.xyz * u_xlat0.xxx;
    u_xlat10_3 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat10_3.yyy;
    u_xlat3.xyz = u_xlat10_3.yyy * vs_TEXCOORD5.xyz;
    u_xlat0.x = dot((-vs_TEXCOORD1.xyz), u_xlat1.xyz);
    u_xlat22 = u_xlat0.x + u_xlat0.x;
    u_xlat0.x = u_xlat0.x;
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat4.y = (-u_xlat0.x) + 1.0;
    u_xlat5.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + (-vs_TEXCOORD1.xyz);
    u_xlat0.x = dot(u_xlat1.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat4.x = dot(u_xlat5.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat1.xy = u_xlat4.xy * u_xlat4.xy;
    u_xlat0.yz = u_xlat1.xy * u_xlat1.xy;
    u_xlat1.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat8 = (-u_xlat1.x) + _Glossiness;
    u_xlat8 = u_xlat8 + 1.0;
    u_xlat8 = clamp(u_xlat8, 0.0, 1.0);
    u_xlat10_4 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat5.xyz = _Color.xyz * u_xlat10_4.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat4.xyz = u_xlat10_4.xyz * _Color.xyz;
    u_xlat1.xzw = u_xlat1.xxx * u_xlat4.xyz;
    u_xlat4.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat5.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat5.xyz = vec3(u_xlat8) + (-u_xlat4.xyz);
    u_xlat5.xyz = u_xlat0.zzz * u_xlat5.xyz + u_xlat4.xyz;
    u_xlat10_6 = texture(unity_NHxRoughness, u_xlat0.yw);
    u_xlat16_7 = u_xlat10_6.w * 16.0;
    u_xlat7.xyz = vec3(u_xlat16_7) * u_xlat4.xyz + u_xlat1.xzw;
    u_xlat2.xyz = u_xlat2.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat3.xyz * u_xlat1.xzw + u_xlat2.xyz;
    u_xlat2.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_2 = texture(_ShadowMapTexture, u_xlat2.xy);
    u_xlat2.xyz = u_xlat10_2.xxx * _LightColor0.xyz;
    u_xlat2.xyz = u_xlat0.xxx * u_xlat2.xyz;
    SV_Target0.xyz = u_xlat7.xyz * u_xlat2.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL _EMISSION 
-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_OcclusionMap" to slot 1
Set 2D Texture "unity_NHxRoughness" to slot 2
Set 2D Texture "_EmissionMap" to slot 3
Set CUBE Texture "unity_SpecCube0" to slot 4

Constant Buffer "Globals" (48 bytes) on slot 0 {
  VectorHalf4 _WorldSpaceLightPos0 at 0
  VectorHalf4 unity_SpecCube0_HDR at 8
  VectorHalf4 _LightColor0 at 16
  VectorHalf4 _Color at 24
  ScalarHalf _Metallic at 32
  ScalarHalf _Glossiness at 34
  VectorHalf4 _EmissionColor at 40
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    half4 unity_SpecCube0_HDR;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (1) ]] ,
    sampler sampler_OcclusionMap [[ sampler (1) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (2) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (2) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (3) ]] ,
    sampler sampler_EmissionMap [[ sampler (3) ]] ,
    texturecube<float, access::sample > unity_SpecCube0 [[ texture (4) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    half3 u_xlat16_3;
    bool u_xlatb3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    half u_xlat16_28;
    u_xlat16_0.xw = half2((-float2(Globals._Glossiness)) + float2(1.0, 1.0));
    u_xlat16_1.x = half((-float(u_xlat16_0.x)) * 0.699999988 + 1.70000005);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_1.x);
    u_xlat16_0.x = half(float(u_xlat16_0.x) * 6.0);
    u_xlat16_1.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_1.x = rsqrt(u_xlat16_1.x);
    u_xlat16_1.xyz = half3(u_xlat16_1.xxx * input.TEXCOORD4.xyz);
    u_xlat16_28 = dot(input.TEXCOORD1.xyz, u_xlat16_1.xyz);
    u_xlat16_28 = half(u_xlat16_28 + u_xlat16_28);
    u_xlat16_2.xyz = half3(u_xlat16_1.xyz * (-half3(u_xlat16_28)) + input.TEXCOORD1.xyz);
    u_xlat10_2 = half4(unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_2.xyz), level(float(u_xlat16_0.x))));
    u_xlatb3 = Globals.unity_SpecCube0_HDR.w==1.0;
    u_xlat16_0.x = (u_xlatb3) ? half(u_xlat10_2.w) : 1.0;
    u_xlat16_0.x = half(u_xlat16_0.x * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_4.xyz = half3(float3(u_xlat10_2.xyz) * float3(u_xlat16_0.xxx));
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_4.xyz = half3(u_xlat16_3.xxx * u_xlat16_4.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_3.xxx * input.TEXCOORD5.xyz);
    u_xlat16_0.x = dot((-input.TEXCOORD1.xyz), u_xlat16_1.xyz);
    u_xlat16_28 = half(u_xlat16_0.x + u_xlat16_0.x);
    u_xlat16_0.x = u_xlat16_0.x;
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_6.y = half((-float(u_xlat16_0.x)) + 1.0);
    u_xlat16_7.xyz = half3(u_xlat16_1.xyz * (-half3(u_xlat16_28)) + (-input.TEXCOORD1.xyz));
    u_xlat16_0.x = dot(u_xlat16_1.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_1.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_6.x = dot(u_xlat16_7.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_6.xy = half2(u_xlat16_6.xy * u_xlat16_6.xy);
    u_xlat16_0.yz = half2(u_xlat16_6.xy * u_xlat16_6.xy);
    u_xlat16_0.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_28 = half((-u_xlat16_0.x) + Globals._Glossiness);
    u_xlat16_28 = half(float(u_xlat16_28) + 1.0);
    u_xlat16_28 = clamp(u_xlat16_28, 0.0h, 1.0h);
    u_xlat16_3.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_6.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_3.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * Globals._Color.xyz);
    u_xlat16_7.xyz = half3(u_xlat16_0.xxx * u_xlat16_3.xyz);
    u_xlat16_6.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_6.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_8.xyz = half3(half3(u_xlat16_28) + (-u_xlat16_6.xyz));
    u_xlat16_8.xyz = half3(u_xlat16_0.zzz * u_xlat16_8.xyz + u_xlat16_6.xyz);
    u_xlat16_3.x = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_0.yw)).w;
    u_xlat16_3.x = half(float(u_xlat16_3.x) * 16.0);
    u_xlat16_0.xyz = half3(u_xlat16_3.xxx * u_xlat16_6.xyz + u_xlat16_7.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * u_xlat16_8.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_5.xyz * u_xlat16_7.xyz + u_xlat16_4.xyz);
    u_xlat16_0.xyz = half3(u_xlat16_0.xyz * u_xlat16_1.xyz + u_xlat16_4.xyz);
    u_xlat16_3.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * Globals._EmissionColor.xyz + u_xlat16_0.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN _EMISSION 
-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "_OcclusionMap" to slot 2
Set 2D Texture "unity_NHxRoughness" to slot 3
Set 2D Texture "_EmissionMap" to slot 4
Set CUBE Texture "unity_SpecCube0" to slot 5

Constant Buffer "Globals" (48 bytes) on slot 0 {
  VectorHalf4 _WorldSpaceLightPos0 at 0
  VectorHalf4 unity_SpecCube0_HDR at 8
  VectorHalf4 _LightColor0 at 16
  VectorHalf4 _Color at 24
  ScalarHalf _Metallic at 32
  ScalarHalf _Glossiness at 34
  VectorHalf4 _EmissionColor at 40
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _WorldSpaceLightPos0;
    half4 unity_SpecCube0_HDR;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half4 _EmissionColor;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > _OcclusionMap [[ texture (2) ]] ,
    sampler sampler_OcclusionMap [[ sampler (2) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (3) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (3) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (4) ]] ,
    sampler sampler_EmissionMap [[ sampler (4) ]] ,
    texturecube<float, access::sample > unity_SpecCube0 [[ texture (5) ]] ,
    sampler samplerunity_SpecCube0 [[ sampler (5) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    half4 u_xlat16_1;
    half3 u_xlat16_2;
    half4 u_xlat10_2;
    float2 u_xlat3;
    half3 u_xlat16_3;
    bool u_xlatb3;
    half3 u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    half3 u_xlat16_8;
    half u_xlat16_9;
    half u_xlat16_25;
    u_xlat16_0.xw = half2((-float2(Globals._Glossiness)) + float2(1.0, 1.0));
    u_xlat16_1.x = half((-float(u_xlat16_0.x)) * 0.699999988 + 1.70000005);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_1.x);
    u_xlat16_0.x = half(float(u_xlat16_0.x) * 6.0);
    u_xlat16_1.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_1.x = rsqrt(u_xlat16_1.x);
    u_xlat16_1.xyz = half3(u_xlat16_1.xxx * input.TEXCOORD4.xyz);
    u_xlat16_25 = dot(input.TEXCOORD1.xyz, u_xlat16_1.xyz);
    u_xlat16_25 = half(u_xlat16_25 + u_xlat16_25);
    u_xlat16_2.xyz = half3(u_xlat16_1.xyz * (-half3(u_xlat16_25)) + input.TEXCOORD1.xyz);
    u_xlat10_2 = half4(unity_SpecCube0.sample(samplerunity_SpecCube0, float3(u_xlat16_2.xyz), level(float(u_xlat16_0.x))));
    u_xlatb3 = Globals.unity_SpecCube0_HDR.w==1.0;
    u_xlat16_0.x = (u_xlatb3) ? half(u_xlat10_2.w) : 1.0;
    u_xlat16_0.x = half(u_xlat16_0.x * Globals.unity_SpecCube0_HDR.x);
    u_xlat16_4.xyz = half3(float3(u_xlat10_2.xyz) * float3(u_xlat16_0.xxx));
    u_xlat16_3.x = _OcclusionMap.sample(sampler_OcclusionMap, input.TEXCOORD0.xy).y;
    u_xlat16_4.xyz = half3(u_xlat16_3.xxx * u_xlat16_4.xyz);
    u_xlat16_5.xyz = half3(u_xlat16_3.xxx * input.TEXCOORD5.xyz);
    u_xlat16_0.x = dot((-input.TEXCOORD1.xyz), u_xlat16_1.xyz);
    u_xlat16_25 = half(u_xlat16_0.x + u_xlat16_0.x);
    u_xlat16_0.x = u_xlat16_0.x;
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_6.y = half((-float(u_xlat16_0.x)) + 1.0);
    u_xlat16_7.xyz = half3(u_xlat16_1.xyz * (-half3(u_xlat16_25)) + (-input.TEXCOORD1.xyz));
    u_xlat16_0.x = dot(u_xlat16_1.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_6.x = dot(u_xlat16_7.xyz, Globals._WorldSpaceLightPos0.xyz);
    u_xlat16_1.xy = half2(u_xlat16_6.xy * u_xlat16_6.xy);
    u_xlat16_0.yz = half2(u_xlat16_1.xy * u_xlat16_1.xy);
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_9 = half((-u_xlat16_1.x) + Globals._Glossiness);
    u_xlat16_9 = half(float(u_xlat16_9) + 1.0);
    u_xlat16_9 = clamp(u_xlat16_9, 0.0h, 1.0h);
    u_xlat16_3.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_6.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_3.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_3.xyz = half3(u_xlat16_3.xyz * Globals._Color.xyz);
    u_xlat16_1.xzw = half3(u_xlat16_1.xxx * u_xlat16_3.xyz);
    u_xlat16_6.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_6.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_7.xyz = half3(half3(u_xlat16_9) + (-u_xlat16_6.xyz));
    u_xlat16_7.xyz = half3(u_xlat16_0.zzz * u_xlat16_7.xyz + u_xlat16_6.xyz);
    u_xlat16_3.x = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_0.yw)).w;
    u_xlat16_3.x = half(float(u_xlat16_3.x) * 16.0);
    u_xlat16_8.xyz = half3(u_xlat16_3.xxx * u_xlat16_6.xyz + u_xlat16_1.xzw);
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * u_xlat16_7.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_5.xyz * u_xlat16_1.xzw + u_xlat16_4.xyz);
    u_xlat3.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_3.x = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat3.xy).x;
    u_xlat16_4.xyz = half3(u_xlat16_3.xxx * Globals._LightColor0.xyz);
    u_xlat16_4.xyz = half3(u_xlat16_0.xxx * u_xlat16_4.xyz);
    u_xlat16_0.xyz = half3(u_xlat16_8.xyz * u_xlat16_4.xyz + u_xlat16_1.xyz);
    u_xlat16_3.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    output.SV_Target0.xyz = half3(u_xlat16_3.xyz * Globals._EmissionColor.xyz + u_xlat16_0.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (418 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 192
  Matrix4x4 unity_ObjectToWorld at 256
  Matrix4x4 unity_WorldToObject at 320
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_4LightPosX0 at 16
  Vector4 unity_4LightPosY0 at 32
  Vector4 unity_4LightPosZ0 at 48
  VectorHalf4 unity_4LightAtten0 at 64
  VectorHalf4 unity_LightColor[8] at 72
  VectorHalf4 unity_SHAr at 136
  VectorHalf4 unity_SHAg at 144
  VectorHalf4 unity_SHAb at 152
  VectorHalf4 unity_SHBr at 160
  VectorHalf4 unity_SHBg at 168
  VectorHalf4 unity_SHBb at 176
  VectorHalf4 unity_SHC at 184
  Vector4 _MainTex_ST at 384
  Vector4 _DetailAlbedoMap_ST at 400
  ScalarHalf _UVSec at 416
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    half4 u_xlat16_2;
    float4 u_xlat3;
    float4 u_xlat4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    float u_xlat21;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat21 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD4.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat21 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    u_xlat2 = (-u_xlat0.xxxx) + Globals.unity_4LightPosX0;
    u_xlat3 = (-u_xlat0.yyyy) + Globals.unity_4LightPosY0;
    u_xlat0 = (-u_xlat0.zzzz) + Globals.unity_4LightPosZ0;
    u_xlat4 = u_xlat1.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat3 = u_xlat2 * u_xlat2 + u_xlat3;
    u_xlat2 = u_xlat2 * u_xlat1.xxxx + u_xlat4;
    u_xlat2 = u_xlat0 * u_xlat1.zzzz + u_xlat2;
    u_xlat0 = u_xlat0 * u_xlat0 + u_xlat3;
    u_xlat0 = max(u_xlat0, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat3 = rsqrt(u_xlat0);
    u_xlat0 = u_xlat0 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat0 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat0;
    u_xlat2 = u_xlat2 * u_xlat3;
    u_xlat2 = max(u_xlat2, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat0 * u_xlat2;
    u_xlat2.xyz = u_xlat0.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat2.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat0.xxx + u_xlat2.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat0.zzz + u_xlat2.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat0.www + u_xlat0.xyz;
    u_xlat16_5.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_5.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_5.x)));
    u_xlat16_2 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_6.x = dot(Globals.unity_SHBr, u_xlat16_2);
    u_xlat16_6.y = dot(Globals.unity_SHBg, u_xlat16_2);
    u_xlat16_6.z = dot(Globals.unity_SHBb, u_xlat16_2);
    u_xlat16_5.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_5.xxx + u_xlat16_6.xyz);
    u_xlat1.w = 1.0;
    u_xlat16_6.x = half(dot(float4(Globals.unity_SHAr), u_xlat1));
    u_xlat16_6.y = half(dot(float4(Globals.unity_SHAg), u_xlat1));
    u_xlat16_6.z = half(dot(float4(Globals.unity_SHAb), u_xlat1));
    u_xlat16_5.xyz = half3(u_xlat16_5.xyz + u_xlat16_6.xyz);
    u_xlat16_5.xyz = half3(max(float3(u_xlat16_5.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat1.xyz = log2(float3(u_xlat16_5.xyz));
    u_xlat1.xyz = u_xlat1.xyz * float3(0.416666657, 0.416666657, 0.416666657);
    u_xlat1.xyz = exp2(u_xlat1.xyz);
    u_xlat1.xyz = u_xlat1.xyz * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat1.xyz = max(u_xlat1.xyz, float3(0.0, 0.0, 0.0));
    output.TEXCOORD5.xyz = half3(u_xlat0.xyz + u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat5;
float u_xlat18;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat18 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    vs_TEXCOORD1.xyz = vec3(u_xlat18) * u_xlat1.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD4.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat1.xyz = vec3(u_xlat18) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat18 = u_xlat1.y * u_xlat1.y;
    u_xlat18 = u_xlat1.x * u_xlat1.x + (-u_xlat18);
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat3.x = dot(unity_SHBr, u_xlat2);
    u_xlat3.y = dot(unity_SHBg, u_xlat2);
    u_xlat3.z = dot(unity_SHBb, u_xlat2);
    u_xlat2.xyz = unity_SHC.xyz * vec3(u_xlat18) + u_xlat3.xyz;
    u_xlat1.w = 1.0;
    u_xlat3.x = dot(unity_SHAr, u_xlat1);
    u_xlat3.y = dot(unity_SHAg, u_xlat1);
    u_xlat3.z = dot(unity_SHAb, u_xlat1);
    u_xlat2.xyz = u_xlat2.xyz + u_xlat3.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat3 = (-u_xlat0.yyyy) + unity_4LightPosY0;
    u_xlat4 = u_xlat1.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat5 = (-u_xlat0.xxxx) + unity_4LightPosX0;
    u_xlat0 = (-u_xlat0.zzzz) + unity_4LightPosZ0;
    u_xlat4 = u_xlat5 * u_xlat1.xxxx + u_xlat4;
    u_xlat1 = u_xlat0 * u_xlat1.zzzz + u_xlat4;
    u_xlat3 = u_xlat5 * u_xlat5 + u_xlat3;
    u_xlat0 = u_xlat0 * u_xlat0 + u_xlat3;
    u_xlat0 = max(u_xlat0, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat3 = inversesqrt(u_xlat0);
    u_xlat0 = u_xlat0 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat0 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat0;
    u_xlat1 = u_xlat1 * u_xlat3;
    u_xlat1 = max(u_xlat1, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat0 * u_xlat1;
    u_xlat1.xyz = u_xlat0.yyy * unity_LightColor[1].xyz;
    u_xlat1.xyz = unity_LightColor[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = unity_LightColor[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    u_xlat0.xyz = unity_LightColor[3].xyz * u_xlat0.www + u_xlat0.xyz;
    vs_TEXCOORD5.xyz = u_xlat2.xyz + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_NHxRoughness;
uniform  samplerCube unity_SpecCube0;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
mediump float u_xlat16_0;
lowp vec4 u_xlat10_0;
bool u_xlatb0;
vec3 u_xlat1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
vec3 u_xlat6;
float u_xlat22;
void main()
{
    u_xlat0.xw = (-vec2(vec2(_Glossiness, _Glossiness))) + vec2(1.0, 1.0);
    u_xlat1.x = (-u_xlat0.x) * 0.699999988 + 1.70000005;
    u_xlat0.x = u_xlat0.x * u_xlat1.x;
    u_xlat0.x = u_xlat0.x * 6.0;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat22 = dot(vs_TEXCOORD1.xyz, u_xlat1.xyz);
    u_xlat22 = u_xlat22 + u_xlat22;
    u_xlat2.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + vs_TEXCOORD1.xyz;
    u_xlat10_2 = textureLod(unity_SpecCube0, u_xlat2.xyz, u_xlat0.x);
    u_xlatb0 = unity_SpecCube0_HDR.w==1.0;
    u_xlat0.x = (u_xlatb0) ? u_xlat10_2.w : 1.0;
    u_xlat0.x = u_xlat0.x * unity_SpecCube0_HDR.x;
    u_xlat2.xyz = u_xlat10_2.xyz * u_xlat0.xxx;
    u_xlat10_3 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat10_3.yyy;
    u_xlat3.xyz = u_xlat10_3.yyy * vs_TEXCOORD5.xyz;
    u_xlat0.x = dot((-vs_TEXCOORD1.xyz), u_xlat1.xyz);
    u_xlat22 = u_xlat0.x + u_xlat0.x;
    u_xlat0.x = u_xlat0.x;
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat4.y = (-u_xlat0.x) + 1.0;
    u_xlat5.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + (-vs_TEXCOORD1.xyz);
    u_xlat0.x = dot(u_xlat1.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat1.xyz = u_xlat0.xxx * _LightColor0.xyz;
    u_xlat4.x = dot(u_xlat5.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat4.xy = u_xlat4.xy * u_xlat4.xy;
    u_xlat0.yz = u_xlat4.xy * u_xlat4.xy;
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat22 = (-u_xlat0.x) + _Glossiness;
    u_xlat22 = u_xlat22 + 1.0;
    u_xlat22 = clamp(u_xlat22, 0.0, 1.0);
    u_xlat10_4 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat5.xyz = _Color.xyz * u_xlat10_4.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat4.xyz = u_xlat10_4.xyz * _Color.xyz;
    u_xlat4.xyz = u_xlat0.xxx * u_xlat4.xyz;
    u_xlat5.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat5.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat6.xyz = vec3(u_xlat22) + (-u_xlat5.xyz);
    u_xlat6.xyz = u_xlat0.zzz * u_xlat6.xyz + u_xlat5.xyz;
    u_xlat10_0 = texture(unity_NHxRoughness, u_xlat0.yw);
    u_xlat16_0 = u_xlat10_0.w * 16.0;
    u_xlat0.xyz = vec3(u_xlat16_0) * u_xlat5.xyz + u_xlat4.xyz;
    u_xlat2.xyz = u_xlat2.xyz * u_xlat6.xyz;
    u_xlat2.xyz = u_xlat3.xyz * u_xlat4.xyz + u_xlat2.xyz;
    SV_Target0.xyz = u_xlat0.xyz * u_xlat1.xyz + u_xlat2.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (434 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 208
  Matrix4x4 unity_ObjectToWorld at 272
  Matrix4x4 unity_WorldToObject at 336
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  Vector4 unity_4LightPosX0 at 32
  Vector4 unity_4LightPosY0 at 48
  Vector4 unity_4LightPosZ0 at 64
  VectorHalf4 unity_4LightAtten0 at 80
  VectorHalf4 unity_LightColor[8] at 88
  VectorHalf4 unity_SHAr at 152
  VectorHalf4 unity_SHAg at 160
  VectorHalf4 unity_SHAb at 168
  VectorHalf4 unity_SHBr at 176
  VectorHalf4 unity_SHBg at 184
  VectorHalf4 unity_SHBb at 192
  VectorHalf4 unity_SHC at 200
  Vector4 _MainTex_ST at 400
  Vector4 _DetailAlbedoMap_ST at 416
  ScalarHalf _UVSec at 432
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    half4 u_xlat16_3;
    float4 u_xlat4;
    float4 u_xlat5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    float u_xlat25;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat25 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat25 = rsqrt(u_xlat25);
    u_xlat2.xyz = float3(u_xlat25) * u_xlat2.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD4.w = 0.0;
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat25 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat25 = rsqrt(u_xlat25);
    u_xlat2.xyz = float3(u_xlat25) * u_xlat2.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat2.xyz);
    u_xlat3 = (-u_xlat1.xxxx) + Globals.unity_4LightPosX0;
    u_xlat4 = (-u_xlat1.yyyy) + Globals.unity_4LightPosY0;
    u_xlat1 = (-u_xlat1.zzzz) + Globals.unity_4LightPosZ0;
    u_xlat5 = u_xlat2.yyyy * u_xlat4;
    u_xlat4 = u_xlat4 * u_xlat4;
    u_xlat4 = u_xlat3 * u_xlat3 + u_xlat4;
    u_xlat3 = u_xlat3 * u_xlat2.xxxx + u_xlat5;
    u_xlat3 = u_xlat1 * u_xlat2.zzzz + u_xlat3;
    u_xlat1 = u_xlat1 * u_xlat1 + u_xlat4;
    u_xlat1 = max(u_xlat1, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = rsqrt(u_xlat1);
    u_xlat1 = u_xlat1 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat1 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat1;
    u_xlat3 = u_xlat3 * u_xlat4;
    u_xlat3 = max(u_xlat3, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat1 * u_xlat3;
    u_xlat3.xyz = u_xlat1.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat3.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat1.zzz + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat1.www + u_xlat1.xyz;
    u_xlat16_6.x = half(u_xlat2.y * u_xlat2.y);
    u_xlat16_6.x = half(u_xlat2.x * u_xlat2.x + (-float(u_xlat16_6.x)));
    u_xlat16_3 = half4(u_xlat2.yzzx * u_xlat2.xyzz);
    u_xlat16_7.x = dot(Globals.unity_SHBr, u_xlat16_3);
    u_xlat16_7.y = dot(Globals.unity_SHBg, u_xlat16_3);
    u_xlat16_7.z = dot(Globals.unity_SHBb, u_xlat16_3);
    u_xlat16_6.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_6.xxx + u_xlat16_7.xyz);
    u_xlat2.w = 1.0;
    u_xlat16_7.x = half(dot(float4(Globals.unity_SHAr), u_xlat2));
    u_xlat16_7.y = half(dot(float4(Globals.unity_SHAg), u_xlat2));
    u_xlat16_7.z = half(dot(float4(Globals.unity_SHAb), u_xlat2));
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + u_xlat16_7.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat2.xyz = log2(float3(u_xlat16_6.xyz));
    u_xlat2.xyz = u_xlat2.xyz * float3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, float3(0.0, 0.0, 0.0));
    output.TEXCOORD5.xyz = half3(u_xlat1.xyz + u_xlat2.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat5;
vec4 u_xlat6;
float u_xlat22;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat22 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat22 = inversesqrt(u_xlat22);
    vs_TEXCOORD1.xyz = vec3(u_xlat22) * u_xlat2.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD4.w = 0.0;
    u_xlat2.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat22 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat22 = inversesqrt(u_xlat22);
    u_xlat2.xyz = vec3(u_xlat22) * u_xlat2.xyz;
    vs_TEXCOORD4.xyz = u_xlat2.xyz;
    u_xlat22 = u_xlat2.y * u_xlat2.y;
    u_xlat22 = u_xlat2.x * u_xlat2.x + (-u_xlat22);
    u_xlat3 = u_xlat2.yzzx * u_xlat2.xyzz;
    u_xlat4.x = dot(unity_SHBr, u_xlat3);
    u_xlat4.y = dot(unity_SHBg, u_xlat3);
    u_xlat4.z = dot(unity_SHBb, u_xlat3);
    u_xlat3.xyz = unity_SHC.xyz * vec3(u_xlat22) + u_xlat4.xyz;
    u_xlat2.w = 1.0;
    u_xlat4.x = dot(unity_SHAr, u_xlat2);
    u_xlat4.y = dot(unity_SHAg, u_xlat2);
    u_xlat4.z = dot(unity_SHAb, u_xlat2);
    u_xlat3.xyz = u_xlat3.xyz + u_xlat4.xyz;
    u_xlat3.xyz = max(u_xlat3.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat3.xyz = log2(u_xlat3.xyz);
    u_xlat3.xyz = u_xlat3.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat3.xyz = exp2(u_xlat3.xyz);
    u_xlat3.xyz = u_xlat3.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat3.xyz = max(u_xlat3.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat4 = (-u_xlat1.yyyy) + unity_4LightPosY0;
    u_xlat5 = u_xlat2.yyyy * u_xlat4;
    u_xlat4 = u_xlat4 * u_xlat4;
    u_xlat6 = (-u_xlat1.xxxx) + unity_4LightPosX0;
    u_xlat1 = (-u_xlat1.zzzz) + unity_4LightPosZ0;
    u_xlat5 = u_xlat6 * u_xlat2.xxxx + u_xlat5;
    u_xlat2 = u_xlat1 * u_xlat2.zzzz + u_xlat5;
    u_xlat4 = u_xlat6 * u_xlat6 + u_xlat4;
    u_xlat1 = u_xlat1 * u_xlat1 + u_xlat4;
    u_xlat1 = max(u_xlat1, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = inversesqrt(u_xlat1);
    u_xlat1 = u_xlat1 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat1 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat1;
    u_xlat2 = u_xlat2 * u_xlat4;
    u_xlat2 = max(u_xlat2, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat1 * u_xlat2;
    u_xlat2.xyz = u_xlat1.yyy * unity_LightColor[1].xyz;
    u_xlat2.xyz = unity_LightColor[0].xyz * u_xlat1.xxx + u_xlat2.xyz;
    u_xlat1.xyz = unity_LightColor[2].xyz * u_xlat1.zzz + u_xlat2.xyz;
    u_xlat1.xyz = unity_LightColor[3].xyz * u_xlat1.www + u_xlat1.xyz;
    vs_TEXCOORD5.xyz = u_xlat3.xyz + u_xlat1.xyz;
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_NHxRoughness;
uniform  samplerCube unity_SpecCube0;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
mediump float u_xlat16_7;
float u_xlat8;
float u_xlat22;
void main()
{
    u_xlat0.xw = (-vec2(vec2(_Glossiness, _Glossiness))) + vec2(1.0, 1.0);
    u_xlat1.x = (-u_xlat0.x) * 0.699999988 + 1.70000005;
    u_xlat0.x = u_xlat0.x * u_xlat1.x;
    u_xlat0.x = u_xlat0.x * 6.0;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat22 = dot(vs_TEXCOORD1.xyz, u_xlat1.xyz);
    u_xlat22 = u_xlat22 + u_xlat22;
    u_xlat2.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + vs_TEXCOORD1.xyz;
    u_xlat10_2 = textureLod(unity_SpecCube0, u_xlat2.xyz, u_xlat0.x);
    u_xlatb0 = unity_SpecCube0_HDR.w==1.0;
    u_xlat0.x = (u_xlatb0) ? u_xlat10_2.w : 1.0;
    u_xlat0.x = u_xlat0.x * unity_SpecCube0_HDR.x;
    u_xlat2.xyz = u_xlat10_2.xyz * u_xlat0.xxx;
    u_xlat10_3 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat10_3.yyy;
    u_xlat3.xyz = u_xlat10_3.yyy * vs_TEXCOORD5.xyz;
    u_xlat0.x = dot((-vs_TEXCOORD1.xyz), u_xlat1.xyz);
    u_xlat22 = u_xlat0.x + u_xlat0.x;
    u_xlat0.x = u_xlat0.x;
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat4.y = (-u_xlat0.x) + 1.0;
    u_xlat5.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + (-vs_TEXCOORD1.xyz);
    u_xlat0.x = dot(u_xlat1.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat4.x = dot(u_xlat5.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat1.xy = u_xlat4.xy * u_xlat4.xy;
    u_xlat0.yz = u_xlat1.xy * u_xlat1.xy;
    u_xlat1.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat8 = (-u_xlat1.x) + _Glossiness;
    u_xlat8 = u_xlat8 + 1.0;
    u_xlat8 = clamp(u_xlat8, 0.0, 1.0);
    u_xlat10_4 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat5.xyz = _Color.xyz * u_xlat10_4.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat4.xyz = u_xlat10_4.xyz * _Color.xyz;
    u_xlat1.xzw = u_xlat1.xxx * u_xlat4.xyz;
    u_xlat4.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat5.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat5.xyz = vec3(u_xlat8) + (-u_xlat4.xyz);
    u_xlat5.xyz = u_xlat0.zzz * u_xlat5.xyz + u_xlat4.xyz;
    u_xlat10_6 = texture(unity_NHxRoughness, u_xlat0.yw);
    u_xlat16_7 = u_xlat10_6.w * 16.0;
    u_xlat7.xyz = vec3(u_xlat16_7) * u_xlat4.xyz + u_xlat1.xzw;
    u_xlat2.xyz = u_xlat2.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat3.xyz * u_xlat1.xzw + u_xlat2.xyz;
    u_xlat2.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_2 = texture(_ShadowMapTexture, u_xlat2.xy);
    u_xlat2.xyz = u_xlat10_2.xxx * _LightColor0.xyz;
    u_xlat2.xyz = u_xlat0.xxx * u_xlat2.xyz;
    SV_Target0.xyz = u_xlat7.xyz * u_xlat2.xyz + u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (306 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 80
  Matrix4x4 unity_ObjectToWorld at 144
  Matrix4x4 unity_WorldToObject at 208
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 unity_SHAr at 16
  VectorHalf4 unity_SHAg at 24
  VectorHalf4 unity_SHAb at 32
  VectorHalf4 unity_SHBr at 40
  VectorHalf4 unity_SHBg at 48
  VectorHalf4 unity_SHBb at 56
  VectorHalf4 unity_SHC at 64
  Vector4 _MainTex_ST at 272
  Vector4 _DetailAlbedoMap_ST at 288
  ScalarHalf _UVSec at 304
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    half3 u_xlat16_1;
    half4 u_xlat16_2;
    half3 u_xlat16_3;
    float u_xlat12;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD4.w = 0.0;
    u_xlat0.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat0.xyz = float3(u_xlat12) * u_xlat0.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat0.xyz);
    u_xlat16_1.x = half(u_xlat0.y * u_xlat0.y);
    u_xlat16_1.x = half(u_xlat0.x * u_xlat0.x + (-float(u_xlat16_1.x)));
    u_xlat16_2 = half4(u_xlat0.yzzx * u_xlat0.xyzz);
    u_xlat16_3.x = dot(Globals.unity_SHBr, u_xlat16_2);
    u_xlat16_3.y = dot(Globals.unity_SHBg, u_xlat16_2);
    u_xlat16_3.z = dot(Globals.unity_SHBb, u_xlat16_2);
    u_xlat16_1.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_1.xxx + u_xlat16_3.xyz);
    u_xlat0.w = 1.0;
    u_xlat16_2.x = half(dot(float4(Globals.unity_SHAr), u_xlat0));
    u_xlat16_2.y = half(dot(float4(Globals.unity_SHAg), u_xlat0));
    u_xlat16_2.z = half(dot(float4(Globals.unity_SHAb), u_xlat0));
    u_xlat16_1.xyz = half3(u_xlat16_1.xyz + u_xlat16_2.xyz);
    u_xlat16_1.xyz = half3(max(float3(u_xlat16_1.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat0.xyz = log2(float3(u_xlat16_1.xyz));
    u_xlat0.xyz = u_xlat0.xyz * float3(0.416666657, 0.416666657, 0.416666657);
    u_xlat0.xyz = exp2(u_xlat0.xyz);
    u_xlat0.xyz = u_xlat0.xyz * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat0.xyz = max(u_xlat0.xyz, float3(0.0, 0.0, 0.0));
    output.TEXCOORD5.xyz = half3(u_xlat0.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
vec4 u_xlat2;
vec3 u_xlat3;
float u_xlat12;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = inversesqrt(u_xlat12);
    vs_TEXCOORD1.xyz = vec3(u_xlat12) * u_xlat0.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD4.w = 0.0;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat12 = inversesqrt(u_xlat12);
    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;
    vs_TEXCOORD4.xyz = u_xlat0.xyz;
    u_xlat1.x = u_xlat0.y * u_xlat0.y;
    u_xlat1.x = u_xlat0.x * u_xlat0.x + (-u_xlat1.x);
    u_xlat2 = u_xlat0.yzzx * u_xlat0.xyzz;
    u_xlat3.x = dot(unity_SHBr, u_xlat2);
    u_xlat3.y = dot(unity_SHBg, u_xlat2);
    u_xlat3.z = dot(unity_SHBb, u_xlat2);
    u_xlat1.xyz = unity_SHC.xyz * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat0.w = 1.0;
    u_xlat2.x = dot(unity_SHAr, u_xlat0);
    u_xlat2.y = dot(unity_SHAg, u_xlat0);
    u_xlat2.z = dot(unity_SHAb, u_xlat0);
    u_xlat0.xyz = u_xlat1.xyz + u_xlat2.xyz;
    u_xlat0.xyz = max(u_xlat0.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat0.xyz = log2(u_xlat0.xyz);
    u_xlat0.xyz = u_xlat0.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat0.xyz = exp2(u_xlat0.xyz);
    u_xlat0.xyz = u_xlat0.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    vs_TEXCOORD5.xyz = max(u_xlat0.xyz, vec3(0.0, 0.0, 0.0));
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_NHxRoughness;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
mediump float u_xlat16_0;
lowp vec4 u_xlat10_0;
bool u_xlatb0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
vec3 u_xlat6;
float u_xlat22;
void main()
{
    u_xlat0.xw = (-vec2(vec2(_Glossiness, _Glossiness))) + vec2(1.0, 1.0);
    u_xlat1.x = (-u_xlat0.x) * 0.699999988 + 1.70000005;
    u_xlat0.x = u_xlat0.x * u_xlat1.x;
    u_xlat0.x = u_xlat0.x * 6.0;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat22 = dot(vs_TEXCOORD1.xyz, u_xlat1.xyz);
    u_xlat22 = u_xlat22 + u_xlat22;
    u_xlat2.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + vs_TEXCOORD1.xyz;
    u_xlat10_2 = textureLod(unity_SpecCube0, u_xlat2.xyz, u_xlat0.x);
    u_xlatb0 = unity_SpecCube0_HDR.w==1.0;
    u_xlat0.x = (u_xlatb0) ? u_xlat10_2.w : 1.0;
    u_xlat0.x = u_xlat0.x * unity_SpecCube0_HDR.x;
    u_xlat2.xyz = u_xlat10_2.xyz * u_xlat0.xxx;
    u_xlat10_3 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat10_3.yyy;
    u_xlat3.xyz = u_xlat10_3.yyy * vs_TEXCOORD5.xyz;
    u_xlat0.x = dot((-vs_TEXCOORD1.xyz), u_xlat1.xyz);
    u_xlat22 = u_xlat0.x + u_xlat0.x;
    u_xlat0.x = u_xlat0.x;
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat4.y = (-u_xlat0.x) + 1.0;
    u_xlat5.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + (-vs_TEXCOORD1.xyz);
    u_xlat0.x = dot(u_xlat1.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat1.xyz = u_xlat0.xxx * _LightColor0.xyz;
    u_xlat4.x = dot(u_xlat5.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat4.xy = u_xlat4.xy * u_xlat4.xy;
    u_xlat0.yz = u_xlat4.xy * u_xlat4.xy;
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat22 = (-u_xlat0.x) + _Glossiness;
    u_xlat22 = u_xlat22 + 1.0;
    u_xlat22 = clamp(u_xlat22, 0.0, 1.0);
    u_xlat10_4 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat5.xyz = _Color.xyz * u_xlat10_4.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat4.xyz = u_xlat10_4.xyz * _Color.xyz;
    u_xlat4.xyz = u_xlat0.xxx * u_xlat4.xyz;
    u_xlat5.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat5.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat6.xyz = vec3(u_xlat22) + (-u_xlat5.xyz);
    u_xlat6.xyz = u_xlat0.zzz * u_xlat6.xyz + u_xlat5.xyz;
    u_xlat10_0 = texture(unity_NHxRoughness, u_xlat0.yw);
    u_xlat16_0 = u_xlat10_0.w * 16.0;
    u_xlat0.xyz = vec3(u_xlat16_0) * u_xlat5.xyz + u_xlat4.xyz;
    u_xlat2.xyz = u_xlat2.xyz * u_xlat6.xyz;
    u_xlat2.xyz = u_xlat3.xyz * u_xlat4.xyz + u_xlat2.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz + u_xlat2.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN _EMISSION 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (322 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 96
  Matrix4x4 unity_ObjectToWorld at 160
  Matrix4x4 unity_WorldToObject at 224
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 unity_SHAr at 32
  VectorHalf4 unity_SHAg at 40
  VectorHalf4 unity_SHAb at 48
  VectorHalf4 unity_SHBr at 56
  VectorHalf4 unity_SHBg at 64
  VectorHalf4 unity_SHBb at 72
  VectorHalf4 unity_SHC at 80
  Vector4 _MainTex_ST at 288
  Vector4 _DetailAlbedoMap_ST at 304
  ScalarHalf _UVSec at 320
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    half3 u_xlat16_2;
    half4 u_xlat16_3;
    half3 u_xlat16_4;
    float u_xlat16;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat16 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat1.xyz = float3(u_xlat16) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD4.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat16 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat16 = rsqrt(u_xlat16);
    u_xlat1.xyz = float3(u_xlat16) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    u_xlat16_2.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_2.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_2.x)));
    u_xlat16_3 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_4.x = dot(Globals.unity_SHBr, u_xlat16_3);
    u_xlat16_4.y = dot(Globals.unity_SHBg, u_xlat16_3);
    u_xlat16_4.z = dot(Globals.unity_SHBb, u_xlat16_3);
    u_xlat16_2.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_2.xxx + u_xlat16_4.xyz);
    u_xlat1.w = 1.0;
    u_xlat16_3.x = half(dot(float4(Globals.unity_SHAr), u_xlat1));
    u_xlat16_3.y = half(dot(float4(Globals.unity_SHAg), u_xlat1));
    u_xlat16_3.z = half(dot(float4(Globals.unity_SHAb), u_xlat1));
    u_xlat16_2.xyz = half3(u_xlat16_2.xyz + u_xlat16_3.xyz);
    u_xlat16_2.xyz = half3(max(float3(u_xlat16_2.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat1.xyz = log2(float3(u_xlat16_2.xyz));
    u_xlat1.xyz = u_xlat1.xyz * float3(0.416666657, 0.416666657, 0.416666657);
    u_xlat1.xyz = exp2(u_xlat1.xyz);
    u_xlat1.xyz = u_xlat1.xyz * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat1.xyz = max(u_xlat1.xyz, float3(0.0, 0.0, 0.0));
    output.TEXCOORD5.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec3 u_xlat2;
vec4 u_xlat3;
vec3 u_xlat4;
float u_xlat16;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    u_xlat1.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat16 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat16 = inversesqrt(u_xlat16);
    vs_TEXCOORD1.xyz = vec3(u_xlat16) * u_xlat1.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD4.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat16 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat16 = inversesqrt(u_xlat16);
    u_xlat1.xyz = vec3(u_xlat16) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat2.x = u_xlat1.y * u_xlat1.y;
    u_xlat2.x = u_xlat1.x * u_xlat1.x + (-u_xlat2.x);
    u_xlat3 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat4.x = dot(unity_SHBr, u_xlat3);
    u_xlat4.y = dot(unity_SHBg, u_xlat3);
    u_xlat4.z = dot(unity_SHBb, u_xlat3);
    u_xlat2.xyz = unity_SHC.xyz * u_xlat2.xxx + u_xlat4.xyz;
    u_xlat1.w = 1.0;
    u_xlat3.x = dot(unity_SHAr, u_xlat1);
    u_xlat3.y = dot(unity_SHAg, u_xlat1);
    u_xlat3.z = dot(unity_SHAb, u_xlat1);
    u_xlat1.xyz = u_xlat2.xyz + u_xlat3.xyz;
    u_xlat1.xyz = max(u_xlat1.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat1.xyz = log2(u_xlat1.xyz);
    u_xlat1.xyz = u_xlat1.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat1.xyz = exp2(u_xlat1.xyz);
    u_xlat1.xyz = u_xlat1.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    vs_TEXCOORD5.xyz = max(u_xlat1.xyz, vec3(0.0, 0.0, 0.0));
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_NHxRoughness;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
mediump float u_xlat16_7;
float u_xlat8;
float u_xlat22;
void main()
{
    u_xlat0.xw = (-vec2(vec2(_Glossiness, _Glossiness))) + vec2(1.0, 1.0);
    u_xlat1.x = (-u_xlat0.x) * 0.699999988 + 1.70000005;
    u_xlat0.x = u_xlat0.x * u_xlat1.x;
    u_xlat0.x = u_xlat0.x * 6.0;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat22 = dot(vs_TEXCOORD1.xyz, u_xlat1.xyz);
    u_xlat22 = u_xlat22 + u_xlat22;
    u_xlat2.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + vs_TEXCOORD1.xyz;
    u_xlat10_2 = textureLod(unity_SpecCube0, u_xlat2.xyz, u_xlat0.x);
    u_xlatb0 = unity_SpecCube0_HDR.w==1.0;
    u_xlat0.x = (u_xlatb0) ? u_xlat10_2.w : 1.0;
    u_xlat0.x = u_xlat0.x * unity_SpecCube0_HDR.x;
    u_xlat2.xyz = u_xlat10_2.xyz * u_xlat0.xxx;
    u_xlat10_3 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat10_3.yyy;
    u_xlat3.xyz = u_xlat10_3.yyy * vs_TEXCOORD5.xyz;
    u_xlat0.x = dot((-vs_TEXCOORD1.xyz), u_xlat1.xyz);
    u_xlat22 = u_xlat0.x + u_xlat0.x;
    u_xlat0.x = u_xlat0.x;
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat4.y = (-u_xlat0.x) + 1.0;
    u_xlat5.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + (-vs_TEXCOORD1.xyz);
    u_xlat0.x = dot(u_xlat1.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat4.x = dot(u_xlat5.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat1.xy = u_xlat4.xy * u_xlat4.xy;
    u_xlat0.yz = u_xlat1.xy * u_xlat1.xy;
    u_xlat1.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat8 = (-u_xlat1.x) + _Glossiness;
    u_xlat8 = u_xlat8 + 1.0;
    u_xlat8 = clamp(u_xlat8, 0.0, 1.0);
    u_xlat10_4 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat5.xyz = _Color.xyz * u_xlat10_4.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat4.xyz = u_xlat10_4.xyz * _Color.xyz;
    u_xlat1.xzw = u_xlat1.xxx * u_xlat4.xyz;
    u_xlat4.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat5.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat5.xyz = vec3(u_xlat8) + (-u_xlat4.xyz);
    u_xlat5.xyz = u_xlat0.zzz * u_xlat5.xyz + u_xlat4.xyz;
    u_xlat10_6 = texture(unity_NHxRoughness, u_xlat0.yw);
    u_xlat16_7 = u_xlat10_6.w * 16.0;
    u_xlat7.xyz = vec3(u_xlat16_7) * u_xlat4.xyz + u_xlat1.xzw;
    u_xlat2.xyz = u_xlat2.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat3.xyz * u_xlat1.xzw + u_xlat2.xyz;
    u_xlat2.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_2 = texture(_ShadowMapTexture, u_xlat2.xy);
    u_xlat2.xyz = u_xlat10_2.xxx * _LightColor0.xyz;
    u_xlat2.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat0.xyz = u_xlat7.xyz * u_xlat2.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL _EMISSION VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (418 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 192
  Matrix4x4 unity_ObjectToWorld at 256
  Matrix4x4 unity_WorldToObject at 320
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 unity_4LightPosX0 at 16
  Vector4 unity_4LightPosY0 at 32
  Vector4 unity_4LightPosZ0 at 48
  VectorHalf4 unity_4LightAtten0 at 64
  VectorHalf4 unity_LightColor[8] at 72
  VectorHalf4 unity_SHAr at 136
  VectorHalf4 unity_SHAg at 144
  VectorHalf4 unity_SHAb at 152
  VectorHalf4 unity_SHBr at 160
  VectorHalf4 unity_SHBg at 168
  VectorHalf4 unity_SHBb at 176
  VectorHalf4 unity_SHC at 184
  Vector4 _MainTex_ST at 384
  Vector4 _DetailAlbedoMap_ST at 400
  ScalarHalf _UVSec at 416
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float4 u_xlat2;
    half4 u_xlat16_2;
    float4 u_xlat3;
    float4 u_xlat4;
    half3 u_xlat16_5;
    half3 u_xlat16_6;
    float u_xlat21;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat21 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD4.w = 0.0;
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat21 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat21 = rsqrt(u_xlat21);
    u_xlat1.xyz = float3(u_xlat21) * u_xlat1.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat1.xyz);
    u_xlat2 = (-u_xlat0.xxxx) + Globals.unity_4LightPosX0;
    u_xlat3 = (-u_xlat0.yyyy) + Globals.unity_4LightPosY0;
    u_xlat0 = (-u_xlat0.zzzz) + Globals.unity_4LightPosZ0;
    u_xlat4 = u_xlat1.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat3 = u_xlat2 * u_xlat2 + u_xlat3;
    u_xlat2 = u_xlat2 * u_xlat1.xxxx + u_xlat4;
    u_xlat2 = u_xlat0 * u_xlat1.zzzz + u_xlat2;
    u_xlat0 = u_xlat0 * u_xlat0 + u_xlat3;
    u_xlat0 = max(u_xlat0, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat3 = rsqrt(u_xlat0);
    u_xlat0 = u_xlat0 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat0 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat0;
    u_xlat2 = u_xlat2 * u_xlat3;
    u_xlat2 = max(u_xlat2, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat0 * u_xlat2;
    u_xlat2.xyz = u_xlat0.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat2.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat0.xxx + u_xlat2.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat0.zzz + u_xlat2.xyz;
    u_xlat0.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat0.www + u_xlat0.xyz;
    u_xlat16_5.x = half(u_xlat1.y * u_xlat1.y);
    u_xlat16_5.x = half(u_xlat1.x * u_xlat1.x + (-float(u_xlat16_5.x)));
    u_xlat16_2 = half4(u_xlat1.yzzx * u_xlat1.xyzz);
    u_xlat16_6.x = dot(Globals.unity_SHBr, u_xlat16_2);
    u_xlat16_6.y = dot(Globals.unity_SHBg, u_xlat16_2);
    u_xlat16_6.z = dot(Globals.unity_SHBb, u_xlat16_2);
    u_xlat16_5.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_5.xxx + u_xlat16_6.xyz);
    u_xlat1.w = 1.0;
    u_xlat16_6.x = half(dot(float4(Globals.unity_SHAr), u_xlat1));
    u_xlat16_6.y = half(dot(float4(Globals.unity_SHAg), u_xlat1));
    u_xlat16_6.z = half(dot(float4(Globals.unity_SHAb), u_xlat1));
    u_xlat16_5.xyz = half3(u_xlat16_5.xyz + u_xlat16_6.xyz);
    u_xlat16_5.xyz = half3(max(float3(u_xlat16_5.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat1.xyz = log2(float3(u_xlat16_5.xyz));
    u_xlat1.xyz = u_xlat1.xyz * float3(0.416666657, 0.416666657, 0.416666657);
    u_xlat1.xyz = exp2(u_xlat1.xyz);
    u_xlat1.xyz = u_xlat1.xyz * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat1.xyz = max(u_xlat1.xyz, float3(0.0, 0.0, 0.0));
    output.TEXCOORD5.xyz = half3(u_xlat0.xyz + u_xlat1.xyz);
    output.TEXCOORD5.w = 0.0;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat5;
float u_xlat18;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat18 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    vs_TEXCOORD1.xyz = vec3(u_xlat18) * u_xlat1.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD4.w = 0.0;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat18 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat18 = inversesqrt(u_xlat18);
    u_xlat1.xyz = vec3(u_xlat18) * u_xlat1.xyz;
    vs_TEXCOORD4.xyz = u_xlat1.xyz;
    u_xlat18 = u_xlat1.y * u_xlat1.y;
    u_xlat18 = u_xlat1.x * u_xlat1.x + (-u_xlat18);
    u_xlat2 = u_xlat1.yzzx * u_xlat1.xyzz;
    u_xlat3.x = dot(unity_SHBr, u_xlat2);
    u_xlat3.y = dot(unity_SHBg, u_xlat2);
    u_xlat3.z = dot(unity_SHBb, u_xlat2);
    u_xlat2.xyz = unity_SHC.xyz * vec3(u_xlat18) + u_xlat3.xyz;
    u_xlat1.w = 1.0;
    u_xlat3.x = dot(unity_SHAr, u_xlat1);
    u_xlat3.y = dot(unity_SHAg, u_xlat1);
    u_xlat3.z = dot(unity_SHAb, u_xlat1);
    u_xlat2.xyz = u_xlat2.xyz + u_xlat3.xyz;
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat2.xyz = log2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat3 = (-u_xlat0.yyyy) + unity_4LightPosY0;
    u_xlat4 = u_xlat1.yyyy * u_xlat3;
    u_xlat3 = u_xlat3 * u_xlat3;
    u_xlat5 = (-u_xlat0.xxxx) + unity_4LightPosX0;
    u_xlat0 = (-u_xlat0.zzzz) + unity_4LightPosZ0;
    u_xlat4 = u_xlat5 * u_xlat1.xxxx + u_xlat4;
    u_xlat1 = u_xlat0 * u_xlat1.zzzz + u_xlat4;
    u_xlat3 = u_xlat5 * u_xlat5 + u_xlat3;
    u_xlat0 = u_xlat0 * u_xlat0 + u_xlat3;
    u_xlat0 = max(u_xlat0, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat3 = inversesqrt(u_xlat0);
    u_xlat0 = u_xlat0 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat0 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat0;
    u_xlat1 = u_xlat1 * u_xlat3;
    u_xlat1 = max(u_xlat1, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat0 = u_xlat0 * u_xlat1;
    u_xlat1.xyz = u_xlat0.yyy * unity_LightColor[1].xyz;
    u_xlat1.xyz = unity_LightColor[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = unity_LightColor[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    u_xlat0.xyz = unity_LightColor[3].xyz * u_xlat0.www + u_xlat0.xyz;
    vs_TEXCOORD5.xyz = u_xlat2.xyz + u_xlat0.xyz;
    vs_TEXCOORD5.w = 0.0;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_NHxRoughness;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
mediump float u_xlat16_0;
lowp vec4 u_xlat10_0;
bool u_xlatb0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
vec3 u_xlat6;
float u_xlat22;
void main()
{
    u_xlat0.xw = (-vec2(vec2(_Glossiness, _Glossiness))) + vec2(1.0, 1.0);
    u_xlat1.x = (-u_xlat0.x) * 0.699999988 + 1.70000005;
    u_xlat0.x = u_xlat0.x * u_xlat1.x;
    u_xlat0.x = u_xlat0.x * 6.0;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat22 = dot(vs_TEXCOORD1.xyz, u_xlat1.xyz);
    u_xlat22 = u_xlat22 + u_xlat22;
    u_xlat2.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + vs_TEXCOORD1.xyz;
    u_xlat10_2 = textureLod(unity_SpecCube0, u_xlat2.xyz, u_xlat0.x);
    u_xlatb0 = unity_SpecCube0_HDR.w==1.0;
    u_xlat0.x = (u_xlatb0) ? u_xlat10_2.w : 1.0;
    u_xlat0.x = u_xlat0.x * unity_SpecCube0_HDR.x;
    u_xlat2.xyz = u_xlat10_2.xyz * u_xlat0.xxx;
    u_xlat10_3 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat10_3.yyy;
    u_xlat3.xyz = u_xlat10_3.yyy * vs_TEXCOORD5.xyz;
    u_xlat0.x = dot((-vs_TEXCOORD1.xyz), u_xlat1.xyz);
    u_xlat22 = u_xlat0.x + u_xlat0.x;
    u_xlat0.x = u_xlat0.x;
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat4.y = (-u_xlat0.x) + 1.0;
    u_xlat5.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + (-vs_TEXCOORD1.xyz);
    u_xlat0.x = dot(u_xlat1.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat1.xyz = u_xlat0.xxx * _LightColor0.xyz;
    u_xlat4.x = dot(u_xlat5.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat4.xy = u_xlat4.xy * u_xlat4.xy;
    u_xlat0.yz = u_xlat4.xy * u_xlat4.xy;
    u_xlat0.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat22 = (-u_xlat0.x) + _Glossiness;
    u_xlat22 = u_xlat22 + 1.0;
    u_xlat22 = clamp(u_xlat22, 0.0, 1.0);
    u_xlat10_4 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat5.xyz = _Color.xyz * u_xlat10_4.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat4.xyz = u_xlat10_4.xyz * _Color.xyz;
    u_xlat4.xyz = u_xlat0.xxx * u_xlat4.xyz;
    u_xlat5.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat5.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat6.xyz = vec3(u_xlat22) + (-u_xlat5.xyz);
    u_xlat6.xyz = u_xlat0.zzz * u_xlat6.xyz + u_xlat5.xyz;
    u_xlat10_0 = texture(unity_NHxRoughness, u_xlat0.yw);
    u_xlat16_0 = u_xlat10_0.w * 16.0;
    u_xlat0.xyz = vec3(u_xlat16_0) * u_xlat5.xyz + u_xlat4.xyz;
    u_xlat2.xyz = u_xlat2.xyz * u_xlat6.xyz;
    u_xlat2.xyz = u_xlat3.xyz * u_xlat4.xyz + u_xlat2.xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz + u_xlat2.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN _EMISSION VERTEXLIGHT_ON 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (434 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 208
  Matrix4x4 unity_ObjectToWorld at 272
  Matrix4x4 unity_WorldToObject at 336
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  Vector4 unity_4LightPosX0 at 32
  Vector4 unity_4LightPosY0 at 48
  Vector4 unity_4LightPosZ0 at 64
  VectorHalf4 unity_4LightAtten0 at 80
  VectorHalf4 unity_LightColor[8] at 88
  VectorHalf4 unity_SHAr at 152
  VectorHalf4 unity_SHAg at 160
  VectorHalf4 unity_SHAb at 168
  VectorHalf4 unity_SHBr at 176
  VectorHalf4 unity_SHBg at 184
  VectorHalf4 unity_SHBb at 192
  VectorHalf4 unity_SHC at 200
  Vector4 _MainTex_ST at 400
  Vector4 _DetailAlbedoMap_ST at 416
  ScalarHalf _UVSec at 432
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    half4 unity_4LightAtten0;
    half4 unity_LightColor[8];
    half4 unity_SHAr;
    half4 unity_SHAg;
    half4 unity_SHAb;
    half4 unity_SHBr;
    half4 unity_SHBg;
    half4 unity_SHBb;
    half4 unity_SHC;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    half4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float4 u_xlat2;
    float4 u_xlat3;
    half4 u_xlat16_3;
    float4 u_xlat4;
    float4 u_xlat5;
    half3 u_xlat16_6;
    half3 u_xlat16_7;
    float u_xlat25;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat25 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat25 = rsqrt(u_xlat25);
    u_xlat2.xyz = float3(u_xlat25) * u_xlat2.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD3 = half4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD4.w = 0.0;
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat25 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat25 = rsqrt(u_xlat25);
    u_xlat2.xyz = float3(u_xlat25) * u_xlat2.xyz;
    output.TEXCOORD4.xyz = half3(u_xlat2.xyz);
    u_xlat3 = (-u_xlat1.xxxx) + Globals.unity_4LightPosX0;
    u_xlat4 = (-u_xlat1.yyyy) + Globals.unity_4LightPosY0;
    u_xlat1 = (-u_xlat1.zzzz) + Globals.unity_4LightPosZ0;
    u_xlat5 = u_xlat2.yyyy * u_xlat4;
    u_xlat4 = u_xlat4 * u_xlat4;
    u_xlat4 = u_xlat3 * u_xlat3 + u_xlat4;
    u_xlat3 = u_xlat3 * u_xlat2.xxxx + u_xlat5;
    u_xlat3 = u_xlat1 * u_xlat2.zzzz + u_xlat3;
    u_xlat1 = u_xlat1 * u_xlat1 + u_xlat4;
    u_xlat1 = max(u_xlat1, float4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = rsqrt(u_xlat1);
    u_xlat1 = u_xlat1 * float4(Globals.unity_4LightAtten0) + float4(1.0, 1.0, 1.0, 1.0);
    u_xlat1 = float4(1.0, 1.0, 1.0, 1.0) / u_xlat1;
    u_xlat3 = u_xlat3 * u_xlat4;
    u_xlat3 = max(u_xlat3, float4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat1 * u_xlat3;
    u_xlat3.xyz = u_xlat1.yyy * float3(Globals.unity_LightColor[1].xyz);
    u_xlat3.xyz = float3(Globals.unity_LightColor[0].xyz) * u_xlat1.xxx + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[2].xyz) * u_xlat1.zzz + u_xlat3.xyz;
    u_xlat1.xyz = float3(Globals.unity_LightColor[3].xyz) * u_xlat1.www + u_xlat1.xyz;
    u_xlat16_6.x = half(u_xlat2.y * u_xlat2.y);
    u_xlat16_6.x = half(u_xlat2.x * u_xlat2.x + (-float(u_xlat16_6.x)));
    u_xlat16_3 = half4(u_xlat2.yzzx * u_xlat2.xyzz);
    u_xlat16_7.x = dot(Globals.unity_SHBr, u_xlat16_3);
    u_xlat16_7.y = dot(Globals.unity_SHBg, u_xlat16_3);
    u_xlat16_7.z = dot(Globals.unity_SHBb, u_xlat16_3);
    u_xlat16_6.xyz = half3(Globals.unity_SHC.xyz * u_xlat16_6.xxx + u_xlat16_7.xyz);
    u_xlat2.w = 1.0;
    u_xlat16_7.x = half(dot(float4(Globals.unity_SHAr), u_xlat2));
    u_xlat16_7.y = half(dot(float4(Globals.unity_SHAg), u_xlat2));
    u_xlat16_7.z = half(dot(float4(Globals.unity_SHAb), u_xlat2));
    u_xlat16_6.xyz = half3(u_xlat16_6.xyz + u_xlat16_7.xyz);
    u_xlat16_6.xyz = half3(max(float3(u_xlat16_6.xyz), float3(0.0, 0.0, 0.0)));
    u_xlat2.xyz = log2(float3(u_xlat16_6.xyz));
    u_xlat2.xyz = u_xlat2.xyz * float3(0.416666657, 0.416666657, 0.416666657);
    u_xlat2.xyz = exp2(u_xlat2.xyz);
    u_xlat2.xyz = u_xlat2.xyz * float3(1.05499995, 1.05499995, 1.05499995) + float3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat2.xyz = max(u_xlat2.xyz, float3(0.0, 0.0, 0.0));
    output.TEXCOORD5.xyz = half3(u_xlat1.xyz + u_xlat2.xyz);
    output.TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 unity_4LightPosX0;
uniform 	vec4 unity_4LightPosY0;
uniform 	vec4 unity_4LightPosZ0;
uniform 	vec4 unity_4LightAtten0;
uniform 	vec4 unity_LightColor[8];
uniform 	vec4 unity_SHAr;
uniform 	vec4 unity_SHAg;
uniform 	vec4 unity_SHAb;
uniform 	vec4 unity_SHBr;
uniform 	vec4 unity_SHBg;
uniform 	vec4 unity_SHBb;
uniform 	vec4 unity_SHC;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec4 u_xlat2;
vec4 u_xlat3;
vec4 u_xlat4;
vec4 u_xlat5;
vec4 u_xlat6;
float u_xlat22;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat22 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat22 = inversesqrt(u_xlat22);
    vs_TEXCOORD1.xyz = vec3(u_xlat22) * u_xlat2.xyz;
    vs_TEXCOORD2 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD3 = vec4(0.0, 0.0, 0.0, 0.0);
    vs_TEXCOORD4.w = 0.0;
    u_xlat2.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat22 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat22 = inversesqrt(u_xlat22);
    u_xlat2.xyz = vec3(u_xlat22) * u_xlat2.xyz;
    vs_TEXCOORD4.xyz = u_xlat2.xyz;
    u_xlat22 = u_xlat2.y * u_xlat2.y;
    u_xlat22 = u_xlat2.x * u_xlat2.x + (-u_xlat22);
    u_xlat3 = u_xlat2.yzzx * u_xlat2.xyzz;
    u_xlat4.x = dot(unity_SHBr, u_xlat3);
    u_xlat4.y = dot(unity_SHBg, u_xlat3);
    u_xlat4.z = dot(unity_SHBb, u_xlat3);
    u_xlat3.xyz = unity_SHC.xyz * vec3(u_xlat22) + u_xlat4.xyz;
    u_xlat2.w = 1.0;
    u_xlat4.x = dot(unity_SHAr, u_xlat2);
    u_xlat4.y = dot(unity_SHAg, u_xlat2);
    u_xlat4.z = dot(unity_SHAb, u_xlat2);
    u_xlat3.xyz = u_xlat3.xyz + u_xlat4.xyz;
    u_xlat3.xyz = max(u_xlat3.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat3.xyz = log2(u_xlat3.xyz);
    u_xlat3.xyz = u_xlat3.xyz * vec3(0.416666657, 0.416666657, 0.416666657);
    u_xlat3.xyz = exp2(u_xlat3.xyz);
    u_xlat3.xyz = u_xlat3.xyz * vec3(1.05499995, 1.05499995, 1.05499995) + vec3(-0.0549999997, -0.0549999997, -0.0549999997);
    u_xlat3.xyz = max(u_xlat3.xyz, vec3(0.0, 0.0, 0.0));
    u_xlat4 = (-u_xlat1.yyyy) + unity_4LightPosY0;
    u_xlat5 = u_xlat2.yyyy * u_xlat4;
    u_xlat4 = u_xlat4 * u_xlat4;
    u_xlat6 = (-u_xlat1.xxxx) + unity_4LightPosX0;
    u_xlat1 = (-u_xlat1.zzzz) + unity_4LightPosZ0;
    u_xlat5 = u_xlat6 * u_xlat2.xxxx + u_xlat5;
    u_xlat2 = u_xlat1 * u_xlat2.zzzz + u_xlat5;
    u_xlat4 = u_xlat6 * u_xlat6 + u_xlat4;
    u_xlat1 = u_xlat1 * u_xlat1 + u_xlat4;
    u_xlat1 = max(u_xlat1, vec4(9.99999997e-07, 9.99999997e-07, 9.99999997e-07, 9.99999997e-07));
    u_xlat4 = inversesqrt(u_xlat1);
    u_xlat1 = u_xlat1 * unity_4LightAtten0 + vec4(1.0, 1.0, 1.0, 1.0);
    u_xlat1 = vec4(1.0, 1.0, 1.0, 1.0) / u_xlat1;
    u_xlat2 = u_xlat2 * u_xlat4;
    u_xlat2 = max(u_xlat2, vec4(0.0, 0.0, 0.0, 0.0));
    u_xlat1 = u_xlat1 * u_xlat2;
    u_xlat2.xyz = u_xlat1.yyy * unity_LightColor[1].xyz;
    u_xlat2.xyz = unity_LightColor[0].xyz * u_xlat1.xxx + u_xlat2.xyz;
    u_xlat1.xyz = unity_LightColor[2].xyz * u_xlat1.zzz + u_xlat2.xyz;
    u_xlat1.xyz = unity_LightColor[3].xyz * u_xlat1.www + u_xlat1.xyz;
    vs_TEXCOORD5.xyz = u_xlat3.xyz + u_xlat1.xyz;
    vs_TEXCOORD5.w = 0.0;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_SpecCube0_HDR;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 _EmissionColor;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D _OcclusionMap;
uniform  sampler2D unity_NHxRoughness;
uniform  sampler2D _EmissionMap;
uniform  samplerCube unity_SpecCube0;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
lowp vec4 u_xlat10_4;
vec3 u_xlat5;
lowp vec4 u_xlat10_6;
vec3 u_xlat7;
mediump float u_xlat16_7;
float u_xlat8;
float u_xlat22;
void main()
{
    u_xlat0.xw = (-vec2(vec2(_Glossiness, _Glossiness))) + vec2(1.0, 1.0);
    u_xlat1.x = (-u_xlat0.x) * 0.699999988 + 1.70000005;
    u_xlat0.x = u_xlat0.x * u_xlat1.x;
    u_xlat0.x = u_xlat0.x * 6.0;
    u_xlat1.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat1.x = inversesqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * vs_TEXCOORD4.xyz;
    u_xlat22 = dot(vs_TEXCOORD1.xyz, u_xlat1.xyz);
    u_xlat22 = u_xlat22 + u_xlat22;
    u_xlat2.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + vs_TEXCOORD1.xyz;
    u_xlat10_2 = textureLod(unity_SpecCube0, u_xlat2.xyz, u_xlat0.x);
    u_xlatb0 = unity_SpecCube0_HDR.w==1.0;
    u_xlat0.x = (u_xlatb0) ? u_xlat10_2.w : 1.0;
    u_xlat0.x = u_xlat0.x * unity_SpecCube0_HDR.x;
    u_xlat2.xyz = u_xlat10_2.xyz * u_xlat0.xxx;
    u_xlat10_3 = texture(_OcclusionMap, vs_TEXCOORD0.xy);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat10_3.yyy;
    u_xlat3.xyz = u_xlat10_3.yyy * vs_TEXCOORD5.xyz;
    u_xlat0.x = dot((-vs_TEXCOORD1.xyz), u_xlat1.xyz);
    u_xlat22 = u_xlat0.x + u_xlat0.x;
    u_xlat0.x = u_xlat0.x;
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat4.y = (-u_xlat0.x) + 1.0;
    u_xlat5.xyz = u_xlat1.xyz * (-vec3(u_xlat22)) + (-vs_TEXCOORD1.xyz);
    u_xlat0.x = dot(u_xlat1.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat4.x = dot(u_xlat5.xyz, _WorldSpaceLightPos0.xyz);
    u_xlat1.xy = u_xlat4.xy * u_xlat4.xy;
    u_xlat0.yz = u_xlat1.xy * u_xlat1.xy;
    u_xlat1.x = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat8 = (-u_xlat1.x) + _Glossiness;
    u_xlat8 = u_xlat8 + 1.0;
    u_xlat8 = clamp(u_xlat8, 0.0, 1.0);
    u_xlat10_4 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat5.xyz = _Color.xyz * u_xlat10_4.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat4.xyz = u_xlat10_4.xyz * _Color.xyz;
    u_xlat1.xzw = u_xlat1.xxx * u_xlat4.xyz;
    u_xlat4.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat5.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat5.xyz = vec3(u_xlat8) + (-u_xlat4.xyz);
    u_xlat5.xyz = u_xlat0.zzz * u_xlat5.xyz + u_xlat4.xyz;
    u_xlat10_6 = texture(unity_NHxRoughness, u_xlat0.yw);
    u_xlat16_7 = u_xlat10_6.w * 16.0;
    u_xlat7.xyz = vec3(u_xlat16_7) * u_xlat4.xyz + u_xlat1.xzw;
    u_xlat2.xyz = u_xlat2.xyz * u_xlat5.xyz;
    u_xlat1.xyz = u_xlat3.xyz * u_xlat1.xzw + u_xlat2.xyz;
    u_xlat2.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_2 = texture(_ShadowMapTexture, u_xlat2.xy);
    u_xlat2.xyz = u_xlat10_2.xxx * _LightColor0.xyz;
    u_xlat2.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat0.xyz = u_xlat7.xyz * u_xlat2.xyz + u_xlat1.xyz;
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    SV_Target0.xyz = u_xlat10_1.xyz * _EmissionColor.xyz + u_xlat0.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "metal":
// No shader variant for this keyword set. The closest match will be used instead.

 }
 Pass {
  Name "FORWARD_DELTA"
  Tags { "LIGHTMODE"="ForwardAdd" "SHADOWSUPPORT"="true" "RenderType"="Opaque" "PerformanceChecks"="False" }
  ZWrite Off
  Blend [_SrcBlend] One
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
Keywords set in this variant: POINT 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (336 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Matrix4x4 unity_WorldToLight at 272
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    float u_xlat6;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat0.xyw = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    output.TEXCOORD5.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "unity_NHxRoughness" to slot 2

Constant Buffer "Globals" (20 bytes) on slot 0 {
  VectorHalf4 _LightColor0 at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (2) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    float u_xlat3;
    half u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_7;
    half u_xlat16_12;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_12 = dot((-input.TEXCOORD1.xyz), u_xlat16_0.xyz);
    u_xlat16_12 = half(u_xlat16_12 + u_xlat16_12);
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * (-half3(u_xlat16_12)) + (-input.TEXCOORD1.xyz));
    u_xlat16_2.x = input.TEXCOORD2.w;
    u_xlat16_2.y = input.TEXCOORD3.w;
    u_xlat16_2.z = input.TEXCOORD4.w;
    u_xlat16_12 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_4.x = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_1.x = half(u_xlat16_4.x * u_xlat16_4.x);
    u_xlat16_1.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_3 = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_1.xy)).w;
    u_xlat16_3 = half(float(u_xlat16_3) * 16.0);
    u_xlat16_7.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_4.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_7.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * Globals._Color.xyz);
    u_xlat16_4.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_4.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * half3(u_xlat16_3));
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_4.xyz = half3(u_xlat16_7.xyz * u_xlat16_1.xxx + u_xlat16_4.xyz);
    u_xlat3 = dot(input.TEXCOORD5.xyz, input.TEXCOORD5.xyz);
    u_xlat16_3 = _LightTexture0.sample(sampler_LightTexture0, float2(u_xlat3)).w;
    u_xlat16_1.xyz = half3(half3(u_xlat16_3) * Globals._LightColor0.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_0.xxx * u_xlat16_1.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat1.xyz;
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    vs_TEXCOORD5.xyz = hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D unity_NHxRoughness;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
vec3 u_xlat3;
mediump float u_xlat16_3;
float u_xlat9;
float u_xlat10;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat9 = dot((-vs_TEXCOORD1.xyz), u_xlat0.xyz);
    u_xlat9 = u_xlat9 + u_xlat9;
    u_xlat1.xyz = u_xlat0.xyz * (-vec3(u_xlat9)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat9 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat3.x = u_xlat9 * u_xlat9;
    u_xlat1.x = u_xlat3.x * u_xlat3.x;
    u_xlat1.y = (-_Glossiness) + 1.0;
    u_xlat10_1 = texture(unity_NHxRoughness, u_xlat1.xy);
    u_xlat16_3 = u_xlat10_1.w * 16.0;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat2.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat2.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat3.xyz = vec3(u_xlat16_3) * u_xlat2.xyz;
    u_xlat10 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat3.xyz = u_xlat1.xyz * vec3(u_xlat10) + u_xlat3.xyz;
    u_xlat1.x = dot(vs_TEXCOORD5.xyz, vs_TEXCOORD5.xyz);
    u_xlat10_1 = texture(_LightTexture0, u_xlat1.xx);
    u_xlat1.xyz = u_xlat10_1.www * _LightColor0.xyz;
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    SV_Target0.xyz = u_xlat3.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (258 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat0.xyw = (-u_xlat0.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat1.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "unity_NHxRoughness" to slot 1

Constant Buffer "Globals" (20 bytes) on slot 0 {
  VectorHalf4 _LightColor0 at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (1) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (1) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half u_xlat16_3;
    half3 u_xlat16_7;
    half u_xlat16_12;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_12 = dot((-input.TEXCOORD1.xyz), u_xlat16_0.xyz);
    u_xlat16_12 = half(u_xlat16_12 + u_xlat16_12);
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * (-half3(u_xlat16_12)) + (-input.TEXCOORD1.xyz));
    u_xlat16_2.x = input.TEXCOORD2.w;
    u_xlat16_2.y = input.TEXCOORD3.w;
    u_xlat16_2.z = input.TEXCOORD4.w;
    u_xlat16_12 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * Globals._LightColor0.xyz);
    u_xlat16_12 = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_1.x = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_1.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_3 = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_1.xy)).w;
    u_xlat16_3 = half(float(u_xlat16_3) * 16.0);
    u_xlat16_7.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_1.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_7.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * Globals._Color.xyz);
    u_xlat16_1.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_1.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_1.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_3));
    u_xlat16_12 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_1.xyz = half3(u_xlat16_7.xyz * half3(u_xlat16_12) + u_xlat16_1.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_0.xyz * u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
float u_xlat6;
float u_xlat7;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = inversesqrt(u_xlat7);
    vs_TEXCOORD1.xyz = vec3(u_xlat7) * u_xlat1.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D unity_NHxRoughness;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
float u_xlat9;
mediump float u_xlat16_9;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat9 = dot((-vs_TEXCOORD1.xyz), u_xlat0.xyz);
    u_xlat9 = u_xlat9 + u_xlat9;
    u_xlat1.xyz = u_xlat0.xyz * (-vec3(u_xlat9)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat9 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat0.xyz = u_xlat0.xxx * _LightColor0.xyz;
    u_xlat9 = u_xlat9 * u_xlat9;
    u_xlat1.x = u_xlat9 * u_xlat9;
    u_xlat1.y = (-_Glossiness) + 1.0;
    u_xlat10_1 = texture(unity_NHxRoughness, u_xlat1.xy);
    u_xlat16_9 = u_xlat10_1.w * 16.0;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat2.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat2.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat2.xyz = vec3(u_xlat16_9) * u_xlat2.xyz;
    u_xlat9 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat1.xyz = u_xlat1.xyz * vec3(u_xlat9) + u_xlat2.xyz;
    SV_Target0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (336 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Matrix4x4 unity_WorldToLight at 272
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat0.xyw = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToLight[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToLight[2] * u_xlat0.zzzz + u_xlat1;
    output.TEXCOORD5 = Globals.hlslcc_mtx4x4unity_WorldToLight[3] * u_xlat0.wwww + u_xlat1;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "_LightTextureB0" to slot 2
Set 2D Texture "unity_NHxRoughness" to slot 3

Constant Buffer "Globals" (20 bytes) on slot 0 {
  VectorHalf4 _LightColor0 at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (2) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (2) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (3) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    float2 u_xlat3;
    half u_xlat16_3;
    half u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_8;
    bool u_xlatb8;
    half u_xlat16_15;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_15 = dot((-input.TEXCOORD1.xyz), u_xlat16_0.xyz);
    u_xlat16_15 = half(u_xlat16_15 + u_xlat16_15);
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * (-half3(u_xlat16_15)) + (-input.TEXCOORD1.xyz));
    u_xlat16_2.x = input.TEXCOORD2.w;
    u_xlat16_2.y = input.TEXCOORD3.w;
    u_xlat16_2.z = input.TEXCOORD4.w;
    u_xlat16_15 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_5.x = half(u_xlat16_15 * u_xlat16_15);
    u_xlat16_1.x = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_1.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_3 = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_1.xy)).w;
    u_xlat16_3 = half(float(u_xlat16_3) * 16.0);
    u_xlat16_8.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_5.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_8.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * Globals._Color.xyz);
    u_xlat16_5.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_5.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_5.xyz = half3(u_xlat16_5.xyz * half3(u_xlat16_3));
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_5.xyz = half3(u_xlat16_8.xyz * u_xlat16_1.xxx + u_xlat16_5.xyz);
    u_xlat3.xy = input.TEXCOORD5.xy / input.TEXCOORD5.ww;
    u_xlat3.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat16_3 = _LightTexture0.sample(sampler_LightTexture0, u_xlat3.xy).w;
    u_xlatb8 = 0.0<input.TEXCOORD5.z;
    u_xlat16_4 = (u_xlatb8) ? 1.0 : 0.0;
    u_xlat16_4 = half(u_xlat16_3 * u_xlat16_4);
    u_xlat3.x = dot(input.TEXCOORD5.xyz, input.TEXCOORD5.xyz);
    u_xlat16_3 = _LightTextureB0.sample(sampler_LightTextureB0, u_xlat3.xx).w;
    u_xlat16_4 = half(u_xlat16_3 * u_xlat16_4);
    u_xlat16_1.xyz = half3(half3(u_xlat16_4) * Globals._LightColor0.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_0.xxx * u_xlat16_1.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_5.xyz * u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat1.xyz;
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat1 = hlslcc_mtx4x4unity_WorldToLight[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_WorldToLight[2] * u_xlat0.zzzz + u_xlat1;
    vs_TEXCOORD5 = hlslcc_mtx4x4unity_WorldToLight[3] * u_xlat0.wwww + u_xlat1;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D _LightTextureB0;
uniform  sampler2D unity_NHxRoughness;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
bool u_xlatb1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
mediump float u_xlat16_3;
float u_xlat4;
float u_xlat9;
float u_xlat10;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat9 = dot((-vs_TEXCOORD1.xyz), u_xlat0.xyz);
    u_xlat9 = u_xlat9 + u_xlat9;
    u_xlat1.xyz = u_xlat0.xyz * (-vec3(u_xlat9)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat9 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat3.x = u_xlat9 * u_xlat9;
    u_xlat1.x = u_xlat3.x * u_xlat3.x;
    u_xlat1.y = (-_Glossiness) + 1.0;
    u_xlat10_1 = texture(unity_NHxRoughness, u_xlat1.xy);
    u_xlat16_3 = u_xlat10_1.w * 16.0;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat2.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat2.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat3.xyz = vec3(u_xlat16_3) * u_xlat2.xyz;
    u_xlat10 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat3.xyz = u_xlat1.xyz * vec3(u_xlat10) + u_xlat3.xyz;
    u_xlat1.xy = vs_TEXCOORD5.xy / vs_TEXCOORD5.ww;
    u_xlat1.xy = u_xlat1.xy + vec2(0.5, 0.5);
    u_xlat10_1 = texture(_LightTexture0, u_xlat1.xy);
    u_xlatb1 = 0.0<vs_TEXCOORD5.z;
    u_xlat1.x = u_xlatb1 ? 1.0 : float(0.0);
    u_xlat1.x = u_xlat10_1.w * u_xlat1.x;
    u_xlat4 = dot(vs_TEXCOORD5.xyz, vs_TEXCOORD5.xyz);
    u_xlat10_2 = texture(_LightTextureB0, vec2(u_xlat4));
    u_xlat1.x = u_xlat1.x * u_xlat10_2.w;
    u_xlat1.xyz = u_xlat1.xxx * _LightColor0.xyz;
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    SV_Target0.xyz = u_xlat3.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: POINT_COOKIE 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (336 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Matrix4x4 unity_WorldToLight at 272
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    float u_xlat6;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat0.xyw = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    output.TEXCOORD5.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTextureB0" to slot 1
Set CUBE Texture "_LightTexture0" to slot 2
Set 2D Texture "unity_NHxRoughness" to slot 3

Constant Buffer "Globals" (20 bytes) on slot 0 {
  VectorHalf4 _LightColor0 at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (1) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (1) ]] ,
    texturecube<half, access::sample > _LightTexture0 [[ texture (2) ]] ,
    sampler sampler_LightTexture0 [[ sampler (2) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (3) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    float u_xlat3;
    half u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_7;
    half u_xlat16_12;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_12 = dot((-input.TEXCOORD1.xyz), u_xlat16_0.xyz);
    u_xlat16_12 = half(u_xlat16_12 + u_xlat16_12);
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * (-half3(u_xlat16_12)) + (-input.TEXCOORD1.xyz));
    u_xlat16_2.x = input.TEXCOORD2.w;
    u_xlat16_2.y = input.TEXCOORD3.w;
    u_xlat16_2.z = input.TEXCOORD4.w;
    u_xlat16_12 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_4.x = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_1.x = half(u_xlat16_4.x * u_xlat16_4.x);
    u_xlat16_1.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_3 = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_1.xy)).w;
    u_xlat16_3 = half(float(u_xlat16_3) * 16.0);
    u_xlat16_7.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_4.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_7.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * Globals._Color.xyz);
    u_xlat16_4.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_4.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * half3(u_xlat16_3));
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_4.xyz = half3(u_xlat16_7.xyz * u_xlat16_1.xxx + u_xlat16_4.xyz);
    u_xlat3 = dot(input.TEXCOORD5.xyz, input.TEXCOORD5.xyz);
    u_xlat16_3 = _LightTextureB0.sample(sampler_LightTextureB0, float2(u_xlat3)).w;
    u_xlat16_7.x = _LightTexture0.sample(sampler_LightTexture0, input.TEXCOORD5.xyz).w;
    u_xlat16_3 = half(u_xlat16_7.x * u_xlat16_3);
    u_xlat16_1.xyz = half3(half3(u_xlat16_3) * Globals._LightColor0.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_0.xxx * u_xlat16_1.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat1.xyz;
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    vs_TEXCOORD5.xyz = hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTextureB0;
uniform  samplerCube _LightTexture0;
uniform  sampler2D unity_NHxRoughness;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
mediump float u_xlat16_1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
mediump float u_xlat16_3;
float u_xlat9;
float u_xlat10;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat9 = dot((-vs_TEXCOORD1.xyz), u_xlat0.xyz);
    u_xlat9 = u_xlat9 + u_xlat9;
    u_xlat1.xyz = u_xlat0.xyz * (-vec3(u_xlat9)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat9 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat3.x = u_xlat9 * u_xlat9;
    u_xlat1.x = u_xlat3.x * u_xlat3.x;
    u_xlat1.y = (-_Glossiness) + 1.0;
    u_xlat10_1 = texture(unity_NHxRoughness, u_xlat1.xy);
    u_xlat16_3 = u_xlat10_1.w * 16.0;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat2.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat2.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat3.xyz = vec3(u_xlat16_3) * u_xlat2.xyz;
    u_xlat10 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat3.xyz = u_xlat1.xyz * vec3(u_xlat10) + u_xlat3.xyz;
    u_xlat1.x = dot(vs_TEXCOORD5.xyz, vs_TEXCOORD5.xyz);
    u_xlat10_1 = texture(_LightTextureB0, u_xlat1.xx);
    u_xlat10_2 = texture(_LightTexture0, vs_TEXCOORD5.xyz);
    u_xlat16_1 = u_xlat10_1.w * u_xlat10_2.w;
    u_xlat1.xyz = vec3(u_xlat16_1) * _LightColor0.xyz;
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    SV_Target0.xyz = u_xlat3.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (336 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Matrix4x4 unity_WorldToLight at 272
  Vector3 _WorldSpaceCameraPos at 0
  VectorHalf4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 224
  Vector4 _DetailAlbedoMap_ST at 240
  ScalarHalf _UVSec at 256
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float2 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat0.xyw = (-u_xlat0.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat1.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1.xy = u_xlat0.yy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat0.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xy * u_xlat0.xx + u_xlat1.xy;
    u_xlat0.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xy * u_xlat0.zz + u_xlat0.xy;
    output.TEXCOORD5.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[3].xy * u_xlat0.ww + u_xlat0.xy;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "unity_NHxRoughness" to slot 2

Constant Buffer "Globals" (20 bytes) on slot 0 {
  VectorHalf4 _LightColor0 at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float2 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (2) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_7;
    half u_xlat16_12;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_12 = dot((-input.TEXCOORD1.xyz), u_xlat16_0.xyz);
    u_xlat16_12 = half(u_xlat16_12 + u_xlat16_12);
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * (-half3(u_xlat16_12)) + (-input.TEXCOORD1.xyz));
    u_xlat16_2.x = input.TEXCOORD2.w;
    u_xlat16_2.y = input.TEXCOORD3.w;
    u_xlat16_2.z = input.TEXCOORD4.w;
    u_xlat16_12 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_4.x = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_1.x = half(u_xlat16_4.x * u_xlat16_4.x);
    u_xlat16_1.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_3 = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_1.xy)).w;
    u_xlat16_3 = half(float(u_xlat16_3) * 16.0);
    u_xlat16_7.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_4.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_7.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * Globals._Color.xyz);
    u_xlat16_4.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_4.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * half3(u_xlat16_3));
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_4.xyz = half3(u_xlat16_7.xyz * u_xlat16_1.xxx + u_xlat16_4.xyz);
    u_xlat16_3 = _LightTexture0.sample(sampler_LightTexture0, input.TEXCOORD5.xy).w;
    u_xlat16_1.xyz = half3(half3(u_xlat16_3) * Globals._LightColor0.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_0.xxx * u_xlat16_1.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec2 vs_TEXCOORD5;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
float u_xlat6;
float u_xlat7;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = inversesqrt(u_xlat7);
    vs_TEXCOORD1.xyz = vec3(u_xlat7) * u_xlat1.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1.xy = u_xlat0.yy * hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat0.xy = hlslcc_mtx4x4unity_WorldToLight[0].xy * u_xlat0.xx + u_xlat1.xy;
    u_xlat0.xy = hlslcc_mtx4x4unity_WorldToLight[2].xy * u_xlat0.zz + u_xlat0.xy;
    vs_TEXCOORD5.xy = hlslcc_mtx4x4unity_WorldToLight[3].xy * u_xlat0.ww + u_xlat0.xy;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D unity_NHxRoughness;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec2 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
vec3 u_xlat3;
mediump float u_xlat16_3;
float u_xlat9;
float u_xlat10;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat9 = dot((-vs_TEXCOORD1.xyz), u_xlat0.xyz);
    u_xlat9 = u_xlat9 + u_xlat9;
    u_xlat1.xyz = u_xlat0.xyz * (-vec3(u_xlat9)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat9 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat3.x = u_xlat9 * u_xlat9;
    u_xlat1.x = u_xlat3.x * u_xlat3.x;
    u_xlat1.y = (-_Glossiness) + 1.0;
    u_xlat10_1 = texture(unity_NHxRoughness, u_xlat1.xy);
    u_xlat16_3 = u_xlat10_1.w * 16.0;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat2.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat2.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat3.xyz = vec3(u_xlat16_3) * u_xlat2.xyz;
    u_xlat10 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat3.xyz = u_xlat1.xyz * vec3(u_xlat10) + u_xlat3.xyz;
    u_xlat10_1 = texture(_LightTexture0, vs_TEXCOORD5.xy);
    u_xlat1.xyz = u_xlat10_1.www * _LightColor0.xyz;
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    SV_Target0.xyz = u_xlat3.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: SPOT SHADOWS_DEPTH 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (592 bytes) on slot 0 {
  Matrix4x4 unity_WorldToShadow[4] at 32
  Matrix4x4 glstate_matrix_mvp at 288
  Matrix4x4 unity_ObjectToWorld at 352
  Matrix4x4 unity_WorldToObject at 416
  Matrix4x4 unity_WorldToLight at 528
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _MainTex_ST at 480
  Vector4 _DetailAlbedoMap_ST at 496
  ScalarHalf _UVSec at 512
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    float u_xlat6;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat0.xyw = float3(u_xlat6) * u_xlat0.xyz;
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToLight[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToLight[2] * u_xlat0.zzzz + u_xlat1;
    output.TEXCOORD5 = Globals.hlslcc_mtx4x4unity_WorldToLight[3] * u_xlat0.wwww + u_xlat1;
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_WorldToShadow[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToShadow[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_WorldToShadow[2] * u_xlat0.zzzz + u_xlat1;
    output.TEXCOORD6 = Globals.hlslcc_mtx4x4unity_WorldToShadow[3] * u_xlat0.wwww + u_xlat1;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "_LightTextureB0" to slot 2
Set 2D Texture "unity_NHxRoughness" to slot 3
Set 2D Texture "_ShadowMapTexture" to slot 4

Constant Buffer "Globals" (28 bytes) on slot 0 {
  VectorHalf4 _LightShadowData at 0
  VectorHalf4 _LightColor0 at 8
  VectorHalf4 _Color at 16
  ScalarHalf _Metallic at 24
  ScalarHalf _Glossiness at 26
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightShadowData;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

constexpr sampler _mtl_xl_shadow_sampler(address::clamp_to_edge, filter::linear, compare_func::greater_equal);
fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (2) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (2) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (3) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (3) ]] ,
    depth2d<float, access::sample > _ShadowMapTexture [[ texture (4) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    float3 u_xlat3;
    half u_xlat16_3;
    half u_xlat10_3;
    half u_xlat16_4;
    half3 u_xlat16_5;
    half3 u_xlat16_8;
    bool u_xlatb8;
    half u_xlat16_15;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_15 = dot((-input.TEXCOORD1.xyz), u_xlat16_0.xyz);
    u_xlat16_15 = half(u_xlat16_15 + u_xlat16_15);
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * (-half3(u_xlat16_15)) + (-input.TEXCOORD1.xyz));
    u_xlat16_2.x = input.TEXCOORD2.w;
    u_xlat16_2.y = input.TEXCOORD3.w;
    u_xlat16_2.z = input.TEXCOORD4.w;
    u_xlat16_15 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_5.x = half(u_xlat16_15 * u_xlat16_15);
    u_xlat16_1.x = half(u_xlat16_5.x * u_xlat16_5.x);
    u_xlat16_1.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_3 = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_1.xy)).w;
    u_xlat16_3 = half(float(u_xlat16_3) * 16.0);
    u_xlat16_8.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_5.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_8.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_8.xyz = half3(u_xlat16_8.xyz * Globals._Color.xyz);
    u_xlat16_5.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_5.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_5.xyz = half3(u_xlat16_5.xyz * half3(u_xlat16_3));
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_5.xyz = half3(u_xlat16_8.xyz * u_xlat16_1.xxx + u_xlat16_5.xyz);
    u_xlat3.xy = input.TEXCOORD5.xy / input.TEXCOORD5.ww;
    u_xlat3.xy = u_xlat3.xy + float2(0.5, 0.5);
    u_xlat16_3 = _LightTexture0.sample(sampler_LightTexture0, u_xlat3.xy).w;
    u_xlatb8 = 0.0<input.TEXCOORD5.z;
    u_xlat16_4 = (u_xlatb8) ? 1.0 : 0.0;
    u_xlat16_4 = half(u_xlat16_3 * u_xlat16_4);
    u_xlat3.x = dot(input.TEXCOORD5.xyz, input.TEXCOORD5.xyz);
    u_xlat16_3 = _LightTextureB0.sample(sampler_LightTextureB0, u_xlat3.xx).w;
    u_xlat16_4 = half(u_xlat16_3 * u_xlat16_4);
    u_xlat3.xyz = input.TEXCOORD6.xyz / input.TEXCOORD6.www;
    u_xlat10_3 = half(_ShadowMapTexture.sample_compare(_mtl_xl_shadow_sampler, u_xlat3.xy, saturate(u_xlat3.z), level(0.0)));
    u_xlat16_1.x = half((-float(Globals._LightShadowData.x)) + 1.0);
    u_xlat16_1.x = half(float(u_xlat10_3) * float(u_xlat16_1.x) + float(Globals._LightShadowData.x));
    u_xlat16_4 = half(u_xlat16_1.x * u_xlat16_4);
    u_xlat16_1.xyz = half3(half3(u_xlat16_4) * Globals._LightColor0.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_0.xxx * u_xlat16_1.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_5.xyz * u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToShadow[16];
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat0.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat1.xyz;
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_WorldToLight[1];
    u_xlat1 = hlslcc_mtx4x4unity_WorldToLight[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_WorldToLight[2] * u_xlat0.zzzz + u_xlat1;
    vs_TEXCOORD5 = hlslcc_mtx4x4unity_WorldToLight[3] * u_xlat0.wwww + u_xlat1;
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_WorldToShadow[1];
    u_xlat1 = hlslcc_mtx4x4unity_WorldToShadow[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_WorldToShadow[2] * u_xlat0.zzzz + u_xlat1;
    vs_TEXCOORD6 = hlslcc_mtx4x4unity_WorldToShadow[3] * u_xlat0.wwww + u_xlat1;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightShadowData;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D _LightTextureB0;
uniform  sampler2D unity_NHxRoughness;
uniform  sampler2DShadow hlslcc_zcmp_ShadowMapTexture;
uniform  sampler2D _ShadowMapTexture;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
bool u_xlatb1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
mediump float u_xlat16_3;
vec3 u_xlat4;
lowp float u_xlat10_4;
float u_xlat7;
float u_xlat9;
float u_xlat10;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat9 = dot((-vs_TEXCOORD1.xyz), u_xlat0.xyz);
    u_xlat9 = u_xlat9 + u_xlat9;
    u_xlat1.xyz = u_xlat0.xyz * (-vec3(u_xlat9)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat9 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat3.x = u_xlat9 * u_xlat9;
    u_xlat1.x = u_xlat3.x * u_xlat3.x;
    u_xlat1.y = (-_Glossiness) + 1.0;
    u_xlat10_1 = texture(unity_NHxRoughness, u_xlat1.xy);
    u_xlat16_3 = u_xlat10_1.w * 16.0;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat2.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat2.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat3.xyz = vec3(u_xlat16_3) * u_xlat2.xyz;
    u_xlat10 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat3.xyz = u_xlat1.xyz * vec3(u_xlat10) + u_xlat3.xyz;
    u_xlat1.xy = vs_TEXCOORD5.xy / vs_TEXCOORD5.ww;
    u_xlat1.xy = u_xlat1.xy + vec2(0.5, 0.5);
    u_xlat10_1 = texture(_LightTexture0, u_xlat1.xy);
    u_xlatb1 = 0.0<vs_TEXCOORD5.z;
    u_xlat1.x = u_xlatb1 ? 1.0 : float(0.0);
    u_xlat1.x = u_xlat10_1.w * u_xlat1.x;
    u_xlat4.x = dot(vs_TEXCOORD5.xyz, vs_TEXCOORD5.xyz);
    u_xlat10_2 = texture(_LightTextureB0, u_xlat4.xx);
    u_xlat1.x = u_xlat1.x * u_xlat10_2.w;
    u_xlat4.xyz = vs_TEXCOORD6.xyz / vs_TEXCOORD6.www;
    vec3 txVec0 = vec3(u_xlat4.xy,u_xlat4.z);
    u_xlat10_4 = textureLod(hlslcc_zcmp_ShadowMapTexture, txVec0, 0.0);
    u_xlat7 = (-_LightShadowData.x) + 1.0;
    u_xlat4.x = u_xlat10_4 * u_xlat7 + _LightShadowData.x;
    u_xlat1.x = u_xlat4.x * u_xlat1.x;
    u_xlat1.xyz = u_xlat1.xxx * _LightColor0.xyz;
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    SV_Target0.xyz = u_xlat3.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL SHADOWS_SCREEN 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (274 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 _WorldSpaceLightPos0 at 32
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float3 u_xlat2;
    float u_xlat11;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.xyw = (-u_xlat1.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    u_xlat11 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat11 = rsqrt(u_xlat11);
    u_xlat2.xyz = float3(u_xlat11) * u_xlat2.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat11 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat11 = rsqrt(u_xlat11);
    u_xlat1.xyz = float3(u_xlat11) * u_xlat2.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD5.zw = u_xlat0.zw;
    output.TEXCOORD5.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_ShadowMapTexture" to slot 1
Set 2D Texture "unity_NHxRoughness" to slot 2

Constant Buffer "Globals" (20 bytes) on slot 0 {
  VectorHalf4 _LightColor0 at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (1) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (1) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (2) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (2) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    float2 u_xlat3;
    half u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_7;
    half u_xlat16_12;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_12 = dot((-input.TEXCOORD1.xyz), u_xlat16_0.xyz);
    u_xlat16_12 = half(u_xlat16_12 + u_xlat16_12);
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * (-half3(u_xlat16_12)) + (-input.TEXCOORD1.xyz));
    u_xlat16_2.x = input.TEXCOORD2.w;
    u_xlat16_2.y = input.TEXCOORD3.w;
    u_xlat16_2.z = input.TEXCOORD4.w;
    u_xlat16_12 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_4.x = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_1.x = half(u_xlat16_4.x * u_xlat16_4.x);
    u_xlat16_1.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_3 = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_1.xy)).w;
    u_xlat16_3 = half(float(u_xlat16_3) * 16.0);
    u_xlat16_7.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_4.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_7.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * Globals._Color.xyz);
    u_xlat16_4.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_4.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * half3(u_xlat16_3));
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_4.xyz = half3(u_xlat16_7.xyz * u_xlat16_1.xxx + u_xlat16_4.xyz);
    u_xlat3.xy = input.TEXCOORD5.xy / input.TEXCOORD5.ww;
    u_xlat16_3 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat3.xy).x;
    u_xlat16_1.xyz = half3(half3(u_xlat16_3) * Globals._LightColor0.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_0.xxx * u_xlat16_1.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec4 vs_TEXCOORD5;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec3 u_xlat2;
float u_xlat10;
float u_xlat11;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat11 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat11 = inversesqrt(u_xlat11);
    vs_TEXCOORD1.xyz = vec3(u_xlat11) * u_xlat2.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = inversesqrt(u_xlat10);
    vs_TEXCOORD4.xyz = vec3(u_xlat10) * u_xlat1.xyz;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD5.zw = u_xlat0.zw;
    vs_TEXCOORD5.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D unity_NHxRoughness;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec4 vs_TEXCOORD5;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
vec3 u_xlat3;
mediump float u_xlat16_3;
float u_xlat9;
float u_xlat10;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat9 = dot((-vs_TEXCOORD1.xyz), u_xlat0.xyz);
    u_xlat9 = u_xlat9 + u_xlat9;
    u_xlat1.xyz = u_xlat0.xyz * (-vec3(u_xlat9)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat9 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat3.x = u_xlat9 * u_xlat9;
    u_xlat1.x = u_xlat3.x * u_xlat3.x;
    u_xlat1.y = (-_Glossiness) + 1.0;
    u_xlat10_1 = texture(unity_NHxRoughness, u_xlat1.xy);
    u_xlat16_3 = u_xlat10_1.w * 16.0;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat2.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat2.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat3.xyz = vec3(u_xlat16_3) * u_xlat2.xyz;
    u_xlat10 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat3.xyz = u_xlat1.xyz * vec3(u_xlat10) + u_xlat3.xyz;
    u_xlat1.xy = vs_TEXCOORD5.xy / vs_TEXCOORD5.ww;
    u_xlat10_1 = texture(_ShadowMapTexture, u_xlat1.xy);
    u_xlat1.xyz = u_xlat10_1.xxx * _LightColor0.xyz;
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    SV_Target0.xyz = u_xlat3.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: DIRECTIONAL_COOKIE SHADOWS_SCREEN 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (352 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Matrix4x4 unity_WorldToLight at 288
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _ProjectionParams at 16
  VectorHalf4 _WorldSpaceLightPos0 at 32
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    half4 _WorldSpaceLightPos0;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float2 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    bool u_xlatb1;
    float3 u_xlat2;
    float u_xlat11;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    output.mtl_Position = u_xlat0;
    u_xlatb1 = Globals._UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat1.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat1.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat1.xyw = (-u_xlat1.xyz) * float3(Globals._WorldSpaceLightPos0.www) + float3(Globals._WorldSpaceLightPos0.xyz);
    u_xlat11 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat11 = rsqrt(u_xlat11);
    u_xlat2.xyz = float3(u_xlat11) * u_xlat2.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat2.xyz);
    output.TEXCOORD2.w = half(u_xlat1.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat1.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat2.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat11 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat11 = rsqrt(u_xlat11);
    u_xlat1.xyz = float3(u_xlat11) * u_xlat2.xyz;
    output.TEXCOORD4 = half4(u_xlat1);
    u_xlat1 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat1;
    u_xlat2.xy = u_xlat1.yy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat1.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xy * u_xlat1.xx + u_xlat2.xy;
    u_xlat1.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xy * u_xlat1.zz + u_xlat1.xy;
    output.TEXCOORD5.xy = Globals.hlslcc_mtx4x4unity_WorldToLight[3].xy * u_xlat1.ww + u_xlat1.xy;
    u_xlat0.y = u_xlat0.y * Globals._ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * float3(0.5, 0.5, 0.5);
    output.TEXCOORD6.zw = u_xlat0.zw;
    output.TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set 2D Texture "_ShadowMapTexture" to slot 2
Set 2D Texture "unity_NHxRoughness" to slot 3

Constant Buffer "Globals" (20 bytes) on slot 0 {
  VectorHalf4 _LightColor0 at 0
  VectorHalf4 _Color at 8
  ScalarHalf _Metallic at 16
  ScalarHalf _Glossiness at 18
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float2 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texture2d<half, access::sample > _ShadowMapTexture [[ texture (2) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (2) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (3) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    float2 u_xlat3;
    half u_xlat16_3;
    half3 u_xlat16_4;
    half3 u_xlat16_7;
    half u_xlat16_12;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_12 = dot((-input.TEXCOORD1.xyz), u_xlat16_0.xyz);
    u_xlat16_12 = half(u_xlat16_12 + u_xlat16_12);
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * (-half3(u_xlat16_12)) + (-input.TEXCOORD1.xyz));
    u_xlat16_2.x = input.TEXCOORD2.w;
    u_xlat16_2.y = input.TEXCOORD3.w;
    u_xlat16_2.z = input.TEXCOORD4.w;
    u_xlat16_12 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_4.x = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_1.x = half(u_xlat16_4.x * u_xlat16_4.x);
    u_xlat16_1.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_3 = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_1.xy)).w;
    u_xlat16_3 = half(float(u_xlat16_3) * 16.0);
    u_xlat16_7.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_4.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_7.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * Globals._Color.xyz);
    u_xlat16_4.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_4.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * half3(u_xlat16_3));
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_4.xyz = half3(u_xlat16_7.xyz * u_xlat16_1.xxx + u_xlat16_4.xyz);
    u_xlat3.xy = input.TEXCOORD6.xy / input.TEXCOORD6.ww;
    u_xlat16_3 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, u_xlat3.xy).x;
    u_xlat16_7.x = _LightTexture0.sample(sampler_LightTexture0, input.TEXCOORD5.xy).w;
    u_xlat16_3 = half(u_xlat16_3 * u_xlat16_7.x);
    u_xlat16_1.xyz = half3(half3(u_xlat16_3) * Globals._LightColor0.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_0.xxx * u_xlat16_1.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _ProjectionParams;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec2 vs_TEXCOORD5;
out vec4 vs_TEXCOORD6;
vec4 u_xlat0;
vec4 u_xlat1;
bool u_xlatb1;
vec3 u_xlat2;
float u_xlat10;
float u_xlat11;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    gl_Position = u_xlat0;
    u_xlatb1 = _UVSec==0.0;
    u_xlat1.xy = (bool(u_xlatb1)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat1.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat1.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat1.xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat1.xyz;
    u_xlat2.xyz = u_xlat1.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat1.xyz = (-u_xlat1.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat11 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat11 = inversesqrt(u_xlat11);
    vs_TEXCOORD1.xyz = vec3(u_xlat11) * u_xlat2.xyz;
    u_xlat1.w = 0.0;
    vs_TEXCOORD2 = u_xlat1.wwwx;
    vs_TEXCOORD3 = u_xlat1.wwwy;
    vs_TEXCOORD4.w = u_xlat1.z;
    u_xlat1.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat10 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat10 = inversesqrt(u_xlat10);
    vs_TEXCOORD4.xyz = vec3(u_xlat10) * u_xlat1.xyz;
    u_xlat1 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat1;
    u_xlat2.xy = u_xlat1.yy * hlslcc_mtx4x4unity_WorldToLight[1].xy;
    u_xlat1.xy = hlslcc_mtx4x4unity_WorldToLight[0].xy * u_xlat1.xx + u_xlat2.xy;
    u_xlat1.xy = hlslcc_mtx4x4unity_WorldToLight[2].xy * u_xlat1.zz + u_xlat1.xy;
    vs_TEXCOORD5.xy = hlslcc_mtx4x4unity_WorldToLight[3].xy * u_xlat1.ww + u_xlat1.xy;
    u_xlat0.y = u_xlat0.y * _ProjectionParams.x;
    u_xlat1.xzw = u_xlat0.xwy * vec3(0.5, 0.5, 0.5);
    vs_TEXCOORD6.zw = u_xlat0.zw;
    vs_TEXCOORD6.xy = u_xlat1.zz + u_xlat1.xw;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  sampler2D _ShadowMapTexture;
uniform  sampler2D unity_NHxRoughness;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec2 vs_TEXCOORD5;
in  vec4 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
mediump float u_xlat16_1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
mediump float u_xlat16_3;
float u_xlat9;
float u_xlat10;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat9 = dot((-vs_TEXCOORD1.xyz), u_xlat0.xyz);
    u_xlat9 = u_xlat9 + u_xlat9;
    u_xlat1.xyz = u_xlat0.xyz * (-vec3(u_xlat9)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat9 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat3.x = u_xlat9 * u_xlat9;
    u_xlat1.x = u_xlat3.x * u_xlat3.x;
    u_xlat1.y = (-_Glossiness) + 1.0;
    u_xlat10_1 = texture(unity_NHxRoughness, u_xlat1.xy);
    u_xlat16_3 = u_xlat10_1.w * 16.0;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat2.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat2.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat3.xyz = vec3(u_xlat16_3) * u_xlat2.xyz;
    u_xlat10 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat3.xyz = u_xlat1.xyz * vec3(u_xlat10) + u_xlat3.xyz;
    u_xlat1.xy = vs_TEXCOORD6.xy / vs_TEXCOORD6.ww;
    u_xlat10_1 = texture(_ShadowMapTexture, u_xlat1.xy);
    u_xlat10_2 = texture(_LightTexture0, vs_TEXCOORD5.xy);
    u_xlat16_1 = u_xlat10_1.x * u_xlat10_2.w;
    u_xlat1.xyz = vec3(u_xlat16_1) * _LightColor0.xyz;
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    SV_Target0.xyz = u_xlat3.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: POINT SHADOWS_CUBE 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (352 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Matrix4x4 unity_WorldToLight at 288
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _LightPositionRange at 32
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    float u_xlat6;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD6.xyz = u_xlat0.xyz + (-Globals._LightPositionRange.xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyw = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    output.TEXCOORD5.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTexture0" to slot 1
Set CUBE Texture "_ShadowMapTexture" to slot 2
Set 2D Texture "unity_NHxRoughness" to slot 3

Constant Buffer "Globals" (44 bytes) on slot 0 {
  Vector4 _LightPositionRange at 0
  VectorHalf4 _LightShadowData at 16
  VectorHalf4 _LightColor0 at 24
  VectorHalf4 _Color at 32
  ScalarHalf _Metallic at 40
  ScalarHalf _Glossiness at 42
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    half4 _LightShadowData;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTexture0 [[ texture (1) ]] ,
    sampler sampler_LightTexture0 [[ sampler (1) ]] ,
    texturecube<float, access::sample > _ShadowMapTexture [[ texture (2) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (2) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (3) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (3) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    float u_xlat3;
    half u_xlat16_3;
    bool u_xlatb3;
    half3 u_xlat16_4;
    float u_xlat7;
    half3 u_xlat16_7;
    half u_xlat16_12;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_12 = dot((-input.TEXCOORD1.xyz), u_xlat16_0.xyz);
    u_xlat16_12 = half(u_xlat16_12 + u_xlat16_12);
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * (-half3(u_xlat16_12)) + (-input.TEXCOORD1.xyz));
    u_xlat16_2.x = input.TEXCOORD2.w;
    u_xlat16_2.y = input.TEXCOORD3.w;
    u_xlat16_2.z = input.TEXCOORD4.w;
    u_xlat16_12 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_4.x = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_1.x = half(u_xlat16_4.x * u_xlat16_4.x);
    u_xlat16_1.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_3 = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_1.xy)).w;
    u_xlat16_3 = half(float(u_xlat16_3) * 16.0);
    u_xlat16_7.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_4.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_7.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * Globals._Color.xyz);
    u_xlat16_4.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_4.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * half3(u_xlat16_3));
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_4.xyz = half3(u_xlat16_7.xyz * u_xlat16_1.xxx + u_xlat16_4.xyz);
    u_xlat3 = dot(input.TEXCOORD6.xyz, input.TEXCOORD6.xyz);
    u_xlat3 = sqrt(u_xlat3);
    u_xlat3 = u_xlat3 * Globals._LightPositionRange.w;
    u_xlat3 = u_xlat3 * 0.970000029;
    u_xlat7 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, input.TEXCOORD6.xyz).x;
    u_xlatb3 = u_xlat7<u_xlat3;
    u_xlat16_1.x = (u_xlatb3) ? Globals._LightShadowData.x : 1.0;
    u_xlat3 = dot(input.TEXCOORD5.xyz, input.TEXCOORD5.xyz);
    u_xlat16_3 = _LightTexture0.sample(sampler_LightTexture0, float2(u_xlat3)).w;
    u_xlat16_3 = half(u_xlat16_1.x * u_xlat16_3);
    u_xlat16_1.xyz = half3(half3(u_xlat16_3) * Globals._LightColor0.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_0.xxx * u_xlat16_1.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 _LightPositionRange;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat1.xyz;
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD6.xyz = u_xlat0.xyz + (-_LightPositionRange.xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    vs_TEXCOORD5.xyz = hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 _LightShadowData;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTexture0;
uniform  samplerCube _ShadowMapTexture;
uniform  sampler2D unity_NHxRoughness;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
bool u_xlatb1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
vec3 u_xlat3;
mediump float u_xlat16_3;
float u_xlat4;
float u_xlat9;
float u_xlat10;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat9 = dot((-vs_TEXCOORD1.xyz), u_xlat0.xyz);
    u_xlat9 = u_xlat9 + u_xlat9;
    u_xlat1.xyz = u_xlat0.xyz * (-vec3(u_xlat9)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat9 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat3.x = u_xlat9 * u_xlat9;
    u_xlat1.x = u_xlat3.x * u_xlat3.x;
    u_xlat1.y = (-_Glossiness) + 1.0;
    u_xlat10_1 = texture(unity_NHxRoughness, u_xlat1.xy);
    u_xlat16_3 = u_xlat10_1.w * 16.0;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat2.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat2.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat3.xyz = vec3(u_xlat16_3) * u_xlat2.xyz;
    u_xlat10 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat3.xyz = u_xlat1.xyz * vec3(u_xlat10) + u_xlat3.xyz;
    u_xlat1.x = dot(vs_TEXCOORD6.xyz, vs_TEXCOORD6.xyz);
    u_xlat1.x = sqrt(u_xlat1.x);
    u_xlat1.x = u_xlat1.x * _LightPositionRange.w;
    u_xlat1.x = u_xlat1.x * 0.970000029;
    u_xlat10_2 = texture(_ShadowMapTexture, vs_TEXCOORD6.xyz);
    u_xlatb1 = u_xlat10_2.x<u_xlat1.x;
    u_xlat1.x = (u_xlatb1) ? _LightShadowData.x : 1.0;
    u_xlat4 = dot(vs_TEXCOORD5.xyz, vs_TEXCOORD5.xyz);
    u_xlat10_2 = texture(_LightTexture0, vec2(u_xlat4));
    u_xlat1.x = u_xlat1.x * u_xlat10_2.w;
    u_xlat1.xyz = u_xlat1.xxx * _LightColor0.xyz;
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    SV_Target0.xyz = u_xlat3.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: POINT_COOKIE SHADOWS_CUBE 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"

Constant Buffer "Globals" (352 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 48
  Matrix4x4 unity_ObjectToWorld at 112
  Matrix4x4 unity_WorldToObject at 176
  Matrix4x4 unity_WorldToLight at 288
  Vector3 _WorldSpaceCameraPos at 0
  Vector4 _WorldSpaceLightPos0 at 16
  Vector4 _LightPositionRange at 32
  Vector4 _MainTex_ST at 240
  Vector4 _DetailAlbedoMap_ST at 256
  ScalarHalf _UVSec at 272
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float3 _WorldSpaceCameraPos;
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    half3 NORMAL0 [[ attribute(1) ]] ;
    float2 TEXCOORD0 [[ attribute(2) ]] ;
    float2 TEXCOORD1 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float3 u_xlat1;
    float u_xlat6;
    float u_xlat7;
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-Globals._WorldSpaceCameraPos.xyzx.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = rsqrt(u_xlat6);
    u_xlat1.xyz = float3(u_xlat6) * u_xlat1.xyz;
    output.TEXCOORD1.xyz = half3(u_xlat1.xyz);
    u_xlat1.xyz = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    output.TEXCOORD6.xyz = u_xlat0.xyz + (-Globals._LightPositionRange.xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat0.xyw = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD2.w = half(u_xlat0.x);
    output.TEXCOORD2.xyz = half3(0.0, 0.0, 0.0);
    output.TEXCOORD3.w = half(u_xlat0.y);
    output.TEXCOORD3.xyz = half3(0.0, 0.0, 0.0);
    u_xlat1.x = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(float3(input.NORMAL0.xyz), Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat7 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat7 = rsqrt(u_xlat7);
    u_xlat0.xyz = float3(u_xlat7) * u_xlat1.xyz;
    output.TEXCOORD4 = half4(u_xlat0);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2] * input.POSITION0.zzzz + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3] * input.POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * Globals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    output.TEXCOORD5.xyz = Globals.hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_LightTextureB0" to slot 1
Set CUBE Texture "_LightTexture0" to slot 2
Set CUBE Texture "_ShadowMapTexture" to slot 3
Set 2D Texture "unity_NHxRoughness" to slot 4

Constant Buffer "Globals" (44 bytes) on slot 0 {
  Vector4 _LightPositionRange at 0
  VectorHalf4 _LightShadowData at 16
  VectorHalf4 _LightColor0 at 24
  VectorHalf4 _Color at 32
  ScalarHalf _Metallic at 40
  ScalarHalf _Glossiness at 42
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    half4 _LightShadowData;
    half4 _LightColor0;
    half4 _Color;
    half _Metallic;
    half _Glossiness;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
    half3 TEXCOORD1 [[ user(TEXCOORD1) ]] ;
    half4 TEXCOORD2 [[ user(TEXCOORD2) ]] ;
    half4 TEXCOORD3 [[ user(TEXCOORD3) ]] ;
    half4 TEXCOORD4 [[ user(TEXCOORD4) ]] ;
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]] ;
    float3 TEXCOORD6 [[ user(TEXCOORD6) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _LightTextureB0 [[ texture (1) ]] ,
    sampler sampler_LightTextureB0 [[ sampler (1) ]] ,
    texturecube<half, access::sample > _LightTexture0 [[ texture (2) ]] ,
    sampler sampler_LightTexture0 [[ sampler (2) ]] ,
    texturecube<float, access::sample > _ShadowMapTexture [[ texture (3) ]] ,
    sampler sampler_ShadowMapTexture [[ sampler (3) ]] ,
    texture2d<half, access::sample > unity_NHxRoughness [[ texture (4) ]] ,
    sampler samplerunity_NHxRoughness [[ sampler (4) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half3 u_xlat16_0;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    float u_xlat3;
    half u_xlat16_3;
    bool u_xlatb3;
    half3 u_xlat16_4;
    float u_xlat7;
    half3 u_xlat16_7;
    half u_xlat16_12;
    u_xlat16_0.x = dot(input.TEXCOORD4.xyz, input.TEXCOORD4.xyz);
    u_xlat16_0.x = rsqrt(u_xlat16_0.x);
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * input.TEXCOORD4.xyz);
    u_xlat16_12 = dot((-input.TEXCOORD1.xyz), u_xlat16_0.xyz);
    u_xlat16_12 = half(u_xlat16_12 + u_xlat16_12);
    u_xlat16_1.xyz = half3(u_xlat16_0.xyz * (-half3(u_xlat16_12)) + (-input.TEXCOORD1.xyz));
    u_xlat16_2.x = input.TEXCOORD2.w;
    u_xlat16_2.y = input.TEXCOORD3.w;
    u_xlat16_2.z = input.TEXCOORD4.w;
    u_xlat16_12 = dot(u_xlat16_1.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = dot(u_xlat16_0.xyz, u_xlat16_2.xyz);
    u_xlat16_0.x = clamp(u_xlat16_0.x, 0.0h, 1.0h);
    u_xlat16_4.x = half(u_xlat16_12 * u_xlat16_12);
    u_xlat16_1.x = half(u_xlat16_4.x * u_xlat16_4.x);
    u_xlat16_1.y = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_3 = unity_NHxRoughness.sample(samplerunity_NHxRoughness, float2(u_xlat16_1.xy)).w;
    u_xlat16_3 = half(float(u_xlat16_3) * 16.0);
    u_xlat16_7.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_4.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_7.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_7.xyz = half3(u_xlat16_7.xyz * Globals._Color.xyz);
    u_xlat16_4.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_4.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_4.xyz = half3(u_xlat16_4.xyz * half3(u_xlat16_3));
    u_xlat16_1.x = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_4.xyz = half3(u_xlat16_7.xyz * u_xlat16_1.xxx + u_xlat16_4.xyz);
    u_xlat3 = dot(input.TEXCOORD6.xyz, input.TEXCOORD6.xyz);
    u_xlat3 = sqrt(u_xlat3);
    u_xlat3 = u_xlat3 * Globals._LightPositionRange.w;
    u_xlat3 = u_xlat3 * 0.970000029;
    u_xlat7 = _ShadowMapTexture.sample(sampler_ShadowMapTexture, input.TEXCOORD6.xyz).x;
    u_xlatb3 = u_xlat7<u_xlat3;
    u_xlat16_1.x = (u_xlatb3) ? Globals._LightShadowData.x : 1.0;
    u_xlat3 = dot(input.TEXCOORD5.xyz, input.TEXCOORD5.xyz);
    u_xlat16_3 = _LightTextureB0.sample(sampler_LightTextureB0, float2(u_xlat3)).w;
    u_xlat16_7.x = _LightTexture0.sample(sampler_LightTexture0, input.TEXCOORD5.xyz).w;
    u_xlat16_3 = half(u_xlat16_7.x * u_xlat16_3);
    u_xlat16_3 = half(u_xlat16_1.x * u_xlat16_3);
    u_xlat16_1.xyz = half3(half3(u_xlat16_3) * Globals._LightColor0.xyz);
    u_xlat16_1.xyz = half3(u_xlat16_0.xxx * u_xlat16_1.xyz);
    output.SV_Target0.xyz = half3(u_xlat16_4.xyz * u_xlat16_1.xyz);
    output.SV_Target0.w = 1.0;
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec3 _WorldSpaceCameraPos;
uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 _LightPositionRange;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	vec4 hlslcc_mtx4x4unity_WorldToLight[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
out vec4 vs_TEXCOORD0;
out vec3 vs_TEXCOORD1;
out vec4 vs_TEXCOORD2;
out vec4 vs_TEXCOORD3;
out vec4 vs_TEXCOORD4;
out vec3 vs_TEXCOORD5;
out vec3 vs_TEXCOORD6;
vec4 u_xlat0;
bool u_xlatb0;
vec3 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    u_xlat1.xyz = u_xlat0.xyz + (-_WorldSpaceCameraPos.xyz);
    u_xlat6 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat1.xyz;
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    vs_TEXCOORD6.xyz = u_xlat0.xyz + (-_LightPositionRange.xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat1.xyz;
    u_xlat0.w = 0.0;
    vs_TEXCOORD2 = u_xlat0.wwwx;
    vs_TEXCOORD3 = u_xlat0.wwwy;
    vs_TEXCOORD4.w = u_xlat0.z;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD4.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[3] * in_POSITION0.wwww + u_xlat0;
    u_xlat1.xyz = u_xlat0.yyy * hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = hlslcc_mtx4x4unity_WorldToLight[0].xyz * u_xlat0.xxx + u_xlat1.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_WorldToLight[2].xyz * u_xlat0.zzz + u_xlat1.xyz;
    vs_TEXCOORD5.xyz = hlslcc_mtx4x4unity_WorldToLight[3].xyz * u_xlat0.www + u_xlat0.xyz;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 _LightShadowData;
uniform 	vec4 _LightColor0;
uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform  sampler2D _MainTex;
uniform  sampler2D _LightTextureB0;
uniform  samplerCube _LightTexture0;
uniform  samplerCube _ShadowMapTexture;
uniform  sampler2D unity_NHxRoughness;
in  vec4 vs_TEXCOORD0;
in  vec3 vs_TEXCOORD1;
in  vec4 vs_TEXCOORD2;
in  vec4 vs_TEXCOORD3;
in  vec4 vs_TEXCOORD4;
in  vec3 vs_TEXCOORD5;
in  vec3 vs_TEXCOORD6;
layout(location = 0) out vec4 SV_Target0;
vec3 u_xlat0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
bool u_xlatb1;
vec3 u_xlat2;
lowp vec4 u_xlat10_2;
lowp vec4 u_xlat10_3;
vec3 u_xlat4;
mediump float u_xlat16_4;
float u_xlat5;
mediump float u_xlat16_5;
float u_xlat12;
float u_xlat13;
void main()
{
    u_xlat0.x = dot(vs_TEXCOORD4.xyz, vs_TEXCOORD4.xyz);
    u_xlat0.x = inversesqrt(u_xlat0.x);
    u_xlat0.xyz = u_xlat0.xxx * vs_TEXCOORD4.xyz;
    u_xlat12 = dot((-vs_TEXCOORD1.xyz), u_xlat0.xyz);
    u_xlat12 = u_xlat12 + u_xlat12;
    u_xlat1.xyz = u_xlat0.xyz * (-vec3(u_xlat12)) + (-vs_TEXCOORD1.xyz);
    u_xlat2.x = vs_TEXCOORD2.w;
    u_xlat2.y = vs_TEXCOORD3.w;
    u_xlat2.z = vs_TEXCOORD4.w;
    u_xlat12 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat0.x = dot(u_xlat0.xyz, u_xlat2.xyz);
    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);
    u_xlat4.x = u_xlat12 * u_xlat12;
    u_xlat1.x = u_xlat4.x * u_xlat4.x;
    u_xlat1.y = (-_Glossiness) + 1.0;
    u_xlat10_1 = texture(unity_NHxRoughness, u_xlat1.xy);
    u_xlat16_4 = u_xlat10_1.w * 16.0;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat2.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat2.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat4.xyz = vec3(u_xlat16_4) * u_xlat2.xyz;
    u_xlat13 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat4.xyz = u_xlat1.xyz * vec3(u_xlat13) + u_xlat4.xyz;
    u_xlat1.x = dot(vs_TEXCOORD6.xyz, vs_TEXCOORD6.xyz);
    u_xlat1.x = sqrt(u_xlat1.x);
    u_xlat1.x = u_xlat1.x * _LightPositionRange.w;
    u_xlat1.x = u_xlat1.x * 0.970000029;
    u_xlat10_2 = texture(_ShadowMapTexture, vs_TEXCOORD6.xyz);
    u_xlatb1 = u_xlat10_2.x<u_xlat1.x;
    u_xlat1.x = (u_xlatb1) ? _LightShadowData.x : 1.0;
    u_xlat5 = dot(vs_TEXCOORD5.xyz, vs_TEXCOORD5.xyz);
    u_xlat10_2 = texture(_LightTextureB0, vec2(u_xlat5));
    u_xlat10_3 = texture(_LightTexture0, vs_TEXCOORD5.xyz);
    u_xlat16_5 = u_xlat10_2.w * u_xlat10_3.w;
    u_xlat1.x = u_xlat1.x * u_xlat16_5;
    u_xlat1.xyz = u_xlat1.xxx * _LightColor0.xyz;
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    SV_Target0.xyz = u_xlat4.xyz * u_xlat1.xyz;
    SV_Target0.w = 1.0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

 }
 Pass {
  Name "SHADOWCASTER"
  Tags { "LIGHTMODE"="SHADOWCASTER" "SHADOWSUPPORT"="true" "RenderType"="Opaque" "PerformanceChecks"="False" }
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
Keywords set in this variant: SHADOWS_DEPTH 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "Color"

Constant Buffer "Globals" (288 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 32
  Matrix4x4 unity_ObjectToWorld at 96
  Matrix4x4 unity_WorldToObject at 160
  Matrix4x4 unity_MatrixVP at 224
  Vector4 _WorldSpaceLightPos0 at 0
  Vector4 unity_LightShadowBias at 16
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _WorldSpaceLightPos0;
    float4 unity_LightShadowBias;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float3 NORMAL0 [[ attribute(1) ]] ;
};

struct Mtl_VertexOut
{
    float4 mtl_Position [[ position ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    float4 u_xlat1;
    float3 u_xlat2;
    bool u_xlatb2;
    float u_xlat6;
    float u_xlat9;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz;
    u_xlat1.xyz = (-u_xlat0.xyz) * Globals._WorldSpaceLightPos0.www + Globals._WorldSpaceLightPos0.xyz;
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat1.xyz = float3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.x = dot(input.NORMAL0.xyz, Globals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(input.NORMAL0.xyz, Globals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(input.NORMAL0.xyz, Globals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = rsqrt(u_xlat9);
    u_xlat2.xyz = float3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat9 = (-u_xlat9) * u_xlat9 + 1.0;
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * Globals.unity_LightShadowBias.z;
    u_xlat0.xyz = (-u_xlat2.xyz) * float3(u_xlat9) + u_xlat0.xyz;
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = Globals.hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = u_xlat0 + Globals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat1 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat1 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat1;
    u_xlat1 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat1;
    u_xlat1 = u_xlat1 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb2 = Globals.unity_LightShadowBias.z!=0.0;
    u_xlat0 = (bool(u_xlatb2)) ? u_xlat0 : u_xlat1;
    u_xlat1.x = Globals.unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = max(u_xlat1.x, -1.0);
    u_xlat1.x = min(u_xlat1.x, 0.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = min(u_xlat0.w, u_xlat6);
    output.mtl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    output.mtl_Position.z = Globals.unity_LightShadowBias.y * u_xlat0.x + u_xlat6;
    return output;
}


-- Fragment shader for "metal":
Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
)
{
    Mtl_FragmentOut output;
    output.SV_Target0 = half4(0.0, 0.0, 0.0, 0.0);
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _WorldSpaceLightPos0;
uniform 	vec4 unity_LightShadowBias;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform 	vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform 	vec4 hlslcc_mtx4x4unity_MatrixVP[4];
in  vec4 in_POSITION0;
in  vec3 in_NORMAL0;
vec4 u_xlat0;
vec4 u_xlat1;
vec3 u_xlat2;
bool u_xlatb2;
float u_xlat6;
float u_xlat9;
void main()
{
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = u_xlat0.xyz + hlslcc_mtx4x4unity_ObjectToWorld[3].xyz;
    u_xlat1.xyz = (-u_xlat0.xyz) * _WorldSpaceLightPos0.www + _WorldSpaceLightPos0.xyz;
    u_xlat9 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat1.xyz = vec3(u_xlat9) * u_xlat1.xyz;
    u_xlat2.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat9 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat9 = inversesqrt(u_xlat9);
    u_xlat2.xyz = vec3(u_xlat9) * u_xlat2.xyz;
    u_xlat9 = dot(u_xlat2.xyz, u_xlat1.xyz);
    u_xlat9 = (-u_xlat9) * u_xlat9 + 1.0;
    u_xlat9 = sqrt(u_xlat9);
    u_xlat9 = u_xlat9 * unity_LightShadowBias.z;
    u_xlat0.xyz = (-u_xlat2.xyz) * vec3(u_xlat9) + u_xlat0.xyz;
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat1 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat1 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat1;
    u_xlat1 = u_xlat1 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    u_xlatb2 = unity_LightShadowBias.z!=0.0;
    u_xlat0 = (bool(u_xlatb2)) ? u_xlat0 : u_xlat1;
    u_xlat1.x = unity_LightShadowBias.x / u_xlat0.w;
    u_xlat1.x = clamp(u_xlat1.x, 0.0, 1.0);
    u_xlat6 = u_xlat0.z + u_xlat1.x;
    u_xlat1.x = max((-u_xlat0.w), u_xlat6);
    gl_Position.xyw = u_xlat0.xyw;
    u_xlat0.x = (-u_xlat6) + u_xlat1.x;
    gl_Position.z = unity_LightShadowBias.y * u_xlat0.x + u_xlat6;
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

layout(location = 0) out vec4 SV_Target0;
void main()
{
    SV_Target0 = vec4(0.0, 0.0, 0.0, 0.0);
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: SHADOWS_CUBE 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"

Constant Buffer "Globals" (144 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 16
  Matrix4x4 unity_ObjectToWorld at 80
  Vector4 _LightPositionRange at 0
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
};

struct Mtl_VertexOut
{
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 mtl_Position [[ position ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    u_xlat0.xyz = input.POSITION0.yyy * Globals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * input.POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * input.POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = Globals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * input.POSITION0.www + u_xlat0.xyz;
    output.TEXCOORD0.xyz = u_xlat0.xyz + (-Globals._LightPositionRange.xyz);
    u_xlat0 = input.POSITION0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * input.POSITION0.xxxx + u_xlat0;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * input.POSITION0.zzzz + u_xlat0;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    return output;
}


-- Fragment shader for "metal":
Constant Buffer "Globals" (32 bytes) on slot 0 {
  Vector4 _LightPositionRange at 0
  Vector4 unity_LightShadowBias at 16
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 _LightPositionRange;
    float4 unity_LightShadowBias;
};

struct Mtl_FragmentIn
{
    float3 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
};

struct Mtl_FragmentOut
{
    half4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    float4 u_xlat0;
    u_xlat0.x = dot(input.TEXCOORD0.xyz, input.TEXCOORD0.xyz);
    u_xlat0.x = sqrt(u_xlat0.x);
    u_xlat0.x = u_xlat0.x + Globals.unity_LightShadowBias.x;
    u_xlat0 = u_xlat0.xxxx * Globals._LightPositionRange.wwww;
    output.SV_Target0 = half4(u_xlat0);
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
in  vec4 in_POSITION0;
out vec3 vs_TEXCOORD0;
vec4 u_xlat0;
void main()
{
    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;
    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;
    vs_TEXCOORD0.xyz = u_xlat0.xyz + (-_LightPositionRange.xyz);
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * in_POSITION0.zzzz + u_xlat0;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _LightPositionRange;
uniform 	vec4 unity_LightShadowBias;
in  vec3 vs_TEXCOORD0;
layout(location = 0) out vec4 SV_Target0;
float u_xlat0;
void main()
{
    u_xlat0 = dot(vs_TEXCOORD0.xyz, vs_TEXCOORD0.xyz);
    u_xlat0 = sqrt(u_xlat0);
    u_xlat0 = u_xlat0 + unity_LightShadowBias.x;
    SV_Target0 = vec4(u_xlat0) * _LightPositionRange.wwww;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

 }
 Pass {
  Name "META"
  Tags { "LIGHTMODE"="Meta" "RenderType"="Opaque" "PerformanceChecks"="False" }
  Cull Off
  //////////////////////////////////
  //                              //
  //      Compiled programs       //
  //                              //
  //////////////////////////////////
//////////////////////////////////////////////////////
No keywords set in this variant.
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"

Constant Buffer "Globals" (136 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 0
  Vector4 unity_LightmapST at 64
  Vector4 unity_DynamicLightmapST at 80
  Vector4 _MainTex_ST at 96
  Vector4 _DetailAlbedoMap_ST at 112
  ScalarHalf _UVSec at 128
  VectorBool4 unity_MetaVertexControl at 132
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    bool4 unity_MetaVertexControl;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float2 TEXCOORD1 [[ attribute(2) ]] ;
    float2 TEXCOORD2 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 mtl_Position [[ position ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool u_xlatb6;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlatb0 = 0.0<input.POSITION0.z;
    u_xlat0.z = u_xlatb0 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xy = input.TEXCOORD1.xy * Globals.unity_LightmapST.xy + Globals.unity_LightmapST.zw;
    u_xlat0.xyz = (Globals.unity_MetaVertexControl.x) ? u_xlat0.xyz : input.POSITION0.xyz;
    u_xlatb6 = 0.0<u_xlat0.z;
    u_xlat1.z = u_xlatb6 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    u_xlat0.xyz = (Globals.unity_MetaVertexControl.y) ? u_xlat1.xyz : u_xlat0.xyz;
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat1 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0

Constant Buffer "Globals" (24 bytes) on slot 0 {
  VectorHalf4 _Color at 0
  ScalarHalf _Metallic at 8
  ScalarHalf _Glossiness at 10
  VectorBool4 unity_MetaFragmentControl at 12
  Float unity_OneOverOutputBoost at 16
  Float unity_MaxOutputValue at 20
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    bool4 unity_MetaFragmentControl;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
};

struct Mtl_FragmentOut
{
    float4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    float3 u_xlat1;
    half3 u_xlat16_1;
    half3 u_xlat16_2;
    half u_xlat16_6;
    float u_xlat7;
    u_xlat16_0.x = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_0.x);
    u_xlat16_1.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_2.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_1.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_1.xyz = half3(u_xlat16_1.xyz * Globals._Color.xyz);
    u_xlat16_2.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_2.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * u_xlat16_2.xyz);
    u_xlat16_0.xyz = half3(float3(u_xlat16_0.xyz) * float3(0.5, 0.5, 0.5));
    u_xlat16_6 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_6) + u_xlat16_0.xyz);
    u_xlat16_1.xyz = log2(u_xlat16_0.xyz);
    u_xlat7 = Globals.unity_OneOverOutputBoost;
    u_xlat7 = clamp(u_xlat7, 0.0f, 1.0f);
    u_xlat1.xyz = float3(u_xlat16_1.xyz) * float3(u_xlat7);
    u_xlat1.xyz = exp2(u_xlat1.xyz);
    u_xlat1.xyz = min(u_xlat1.xyz, float3(Globals.unity_MaxOutputValue));
    u_xlat16_0.xyz = (Globals.unity_MetaFragmentControl.x) ? half3(u_xlat1.xyz) : half3(0.0, 0.0, 0.0);
    u_xlat16_0.w = (Globals.unity_MetaFragmentControl.x) ? 1.0 : 0.0;
    u_xlat16_0 = (Globals.unity_MetaFragmentControl.y) ? half4(0.0, 0.0, 0.0, 0.0235294122) : u_xlat16_0;
    output.SV_Target0 = float4(u_xlat16_0);
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 unity_LightmapST;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	bvec4 unity_MetaVertexControl;
in  vec4 in_POSITION0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
out vec4 vs_TEXCOORD0;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
bool u_xlatb6;
void main()
{
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlatb0 = 0.0<in_POSITION0.z;
    u_xlat0.z = u_xlatb0 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xy = in_TEXCOORD1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    u_xlat0.xyz = (unity_MetaVertexControl.x) ? u_xlat0.xyz : in_POSITION0.xyz;
    u_xlatb6 = 0.0<u_xlat0.z;
    u_xlat1.z = u_xlatb6 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xy = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    u_xlat0.xyz = (unity_MetaVertexControl.y) ? u_xlat1.xyz : u_xlat0.xyz;
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat1 = hlslcc_mtx4x4glstate_matrix_mvp[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	bvec4 unity_MetaFragmentControl;
uniform 	float unity_OneOverOutputBoost;
uniform 	float unity_MaxOutputValue;
uniform  sampler2D _MainTex;
in  vec4 vs_TEXCOORD0;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec3 u_xlat2;
float u_xlat6;
void main()
{
    u_xlat0.x = (-_Glossiness) + 1.0;
    u_xlat0.x = u_xlat0.x * u_xlat0.x;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat2.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat2.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat2.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat2.xyz;
    u_xlat0.xyz = u_xlat0.xyz * vec3(0.5, 0.5, 0.5);
    u_xlat6 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat1.xyz * vec3(u_xlat6) + u_xlat0.xyz;
    u_xlat0.xyz = log2(u_xlat0.xyz);
    u_xlat6 = unity_OneOverOutputBoost;
    u_xlat6 = clamp(u_xlat6, 0.0, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * vec3(u_xlat6);
    u_xlat0.xyz = exp2(u_xlat0.xyz);
    u_xlat0.xyz = min(u_xlat0.xyz, vec3(vec3(unity_MaxOutputValue, unity_MaxOutputValue, unity_MaxOutputValue)));
    u_xlat0.w = 1.0;
    u_xlat0 = (unity_MetaFragmentControl.x) ? u_xlat0 : vec4(0.0, 0.0, 0.0, 0.0);
    SV_Target0 = (unity_MetaFragmentControl.y) ? vec4(0.0, 0.0, 0.0, 0.0235294122) : u_xlat0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

//////////////////////////////////////////////////////
Keywords set in this variant: _EMISSION 
-- Vertex shader for "metal":
Uses vertex data channel "Vertex"
Uses vertex data channel "TexCoord"
Uses vertex data channel "TexCoord0"
Uses vertex data channel "TexCoord1"

Constant Buffer "Globals" (136 bytes) on slot 0 {
  Matrix4x4 glstate_matrix_mvp at 0
  Vector4 unity_LightmapST at 64
  Vector4 unity_DynamicLightmapST at 80
  Vector4 _MainTex_ST at 96
  Vector4 _DetailAlbedoMap_ST at 112
  ScalarHalf _UVSec at 128
  VectorBool4 unity_MetaVertexControl at 132
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    float4 hlslcc_mtx4x4glstate_matrix_mvp[4];
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 _MainTex_ST;
    float4 _DetailAlbedoMap_ST;
    half _UVSec;
    bool4 unity_MetaVertexControl;
};

struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float2 TEXCOORD0 [[ attribute(1) ]] ;
    float2 TEXCOORD1 [[ attribute(2) ]] ;
    float2 TEXCOORD2 [[ attribute(3) ]] ;
};

struct Mtl_VertexOut
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 mtl_Position [[ position ]];
};

vertex Mtl_VertexOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    Mtl_VertexIn input [[ stage_in ]])
{
    Mtl_VertexOut output;
    float4 u_xlat0;
    bool u_xlatb0;
    float4 u_xlat1;
    bool u_xlatb6;
    u_xlatb0 = Globals._UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? input.TEXCOORD0.xy : input.TEXCOORD1.xy;
    output.TEXCOORD0.zw = u_xlat0.xy * Globals._DetailAlbedoMap_ST.xy + Globals._DetailAlbedoMap_ST.zw;
    output.TEXCOORD0.xy = input.TEXCOORD0.xy * Globals._MainTex_ST.xy + Globals._MainTex_ST.zw;
    u_xlatb0 = 0.0<input.POSITION0.z;
    u_xlat0.z = u_xlatb0 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xy = input.TEXCOORD1.xy * Globals.unity_LightmapST.xy + Globals.unity_LightmapST.zw;
    u_xlat0.xyz = (Globals.unity_MetaVertexControl.x) ? u_xlat0.xyz : input.POSITION0.xyz;
    u_xlatb6 = 0.0<u_xlat0.z;
    u_xlat1.z = u_xlatb6 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xy = input.TEXCOORD2.xy * Globals.unity_DynamicLightmapST.xy + Globals.unity_DynamicLightmapST.zw;
    u_xlat0.xyz = (Globals.unity_MetaVertexControl.y) ? u_xlat1.xyz : u_xlat0.xyz;
    u_xlat1 = u_xlat0.yyyy * Globals.hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat1 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat0 = Globals.hlslcc_mtx4x4glstate_matrix_mvp[2] * u_xlat0.zzzz + u_xlat1;
    output.mtl_Position = u_xlat0 + Globals.hlslcc_mtx4x4glstate_matrix_mvp[3];
    return output;
}


-- Fragment shader for "metal":
Set 2D Texture "_MainTex" to slot 0
Set 2D Texture "_EmissionMap" to slot 1

Constant Buffer "Globals" (40 bytes) on slot 0 {
  VectorHalf4 _Color at 0
  ScalarHalf _Metallic at 8
  ScalarHalf _Glossiness at 10
  VectorHalf4 _EmissionColor at 16
  VectorBool4 unity_MetaFragmentControl at 24
  Float unity_OneOverOutputBoost at 28
  Float unity_MaxOutputValue at 32
  Float unity_UseLinearSpace at 36
}

Shader Disassembly:
#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Globals_Type
{
    half4 _Color;
    half _Metallic;
    half _Glossiness;
    half4 _EmissionColor;
    bool4 unity_MetaFragmentControl;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
};

struct Mtl_FragmentIn
{
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]] ;
};

struct Mtl_FragmentOut
{
    float4 SV_Target0 [[ color(0) ]];
};

fragment Mtl_FragmentOut xlatMtlMain(
    constant Globals_Type& Globals [[ buffer(0) ]],
    texture2d<half, access::sample > _MainTex [[ texture (0) ]] ,
    sampler sampler_MainTex [[ sampler (0) ]] ,
    texture2d<half, access::sample > _EmissionMap [[ texture (1) ]] ,
    sampler sampler_EmissionMap [[ sampler (1) ]] ,
    Mtl_FragmentIn input [[ stage_in ]])
{
    Mtl_FragmentOut output;
    half4 u_xlat16_0;
    float3 u_xlat1;
    half3 u_xlat16_1;
    float4 u_xlat2;
    half u_xlat16_2;
    half3 u_xlat16_3;
    half3 u_xlat16_4;
    half u_xlat16_12;
    float u_xlat13;
    half u_xlat16_13;
    bool u_xlatb13;
    u_xlat16_0.x = half((-float(Globals._Glossiness)) + 1.0);
    u_xlat16_0.x = half(u_xlat16_0.x * u_xlat16_0.x);
    u_xlat16_1.xyz = _MainTex.sample(sampler_MainTex, input.TEXCOORD0.xy).xyz;
    u_xlat16_4.xyz = half3(float3(Globals._Color.xyz) * float3(u_xlat16_1.xyz) + float3(-0.220916301, -0.220916301, -0.220916301));
    u_xlat16_1.xyz = half3(u_xlat16_1.xyz * Globals._Color.xyz);
    u_xlat16_4.xyz = half3(float3(Globals._Metallic) * float3(u_xlat16_4.xyz) + float3(0.220916301, 0.220916301, 0.220916301));
    u_xlat16_0.xyz = half3(u_xlat16_0.xxx * u_xlat16_4.xyz);
    u_xlat16_0.xyz = half3(float3(u_xlat16_0.xyz) * float3(0.5, 0.5, 0.5));
    u_xlat16_12 = half((-float(Globals._Metallic)) * 0.779083729 + 0.779083729);
    u_xlat16_0.xyz = half3(u_xlat16_1.xyz * half3(u_xlat16_12) + u_xlat16_0.xyz);
    u_xlat16_1.xyz = log2(u_xlat16_0.xyz);
    u_xlat13 = Globals.unity_OneOverOutputBoost;
    u_xlat13 = clamp(u_xlat13, 0.0f, 1.0f);
    u_xlat1.xyz = float3(u_xlat16_1.xyz) * float3(u_xlat13);
    u_xlat1.xyz = exp2(u_xlat1.xyz);
    u_xlat1.xyz = min(u_xlat1.xyz, float3(Globals.unity_MaxOutputValue));
    u_xlat16_0.xyz = (Globals.unity_MetaFragmentControl.x) ? half3(u_xlat1.xyz) : half3(0.0, 0.0, 0.0);
    u_xlat16_1.xyz = _EmissionMap.sample(sampler_EmissionMap, input.TEXCOORD0.xy).xyz;
    u_xlat1.xyz = float3(u_xlat16_1.xyz) * float3(Globals._EmissionColor.xyz);
    u_xlat2.xyz = u_xlat1.xyz * float3(0.305306017, 0.305306017, 0.305306017) + float3(0.682171106, 0.682171106, 0.682171106);
    u_xlat2.xyz = u_xlat1.xyz * u_xlat2.xyz + float3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat2.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlatb13 = float(0.0)!=Globals.unity_UseLinearSpace;
    u_xlat16_3.xyz = (bool(u_xlatb13)) ? half3(u_xlat1.xyz) : half3(u_xlat2.xyz);
    u_xlat16_1.xyz = half3(float3(u_xlat16_3.xyz) * float3(0.010309278, 0.010309278, 0.010309278));
    u_xlat16_13 = max(u_xlat16_1.y, u_xlat16_1.x);
    u_xlat16_2 = half(max(float(u_xlat16_1.z), 0.0199999996));
    u_xlat16_13 = max(u_xlat16_13, u_xlat16_2);
    u_xlat13 = float(u_xlat16_13) * 255.0;
    u_xlat13 = ceil(u_xlat13);
    u_xlat2.w = u_xlat13 * 0.00392156886;
    u_xlat2.xyz = float3(u_xlat16_1.xyz) / u_xlat2.www;
    u_xlat16_0.w = (Globals.unity_MetaFragmentControl.x) ? 1.0 : 0.0;
    u_xlat16_0 = (Globals.unity_MetaFragmentControl.y) ? half4(u_xlat2) : u_xlat16_0;
    output.SV_Target0 = float4(u_xlat16_0);
    return output;
}


-- Vertex shader for "glcore":
Shader Disassembly:
#ifdef VERTEX
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 hlslcc_mtx4x4glstate_matrix_mvp[4];
uniform 	vec4 unity_LightmapST;
uniform 	vec4 unity_DynamicLightmapST;
uniform 	vec4 _MainTex_ST;
uniform 	vec4 _DetailAlbedoMap_ST;
uniform 	float _UVSec;
uniform 	bvec4 unity_MetaVertexControl;
in  vec4 in_POSITION0;
in  vec2 in_TEXCOORD0;
in  vec2 in_TEXCOORD1;
in  vec2 in_TEXCOORD2;
out vec4 vs_TEXCOORD0;
vec4 u_xlat0;
bool u_xlatb0;
vec4 u_xlat1;
bool u_xlatb6;
void main()
{
    u_xlatb0 = _UVSec==0.0;
    u_xlat0.xy = (bool(u_xlatb0)) ? in_TEXCOORD0.xy : in_TEXCOORD1.xy;
    vs_TEXCOORD0.zw = u_xlat0.xy * _DetailAlbedoMap_ST.xy + _DetailAlbedoMap_ST.zw;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlatb0 = 0.0<in_POSITION0.z;
    u_xlat0.z = u_xlatb0 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xy = in_TEXCOORD1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
    u_xlat0.xyz = (unity_MetaVertexControl.x) ? u_xlat0.xyz : in_POSITION0.xyz;
    u_xlatb6 = 0.0<u_xlat0.z;
    u_xlat1.z = u_xlatb6 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xy = in_TEXCOORD2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
    u_xlat0.xyz = (unity_MetaVertexControl.y) ? u_xlat1.xyz : u_xlat0.xyz;
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4glstate_matrix_mvp[1];
    u_xlat1 = hlslcc_mtx4x4glstate_matrix_mvp[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat0 = hlslcc_mtx4x4glstate_matrix_mvp[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = u_xlat0 + hlslcc_mtx4x4glstate_matrix_mvp[3];
    return;
}

#endif
#ifdef FRAGMENT
#version 150
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_shader_bit_encoding : enable

uniform 	vec4 _Color;
uniform 	float _Metallic;
uniform 	float _Glossiness;
uniform 	vec4 _EmissionColor;
uniform 	bvec4 unity_MetaFragmentControl;
uniform 	float unity_OneOverOutputBoost;
uniform 	float unity_MaxOutputValue;
uniform 	float unity_UseLinearSpace;
uniform  sampler2D _MainTex;
uniform  sampler2D _EmissionMap;
in  vec4 vs_TEXCOORD0;
layout(location = 0) out vec4 SV_Target0;
vec4 u_xlat0;
vec3 u_xlat1;
lowp vec4 u_xlat10_1;
vec4 u_xlat2;
vec3 u_xlat3;
float u_xlat9;
float u_xlat10;
bool u_xlatb10;
void main()
{
    u_xlat0.x = (-_Glossiness) + 1.0;
    u_xlat0.x = u_xlat0.x * u_xlat0.x;
    u_xlat10_1 = texture(_MainTex, vs_TEXCOORD0.xy);
    u_xlat3.xyz = _Color.xyz * u_xlat10_1.xyz + vec3(-0.220916301, -0.220916301, -0.220916301);
    u_xlat1.xyz = u_xlat10_1.xyz * _Color.xyz;
    u_xlat3.xyz = vec3(vec3(_Metallic, _Metallic, _Metallic)) * u_xlat3.xyz + vec3(0.220916301, 0.220916301, 0.220916301);
    u_xlat0.xyz = u_xlat0.xxx * u_xlat3.xyz;
    u_xlat0.xyz = u_xlat0.xyz * vec3(0.5, 0.5, 0.5);
    u_xlat9 = (-_Metallic) * 0.779083729 + 0.779083729;
    u_xlat0.xyz = u_xlat1.xyz * vec3(u_xlat9) + u_xlat0.xyz;
    u_xlat0.xyz = log2(u_xlat0.xyz);
    u_xlat9 = unity_OneOverOutputBoost;
    u_xlat9 = clamp(u_xlat9, 0.0, 1.0);
    u_xlat0.xyz = u_xlat0.xyz * vec3(u_xlat9);
    u_xlat0.xyz = exp2(u_xlat0.xyz);
    u_xlat0.xyz = min(u_xlat0.xyz, vec3(vec3(unity_MaxOutputValue, unity_MaxOutputValue, unity_MaxOutputValue)));
    u_xlat0.w = 1.0;
    u_xlat0 = (unity_MetaFragmentControl.x) ? u_xlat0 : vec4(0.0, 0.0, 0.0, 0.0);
    u_xlat10_1 = texture(_EmissionMap, vs_TEXCOORD0.xy);
    u_xlat1.xyz = u_xlat10_1.xyz * _EmissionColor.xyz;
    u_xlat2.xyz = u_xlat1.xyz * vec3(0.305306017, 0.305306017, 0.305306017) + vec3(0.682171106, 0.682171106, 0.682171106);
    u_xlat2.xyz = u_xlat1.xyz * u_xlat2.xyz + vec3(0.0125228781, 0.0125228781, 0.0125228781);
    u_xlat2.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlatb10 = vec4(0.0, 0.0, 0.0, 0.0)!=vec4(unity_UseLinearSpace);
    u_xlat1.xyz = (bool(u_xlatb10)) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlat1.xyz = u_xlat1.xyz * vec3(0.010309278, 0.010309278, 0.010309278);
    u_xlat10 = max(u_xlat1.y, u_xlat1.x);
    u_xlat2.x = max(u_xlat1.z, 0.0199999996);
    u_xlat10 = max(u_xlat10, u_xlat2.x);
    u_xlat10 = u_xlat10 * 255.0;
    u_xlat10 = ceil(u_xlat10);
    u_xlat2.w = u_xlat10 * 0.00392156886;
    u_xlat2.xyz = u_xlat1.xyz / u_xlat2.www;
    SV_Target0 = (unity_MetaFragmentControl.y) ? u_xlat2 : u_xlat0;
    return;
}

#endif


-- Fragment shader for "glcore":
Shader Disassembly:
// All GLSL source is contained within the vertex program

 }
}
CustomEditor "StandardShaderGUI"
Fallback "VertexLit"
}